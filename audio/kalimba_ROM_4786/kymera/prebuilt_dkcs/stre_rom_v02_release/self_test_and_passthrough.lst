
/home/svc-audio-dspsw/kymera_builds/builds/2019/kymera_1903271828/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/self_test_and_passthrough.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_download_self_test_var_ref_test_maxim>:
.MAXIM;

.VAR myVar = 0x1234;

$_download_self_test_var_ref_test_maxim:
    push r10;
84200000:	00 00 c0 f3 	push r10;
    r10 = 10;
84200004:	0a 00 c0 01 	r10 = Null + 10;
    r0 = &$dm2_v5;
84200008:	80 ff 00 fd 	r0 = Null + -8388552;
8420000c:	38 00 20 01 
    do get_value_loop;
84200010:	02 00 f0 e5 	do $M.download_self_test_var_ref_test_maxim.get_value_loop;
        r0 = M[r0];
84200014:	00 00 20 d3 	r0 = M[r0 + Null];

84200018 <$M.download_self_test_var_ref_test_maxim.get_value_loop>:
    get_value_loop:
    pop r10;
84200018:	00 00 c4 f3 	pop r10;
    /* Return GOOD */
    Null = r0 - 0x600D;
8420001c:	0d 60 02 21 	Null = r0 - 24589;
    if NZ jump err;
84200020:	12 00 10 dd 	if NE jump $M.download_self_test_var_ref_test_maxim.err;
    /* Check more variable reference instructions */
    I2 = M[myVar];
84200024:	00 0e 00 fd 	I2 = M[Null + $M.download_self_test_var_ref_test_maxim.myVar];
84200028:	20 93 20 f5 
    Null = I2 - 0x1234;
8420002c:	34 12 02 69 	Null = I2 - 4660;
    if NZ jump err;
84200030:	0e 00 10 dd 	if NE jump $M.download_self_test_var_ref_test_maxim.err;
    r1 = -ADDR_PER_WORD;
84200034:	df 00 30 e4 	r1 = Null - 4;
    r0 = M[r1 + myVar + ADDR_PER_WORD];
84200038:	70 00 00 fd 	r0 = M[r1 + 7340836];
8420003c:	24 03 23 d1 
    Null = r0 - 0x1234;
84200040:	34 12 02 21 	Null = r0 - 4660;
    if NZ jump err;
84200044:	09 00 10 dd 	if NE jump $M.download_self_test_var_ref_test_maxim.err;
    r0 = 0;
84200048:	00 00 20 01 	r0 = Null + 0;
    r1 = ADDR_PER_WORD;
8420004c:	bf 00 30 e4 	r1 = Null + 4;
    r0 = M[r1 + myVar - ADDR_PER_WORD];
84200050:	70 00 00 fd 	r0 = M[r1 + 7340828];
84200054:	1c 03 23 d1 
    Null = r0 - 0x1234;
84200058:	34 12 02 21 	Null = r0 - 4660;
    if NZ jump err;
8420005c:	03 00 10 dd 	if NE jump $M.download_self_test_var_ref_test_maxim.err;
    /* All good */
    r0 = 0x600D;
84200060:	0d 60 20 01 	r0 = Null + 24589;
    rts;
84200064:	0f 00 0d dc 	rts;

84200068 <$M.download_self_test_var_ref_test_maxim.err>:
    err:
        /* Return error */
        r0 = 0xBAD;
84200068:	ad 0b 20 01 	r0 = Null + 2989;
        rts;
8420006c:	0f 00 0d dc 	rts;

84200070 <$_download_self_test_call_from_maxim_to_minim_test_maxim>:
.MODULE $M.download_self_test_call_from_maxim_to_minim_test_maxim;
.CODESEGMENT PM;
.MAXIM;

$_download_self_test_call_from_maxim_to_minim_test_maxim:
    push rLink;
84200070:	00 00 d0 f3 	push rLink;
    r0 = 1;
84200074:	2f 00 20 e4 	r0 = Null + 1;
    call $_func_increase_one_with_param_asm;
84200078:	20 04 00 fd 	call (m) $_func_increase_one_with_param_asm;
8420007c:	57 27 f0 e1 
    Null = r0 - 2;
84200080:	cf 00 02 e4 	Null = r0 - 2;
    if NZ jump ret_BAD;
84200084:	11 00 10 dd 	if NE jump $M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_BAD;
    r1 = $_func_increase_one_with_param_asm;
84200088:	20 04 00 fd 	r1 = Null + 69216087;
8420008c:	57 27 30 01 
    call r1;
84200090:	0f 00 03 e0 	call r1;
    Null = r0 - 3;
84200094:	03 00 02 21 	Null = r0 - 3;
    if NZ jump ret_BAD;
84200098:	0c 00 10 dd 	if NE jump $M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_BAD;
    r1 = $_func_increase_one_with_param_c;
8420009c:	20 04 00 fd 	r1 = Null + 69210523;
842000a0:	9b 11 30 01 
    call r1;
842000a4:	0f 00 03 e0 	call r1;
    Null = r0 - 4;
842000a8:	df 00 02 e4 	Null = r0 - 4;
    if NZ jump ret_BAD;
842000ac:	07 00 10 dd 	if NE jump $M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_BAD;
    call $_func_increase_one_with_param_c;
842000b0:	20 04 00 fd 	call (m) $_func_increase_one_with_param_c;
842000b4:	9b 11 f0 e1 
    Null = r0 - 5;
842000b8:	05 00 02 21 	Null = r0 - 5;
    if NZ jump ret_BAD;
842000bc:	03 00 10 dd 	if NE jump $M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_BAD;

842000c0 <$M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_GOOD>:
    ret_GOOD:
        r0 = 0x600D;
842000c0:	0d 60 20 01 	r0 = Null + 24589;
        jump return;
842000c4:	02 00 f0 dd 	jump $M.download_self_test_call_from_maxim_to_minim_test_maxim.return;

842000c8 <$M.download_self_test_call_from_maxim_to_minim_test_maxim.ret_BAD>:
    ret_BAD:
        r0 = 0xBAD;
842000c8:	ad 0b 20 01 	r0 = Null + 2989;

842000cc <$M.download_self_test_call_from_maxim_to_minim_test_maxim.return>:
    return:
        pop rLink;
842000cc:	00 00 d4 f3 	pop rLink;
        rts;
842000d0:	0f 00 0d dc 	rts;

842000d4 <$_download_self_test_call_from_maxim_to_insert32_instr_test_maxim>:
.CODESEGMENT PM;
.DATASEGMENT DM;
.MAXIM;

$_download_self_test_call_from_maxim_to_insert32_instr_test_maxim:
    push rLink;
842000d4:	00 00 d0 f3 	push rLink;
    call $_func_insert32_instr_c;
842000d8:	20 04 00 fd 	call (m) $_func_insert32_instr_c;
842000dc:	fb 11 f0 e1 
    Null = r0 - 5;
842000e0:	05 00 02 21 	Null = r0 - 5;
    if NZ jump ret_BAD;
842000e4:	03 00 10 dd 	if NE jump $M.download_self_test_call_from_maxim_to_insert32_instr_test_maxim.ret_BAD;

842000e8 <$M.download_self_test_call_from_maxim_to_insert32_instr_test_maxim.ret_GOOD>:

    ret_GOOD:
        r0 = 0x600D;
842000e8:	0d 60 20 01 	r0 = Null + 24589;
        jump return;
842000ec:	02 00 f0 dd 	jump $M.download_self_test_call_from_maxim_to_insert32_instr_test_maxim.return;

842000f0 <$M.download_self_test_call_from_maxim_to_insert32_instr_test_maxim.ret_BAD>:
    ret_BAD:
        r0 = 0xBAD;
842000f0:	ad 0b 20 01 	r0 = Null + 2989;

842000f4 <$M.download_self_test_call_from_maxim_to_insert32_instr_test_maxim.return>:
    return:
        pop rLink;
842000f4:	00 00 d4 f3 	pop rLink;
        rts;
842000f8:	0f 00 0d dc 	rts;

842000fc <$_download_self_test_variable_size_vars_test_maxim_asm>:
    .VAR8 ByteArray[3] = 0x2E, 0x2F, 0x30;
    .VAR secondWord = 0x63;
    .VAR8 sixthByte = 0x31;
    .VAR secondHalf[3] = 0xBEEF,0xDEAD, 0xABCD;
    .VAR16 secondHalf1 = 0xBEEF;
    push rLink;
842000fc:	00 00 d0 f3 	push rLink;
    r0 = MBU[firstByte];
84200100:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.firstByte];
84200104:	24 23 20 f5 
    Null = r0 - 0xC;
84200108:	0c 00 02 21 	Null = r0 - 12;
    if NZ jump ret_BAD;
8420010c:	33 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = M[firstWord];
84200110:	70 00 00 fd 	r0 = Null + M[$M.download_self_test_variable_size_vars_test_maxim_asm.firstWord];
84200114:	28 03 20 09 
    Null = r0 - 0x87654321;
84200118:	65 87 00 fd 	Null = r0 - -2023406815;
8420011c:	21 43 02 21 
    if NZ jump ret_BAD;
84200120:	2e 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MHU[firstHalf];
84200124:	00 0e 00 fd 	r0 = MHU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.firstHalf];
84200128:	2c 63 20 f5 
    Null = r0 - 0xABCD;
8420012c:	00 00 00 fd 	Null = r0 - 43981;
84200130:	cd ab 02 21 
    if NZ jump ret_BAD;
84200134:	29 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[secondByte];
84200138:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.secondByte];
8420013c:	2e 23 20 f5 
    Null = r0 - 0x2A;
84200140:	2a 00 02 21 	Null = r0 - 42;
    if NZ jump ret_BAD;
84200144:	25 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[thirdByte];
84200148:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.thirdByte];
8420014c:	2f 23 20 f5 
    Null = r0 - 0x2B;
84200150:	2b 00 02 21 	Null = r0 - 43;
    if NZ jump ret_BAD;
84200154:	21 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[fourthByte];
84200158:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.fourthByte];
8420015c:	30 23 20 f5 
    Null = r0 - 0x2C;
84200160:	2c 00 02 21 	Null = r0 - 44;
    if NZ jump ret_BAD;
84200164:	1d 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[fifthByte];
84200168:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.fifthByte];
8420016c:	31 23 20 f5 
    Null = r0 - 0x2D;
84200170:	2d 00 02 21 	Null = r0 - 45;
    if NZ jump ret_BAD;
84200174:	19 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[ByteArray+1];
84200178:	00 0e 00 fd 	r0 = MBU[Null + 0x700333];
8420017c:	33 23 20 f5 
    Null = r0 - 0x2F;
84200180:	2f 00 02 21 	Null = r0 - 47;
    if NZ jump ret_BAD;
84200184:	15 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = M[secondWord];
84200188:	70 00 00 fd 	r0 = Null + M[$M.download_self_test_variable_size_vars_test_maxim_asm.secondWord];
8420018c:	38 03 20 09 
    Null = r0 - 0x63;
84200190:	63 00 02 21 	Null = r0 - 99;
    if NZ jump ret_BAD;
84200194:	11 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MBU[sixthByte];
84200198:	00 0e 00 fd 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.sixthByte];
8420019c:	3c 23 20 f5 
    Null = r0 - 0x31;
842001a0:	31 00 02 21 	Null = r0 - 49;
    if NZ jump ret_BAD;
842001a4:	0d 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = M[secondHalf + 2*ADDR_PER_WORD];
842001a8:	70 00 00 fd 	r0 = Null + M[0x700348];
842001ac:	48 03 20 09 
    Null = r0 - 0xABCD;
842001b0:	00 00 00 fd 	Null = r0 - 43981;
842001b4:	cd ab 02 21 
    if NZ jump ret_BAD;
842001b8:	08 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;
    r0 = MHU[secondHalf1];
842001bc:	00 0e 00 fd 	r0 = MHU[Null + $M.download_self_test_variable_size_vars_test_maxim_asm.secondHalf1];
842001c0:	4c 63 20 f5 
    Null = r0 - 0xBEEF;
842001c4:	00 00 00 fd 	Null = r0 - 48879;
842001c8:	ef be 02 21 
    if NZ jump ret_BAD;
842001cc:	03 00 10 dd 	if NE jump $M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD;

842001d0 <$M.download_self_test_variable_size_vars_test_maxim_asm.ret_GOOD>:
    ret_GOOD:
        r0 = 0x600D;
842001d0:	0d 60 20 01 	r0 = Null + 24589;
        jump return;
842001d4:	02 00 f0 dd 	jump $M.download_self_test_variable_size_vars_test_maxim_asm.return;

842001d8 <$M.download_self_test_variable_size_vars_test_maxim_asm.ret_BAD>:
    ret_BAD:
        r0 = 0xBAD;
842001d8:	ad 0b 20 01 	r0 = Null + 2989;

842001dc <$M.download_self_test_variable_size_vars_test_maxim_asm.return>:
    return:
        pop rLink;
842001dc:	00 00 d4 f3 	pop rLink;
        rts;
842001e0:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

842001e4 <$_basic_passthrough_create>:


/* ********************************** API functions ************************************* */

bool basic_passthrough_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842001e4:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
842001e6:	17 00       	r5 = r0 + Null;
842001e8:	28 09       	r6 = r3 + Null;
    BASIC_PASSTHROUGH_OP_DATA *opx_data;
    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
842001ea:	ef fd ff ff 	call (m) 0x8c;
842001ee:	23 e5 
842001f0:	10 04       	Null = r0 - Null;
842001f2:	03 62       	if NE jump (m) Lc_basic_passthrough_create_3;

842001f4 <Lc_basic_passthrough_create_2>:
    {
        return FALSE;
842001f4:	02 00       	r0 = Null + Null;
842001f6:	42 6e       	jump (m) Lc_basic_passthrough_create_10;

842001f8 <Lc_basic_passthrough_create_3>:
    }

    opx_data = (BASIC_PASSTHROUGH_OP_DATA *)op_data->extra_op_data;
842001f8:	3e 99       	r4 = M[r5 + 48];

    opx_data->latency_buffer_size = 0;
842001fa:	70 8f       	M[r4 + 20] = Null;

#ifdef INSTALL_TTP
    if (op_data->cap_data->id == TTP_PASS_CAP_ID)
842001fc:	79 89       	rMAC = M[r5 + 20];
842001fe:	09 e8       	rMAC = M[rMAC + Null];
84200200:	01 f0 10 f0 	Null = rMAC - 16487;
84200204:	67 24 
84200206:	17 62       	if NE jump (m) Lc_basic_passthrough_create_6;

84200208 <Lc_basic_passthrough_create_4>:
    {
        /* Allocate and initialise the TTP data */
        opx_data->time_to_play = ttp_init();
84200208:	ff fd b2 f0 	call (m) 0x16698;
8420020c:	31 e4 
8420020e:	32 8f       	M[r4 + 16] = r0;
        if (opx_data->time_to_play != NULL)
84200210:	31 89       	rMAC = M[r4 + 16];
84200212:	2e 60       	if EQ jump (m) Lc_basic_passthrough_create_9;

84200214 <Lc_basic_passthrough_create_5>:
        {
            ttp_params params;
            ttp_get_default_params(&params, TTP_TYPE_PCM);
84200214:	43 20       	r1 = Null + 1;
84200216:	42 11       	r0 = FP + 20;
84200218:	ff fd b2 f0 	call (m) 0x166de;
8420021c:	27 e6 
            ttp_configure_latency(opx_data->time_to_play, 5000);
8420021e:	03 f0 88 63 	r1 = Null + 5000;
84200222:	32 89       	r0 = M[r4 + 16];
84200224:	ff fd b2 f0 	call (m) 0x167da;
84200228:	37 ed 
            ttp_configure_params(opx_data->time_to_play, &params);
8420022a:	43 11       	r1 = FP + 20;
8420022c:	32 89       	r0 = M[r4 + 16];
8420022e:	ff fd b2 f0 	call (m) 0x16822;
84200232:	35 ef 

84200234 <Lc_basic_passthrough_create_6>:
            return TRUE;
        }
    }
#endif

    opx_data->ip_format = AUDIO_DATA_FORMAT_FIXP;
84200234:	41 20       	rMAC = Null + 1;
84200236:	71 8e       	M[r4 + 4] = rMAC;
    opx_data->op_format = AUDIO_DATA_FORMAT_FIXP;
84200238:	b1 8e       	M[r4 + 8] = rMAC;
    opx_data->num_active_chans = 0;
8420023a:	f0 8f       	M[r4 + 28] = Null;
    opx_data->active_chans = 0;
8420023c:	30 9e       	M[r4 + 32] = Null;
    /* Unless the host says otherwise assume incoming channels are not a stream */
    opx_data->simple_data_test_safe = FALSE;
8420023e:	f0 8e       	M[r4 + 12] = Null;
    switch (op_data->cap_data->id)
    {
        case BASIC_PASS_CAP_ID:
        case TTP_PASS_CAP_ID:
        default:
            opx_data->copy_function = (void *)(&mono_audio_loop);
84200240:	42 f0 11 f0 	rMAC = Null + 69215833;
84200244:	59 4a 
84200246:	31 ee       	M[r4 + Null] = rMAC;
            break;
    }

    if(!cpsInitParameters(&opx_data->parms_def,BASIC_PASSTHROUGH_GetDefaults(BASIC_PASS_CAP_ID),(unsigned*)(&opx_data->params),sizeof(BASIC_PASSTHROUGH_PARAMETERS)))
84200248:	22 f0 02 40 	r0 = Null + 16386;
8420024c:	05 f0 25 e5 	call (m) $_BASIC_PASSTHROUGH_GetDefaults;
84200250:	13 00       	r1 = r0 + Null;
84200252:	05 22       	r3 = Null + 8;
84200254:	64 f0 50 20 	r2 = r4 + 80;
84200258:	62 f0 90 20 	r0 = r4 + 144;
8420025c:	ff fd 00 f0 	call (m) 0x424;
84200260:	29 ee 
84200262:	10 04       	Null = r0 - Null;
84200264:	05 60       	if EQ jump (m) Lc_basic_passthrough_create_9;

84200266 <Lc_basic_passthrough_create_7>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    opx_data->ReInitFlag = 1;
84200266:	41 20       	rMAC = Null + 1;
84200268:	b1 af       	M[r4 + 88] = rMAC;

8420026a <Lc_basic_passthrough_create_8>:
        }
        else
        {
            /* TTP init failed, so fail the operator creation */
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
8420026a:	42 20       	r0 = Null + 1;
8420026c:	07 6e       	jump (m) Lc_basic_passthrough_create_10;

8420026e <Lc_basic_passthrough_create_9>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420026e:	01 f0 00 60 	rMAC = Null + 4096;
84200272:	82 f0 00 e8 	r0 = M[r6 + Null];
84200276:	51 8e       	M[r0 + 4] = rMAC;
84200278:	f9 6f       	jump (m) Lc_basic_passthrough_create_8;

8420027a <Lc_basic_passthrough_create_10>:
    }

    opx_data->ReInitFlag = 1;

    return TRUE;
}
8420027a:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420027c:	d8 4c       	rts;

8420027e <$_basic_passthrough_destroy>:


bool basic_passthrough_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420027e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200280:	16 00       	r4 = r0 + Null;
84200282:	1f 00       	r5 = r1 + Null;
84200284:	20 09       	r6 = r2 + Null;
84200286:	29 09       	r7 = r3 + Null;
#ifdef INSTALL_TTP
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)op_data->extra_op_data;
84200288:	31 99       	rMAC = M[r4 + 48];
    /* Time to play pointer will only be non-NULL if this is the TTP_PASS capability
     * It's safe to call ttp_free whether it's NULL or not.
     */
    ttp_free(opx_data->time_to_play);
8420028a:	0a 89       	r0 = M[rMAC + 16];
8420028c:	ff fd b4 f0 	call (m) 0x16af4;
84200290:	29 e3 
#endif
    /* call base_op destroy that creates and fills response message, too */
    return base_op_destroy(op_data, message_data, response_id, response_data);
84200292:	4d 08       	r3 = r7 + Null;
84200294:	44 08       	r2 = r6 + Null;
84200296:	3b 00       	r1 = r5 + Null;
84200298:	32 00       	r0 = r4 + Null;
8420029a:	ef fd ff ff 	call (m) 0xac;
8420029e:	33 e0 

842002a0 <Lc_basic_passthrough_destroy_2>:
}
842002a0:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842002a2:	d8 4c       	rts;

842002a4 <$_basic_passthrough_reset>:


bool basic_passthrough_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002a4:	c8 1c       	pushm <FP(=SP), rLink>;
    if (!base_op_reset(op_data, message_data, response_id, response_data))
842002a6:	ef fd fe ff 	call (m) 0x28;
842002aa:	23 ec 
    {
        return FALSE;
    }

    return TRUE;
842002ac:	11 00       	rMAC = r0 + Null;
842002ae:	02 00       	r0 = Null + Null;
842002b0:	08 04       	Null = rMAC - Null;
842002b2:	21 f0 42 ce 	if NE r0 = Null + 1;

842002b6 <Lc_basic_passthrough_reset_2>:
}
842002b6:	c8 48       	popm <FP, rLink>;
842002b8:	d8 4c       	rts;

842002ba <$_basic_passthrough_connect>:

bool basic_passthrough_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002ba:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842002bc:	19 09       	r7 = r1 + Null;
842002be:	2a 09       	r8 = r3 + Null;
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
842002c0:	16 99       	r4 = M[r0 + 48];
    unsigned terminal_id = ((unsigned*)message_data)[0];
842002c2:	9b f0 00 e8 	r9 = M[r7 + Null];
    unsigned i, channel;

    *response_id = OPCMD_CONNECT;
842002c6:	41 21       	rMAC = Null + 5;
842002c8:	21 ee       	M[r2 + Null] = rMAC;
    if (!base_op_build_std_response(STATUS_OK, op_data->id, response_data))
842002ca:	53 88       	r1 = M[r0 + 4];
842002cc:	02 00       	r0 = Null + Null;
842002ce:	54 08       	r2 = r8 + Null;
842002d0:	ef fd ff ff 	call (m) 0x204;
842002d4:	35 e9 
842002d6:	10 04       	Null = r0 - Null;
842002d8:	03 62       	if NE jump (m) Lc_basic_passthrough_connect_3;

842002da <Lc_basic_passthrough_connect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
842002da:	02 00       	r0 = Null + Null;
842002dc:	bf 6e       	jump (m) Lc_basic_passthrough_connect_51;

842002de <Lc_basic_passthrough_connect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
842002de:	bf ff b8 ff 	r6 = r9 AND 0xff7fffff;
842002e2:	ff 1f 
    if (channel >= MAX_CHANS)
842002e4:	80 f0 08 24 	Null = r6 - 8;
842002e8:	08 64       	if NC jump (m) Lc_basic_passthrough_connect_6;

842002ea <Lc_basic_passthrough_connect_4>:
842002ea:	01 f0 03 60 	rMAC = Null + 4099;
842002ee:	a2 f0 00 e8 	r0 = M[r8 + Null];
842002f2:	51 8e       	M[r0 + 4] = rMAC;

842002f4 <Lc_basic_passthrough_connect_5>:
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842002f4:	42 20       	r0 = Null + 1;
842002f6:	b2 6e       	jump (m) Lc_basic_passthrough_connect_51;

842002f8 <Lc_basic_passthrough_connect_6>:
    }

    /* A channel structure is needed for the buffer, find the existing channel
     * structure in the list otherwise create a new one.
     */
    for (i = 0; i < MAX_CHANS; i++)
842002f8:	07 00       	r5 = Null + Null;
842002fa:	31 31       	rMAC = r4 + 36;
842002fc:	06 6e       	jump (m) Lc_basic_passthrough_connect_8;

842002fe <Lc_basic_passthrough_connect_7>:
842002fe:	7f 20       	r5 = r5 + 1;
84200300:	09 21       	rMAC = rMAC + 4;
84200302:	38 26       	Null = r5 - 8;
84200304:	f2 ff f1 ef 	if C jump (m) Lc_basic_passthrough_connect_5;

84200308 <Lc_basic_passthrough_connect_8>:
    {
        if (opx_data->channel[i] != NULL )
84200308:	0a e8       	r0 = M[rMAC + Null];
8420030a:	5b 60       	if EQ jump (m) Lc_basic_passthrough_connect_30;

8420030c <Lc_basic_passthrough_connect_9>:
        {
            if (channel == opx_data->channel[i]->channel_num)
8420030c:	52 89       	r0 = M[r0 + 20];
8420030e:	2f f8 00 c2 	Null = r6 - r0;
84200312:	f6 63       	if NE jump (m) Lc_basic_passthrough_connect_7;

84200314 <Lc_basic_passthrough_connect_10>:
            {
                unsigned j;
                /* There is already a structure representing this channel so populate
                 * it with this connection. If it's already populated this is an error
                 */
                if (terminal_id & TERMINAL_SINK_MASK)
84200314:	40 f0 b1 f0 	rMAC = r9 AND 0x800000;
84200318:	00 00 
8420031a:	1c 60       	if EQ jump (m) Lc_basic_passthrough_connect_17;

8420031c <Lc_basic_passthrough_connect_11>:
                {
                    if (opx_data->channel[i]->ip_buffer == NULL)
8420031c:	7a 54       	r0 = r5 LSHIFT 2;
8420031e:	31 00       	rMAC = r4 + Null;
84200320:	51 00       	rMAC = r0 + rMAC;
84200322:	4a 98       	r0 = M[rMAC + 36];
84200324:	11 e8       	rMAC = M[r0 + Null];
84200326:	10 62       	if NE jump (m) Lc_basic_passthrough_connect_16;

84200328 <Lc_basic_passthrough_connect_12>:
                    {
                        opx_data->channel[i]->ip_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84200328:	91 f0 01 88 	rMAC = M[r7 + 4];
8420032c:	11 ee       	M[r0 + Null] = rMAC;
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_ip_buffer == NULL)
8420032e:	b2 a8       	r0 = M[r4 + 72];
84200330:	05 62       	if NE jump (m) Lc_basic_passthrough_connect_15;

84200332 <Lc_basic_passthrough_connect_13>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
84200332:	4a 89       	r0 = M[rMAC + 20];
84200334:	52 c6       	r0 = r0 AND 0x8000;
84200336:	02 60       	if EQ jump (m) Lc_basic_passthrough_connect_15;

84200338 <Lc_basic_passthrough_connect_14>:
                        {
                            if (buff_has_metadata(opx_data->channel[i]->ip_buffer))
                            {
                                opx_data->metadata_ip_buffer = opx_data->channel[i]->ip_buffer;
84200338:	b1 ae       	M[r4 + 72] = rMAC;

8420033a <Lc_basic_passthrough_connect_15>:
                 * are [ definition of active appears to be a single channel, which
                 * is banned, this could be confusing if add all IP then some OP, but
                 * probably OK - as for the SINK/SRC we first add a new channel and then
                 * the 2nd time around we come here, and have added the other ]
                 */
                for (j = i; j != 0; j --)
8420033a:	3a 00       	r0 = r5 + Null;
8420033c:	7b 54       	r1 = r5 LSHIFT 2;
8420033e:	31 00       	rMAC = r4 + Null;
84200340:	59 00       	rMAC = r1 + rMAC;
84200342:	09 30       	rMAC = rMAC + 32;
84200344:	1c 6e       	jump (m) Lc_basic_passthrough_connect_22;

84200346 <Lc_basic_passthrough_connect_16>:
84200346:	01 f0 00 60 	rMAC = Null + 4096;
8420034a:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420034e:	51 8e       	M[r0 + 4] = rMAC;
84200350:	d2 6f       	jump (m) Lc_basic_passthrough_connect_5;

84200352 <Lc_basic_passthrough_connect_17>:
                        return TRUE;
                    }
                }
                else
                {
                    if (opx_data->channel[i]->op_buffer == NULL)
84200352:	7a 54       	r0 = r5 LSHIFT 2;
84200354:	31 00       	rMAC = r4 + Null;
84200356:	51 00       	rMAC = r0 + rMAC;
84200358:	49 98       	rMAC = M[rMAC + 36];
8420035a:	09 21       	rMAC = rMAC + 4;
8420035c:	0a e8       	r0 = M[rMAC + Null];
8420035e:	f4 63       	if NE jump (m) Lc_basic_passthrough_connect_16;

84200360 <Lc_basic_passthrough_connect_18>:
                    {
                        opx_data->channel[i]->op_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84200360:	92 f0 01 88 	r0 = M[r7 + 4];
84200364:	0a ee       	M[rMAC + Null] = r0;
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_op_buffer == NULL)
84200366:	f1 a8       	rMAC = M[r4 + 76];
84200368:	e9 63       	if NE jump (m) Lc_basic_passthrough_connect_15;

8420036a <Lc_basic_passthrough_connect_19>:
8420036a:	51 89       	rMAC = M[r0 + 20];
8420036c:	49 c6       	rMAC = rMAC AND 0x8000;
8420036e:	e6 61       	if EQ jump (m) Lc_basic_passthrough_connect_15;

84200370 <Lc_basic_passthrough_connect_20>:
                        {
                            if (buff_has_metadata(opx_data->channel[i]->op_buffer))
                            {
                                opx_data->metadata_op_buffer = opx_data->channel[i]->op_buffer;
84200370:	f2 ae       	M[r4 + 76] = r0;
                                /* Set the usable octets for the metadata. */
                                buff_metadata_set_usable_octets(opx_data->metadata_op_buffer,
                                        get_octets_per_word(opx_data->op_format));
84200372:	b1 88       	rMAC = M[r4 + 8];
} AUDIO_DATA_FORMAT;

/* Returns the used octets in a word for a given format. */
static inline unsigned get_octets_per_word(AUDIO_DATA_FORMAT format)
{
    if (format == AUDIO_DATA_FORMAT_24_BIT)
84200374:	c8 26       	Null = rMAC - 11;
84200376:	52 62       	if NE jump (m) Lc_basic_passthrough_connect_39;

84200378 <Lc_basic_passthrough_connect_21>:
    {
        return 3;
84200378:	c3 20       	r1 = Null + 3;
8420037a:	5c 6e       	jump (m) Lc_basic_passthrough_connect_44;

8420037c <Lc_basic_passthrough_connect_22>:
                 * are [ definition of active appears to be a single channel, which
                 * is banned, this could be confusing if add all IP then some OP, but
                 * probably OK - as for the SINK/SRC we first add a new channel and then
                 * the 2nd time around we come here, and have added the other ]
                 */
                for (j = i; j != 0; j --)
8420037c:	10 04       	Null = r0 - Null;
8420037e:	0a 60       	if EQ jump (m) Lc_basic_passthrough_connect_27;

84200380 <Lc_basic_passthrough_connect_23>:
                {
                    if ((opx_data->channel[j-1] != NULL) &&
                        (opx_data->channel[j-1]->ip_buffer != NULL ||
                         opx_data->channel[j-1]->op_buffer != NULL ))
84200380:	0b e8       	r1 = M[rMAC + Null];
84200382:	05 60       	if EQ jump (m) Lc_basic_passthrough_connect_26;

84200384 <Lc_basic_passthrough_connect_24>:
84200384:	1c e8       	r2 = M[r1 + Null];
84200386:	06 62       	if NE jump (m) Lc_basic_passthrough_connect_27;

84200388 <Lc_basic_passthrough_connect_25>:
84200388:	5b 88       	r1 = M[r1 + 4];
8420038a:	04 62       	if NE jump (m) Lc_basic_passthrough_connect_27;

8420038c <Lc_basic_passthrough_connect_26>:
                 * are [ definition of active appears to be a single channel, which
                 * is banned, this could be confusing if add all IP then some OP, but
                 * probably OK - as for the SINK/SRC we first add a new channel and then
                 * the 2nd time around we come here, and have added the other ]
                 */
                for (j = i; j != 0; j --)
8420038c:	52 24       	r0 = r0 - 1;
8420038e:	09 25       	rMAC = rMAC - 4;
84200390:	f6 6f       	jump (m) Lc_basic_passthrough_connect_22;

84200392 <Lc_basic_passthrough_connect_27>:
                    {
                        /* Next channel up is an active channel */
                        break;
                    }
                }
                if (i != j)
84200392:	b8 04       	Null = r5 - r0;
84200394:	0d 60       	if EQ jump (m) Lc_basic_passthrough_connect_29;

84200396 <Lc_basic_passthrough_connect_28>:
                {
                    /* Swap the last inactive channel with the newly active channel.  */
                    PASSTHROUGH_CHANNEL *activate = opx_data->channel[i];
84200396:	7b 54       	r1 = r5 LSHIFT 2;
84200398:	31 00       	rMAC = r4 + Null;
8420039a:	59 00       	rMAC = r1 + rMAC;
8420039c:	0c 31       	r2 = rMAC + 36;
8420039e:	23 e8       	r1 = M[r2 + Null];
                    opx_data->channel[i] = opx_data->channel[j];
842003a0:	52 54       	r0 = r0 LSHIFT 2;
842003a2:	31 00       	rMAC = r4 + Null;
842003a4:	51 00       	rMAC = r0 + rMAC;
842003a6:	09 31       	rMAC = rMAC + 36;
842003a8:	0a e8       	r0 = M[rMAC + Null];
842003aa:	22 ee       	M[r2 + Null] = r0;
                    opx_data->channel[j] = activate;
842003ac:	0b ee       	M[rMAC + Null] = r1;

842003ae <Lc_basic_passthrough_connect_29>:
                }

                /* Mark that this channel is now active */
                opx_data->num_active_chans++;
842003ae:	f1 89       	rMAC = M[r4 + 28];
842003b0:	49 20       	rMAC = rMAC + 1;
842003b2:	f1 8f       	M[r4 + 28] = rMAC;
                opx_data->active_chans |= CHANNEL_MASK(channel);
842003b4:	00 f8 92 de 	r0 = 0x1 LSHIFT r6;
842003b8:	31 98       	rMAC = M[r4 + 32];
842003ba:	89 12       	rMAC = rMAC OR r0;
842003bc:	31 9e       	M[r4 + 32] = rMAC;

                break;
842003be:	9b 6f       	jump (m) Lc_basic_passthrough_connect_5;

842003c0 <Lc_basic_passthrough_connect_30>:
        else
        {
            /* There channel doesn't have a structure yet so create one and
             * populate it. It starts at the bottom of the list as its inactive
             * until both terminals are connected. */
            opx_data->channel[i] = xzpnew(PASSTHROUGH_CHANNEL);
842003c0:	c3 20       	r1 = Null + 3;
842003c2:	02 2a       	r0 = Null + 24;
842003c4:	ff fd 25 f0 	call (m) 0x4f2a;
842003c8:	27 eb 
842003ca:	7b 54       	r1 = r5 LSHIFT 2;
842003cc:	31 00       	rMAC = r4 + Null;
842003ce:	59 00       	rMAC = r1 + rMAC;
842003d0:	09 31       	rMAC = rMAC + 36;
            if (opx_data->channel[i] != NULL)
842003d2:	0a ee       	M[rMAC + Null] = r0;
842003d4:	b9 61       	if EQ jump (m) Lc_basic_passthrough_connect_16;

842003d6 <Lc_basic_passthrough_connect_31>:
            {
                opx_data->channel[i]->channel_num = channel;
842003d6:	28 f0 05 8e 	M[r0 + 20] = r6;
                opx_data->channel[i]->fadeout_parameters.fadeout_state = NOT_RUNNING_STATE;
842003da:	0a e8       	r0 = M[rMAC + Null];
842003dc:	10 9b       	MB[r0 + 12] = Null;
                if (terminal_id & TERMINAL_SINK_MASK)
842003de:	40 f0 b2 f0 	r0 = r9 AND 0x800000;
842003e2:	00 00 
842003e4:	0c 60       	if EQ jump (m) Lc_basic_passthrough_connect_35;

842003e6 <Lc_basic_passthrough_connect_32>:
                {
                    opx_data->channel[i]->ip_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
842003e6:	92 f0 01 88 	r0 = M[r7 + 4];
842003ea:	09 e8       	rMAC = M[rMAC + Null];
842003ec:	0a ee       	M[rMAC + Null] = r0;
#ifdef INSTALL_METADATA
                    if (opx_data->metadata_ip_buffer == NULL)
842003ee:	b1 a8       	rMAC = M[r4 + 72];
842003f0:	82 63       	if NE jump (m) Lc_basic_passthrough_connect_5;

842003f2 <Lc_basic_passthrough_connect_33>:
842003f2:	51 89       	rMAC = M[r0 + 20];
842003f4:	49 c6       	rMAC = rMAC AND 0x8000;
842003f6:	7f 61       	if EQ jump (m) Lc_basic_passthrough_connect_5;

842003f8 <Lc_basic_passthrough_connect_34>:
                    {
                        if (buff_has_metadata(opx_data->channel[i]->ip_buffer))
                        {
                            opx_data->metadata_ip_buffer = opx_data->channel[i]->ip_buffer;
842003f8:	b2 ae       	M[r4 + 72] = r0;
842003fa:	7d 6f       	jump (m) Lc_basic_passthrough_connect_5;

842003fc <Lc_basic_passthrough_connect_35>:
                    }
#endif /* INSTALL_METADATA */
                }
                else
                {
                    opx_data->channel[i]->op_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
842003fc:	92 f0 01 88 	r0 = M[r7 + 4];
84200400:	09 e8       	rMAC = M[rMAC + Null];
84200402:	4a 8e       	M[rMAC + 4] = r0;
#ifdef INSTALL_METADATA
                    if (opx_data->metadata_op_buffer == NULL)
84200404:	f1 a8       	rMAC = M[r4 + 76];
84200406:	77 63       	if NE jump (m) Lc_basic_passthrough_connect_5;

84200408 <Lc_basic_passthrough_connect_36>:
84200408:	51 89       	rMAC = M[r0 + 20];
8420040a:	49 c6       	rMAC = rMAC AND 0x8000;
8420040c:	74 61       	if EQ jump (m) Lc_basic_passthrough_connect_5;

8420040e <Lc_basic_passthrough_connect_37>:
                    {
                        if (buff_has_metadata(opx_data->channel[i]->op_buffer))
                        {
                            opx_data->metadata_op_buffer = opx_data->channel[i]->op_buffer;
8420040e:	f2 ae       	M[r4 + 76] = r0;
                            /* Set the usable octets for the metadata. */
                            buff_metadata_set_usable_octets(opx_data->metadata_op_buffer,
                                    get_octets_per_word(opx_data->op_format));
84200410:	b1 88       	rMAC = M[r4 + 8];
} AUDIO_DATA_FORMAT;

/* Returns the used octets in a word for a given format. */
static inline unsigned get_octets_per_word(AUDIO_DATA_FORMAT format)
{
    if (format == AUDIO_DATA_FORMAT_24_BIT)
84200412:	c8 26       	Null = rMAC - 11;
84200414:	13 62       	if NE jump (m) Lc_basic_passthrough_connect_45;

84200416 <Lc_basic_passthrough_connect_38>:
    {
        return 3;
84200416:	c3 20       	r1 = Null + 3;
84200418:	1d 6e       	jump (m) Lc_basic_passthrough_connect_50;

8420041a <Lc_basic_passthrough_connect_39>:
    }
    else if ((format == AUDIO_DATA_FORMAT_FIXP) ||
             (format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA) ||
             (format == SPDIF_INPUT_DATA_FORMAT) ||
             (format == USB_AUDIO_DATA_FORMAT))
8420041a:	48 24       	Null = rMAC - 1;
8420041c:	05 60       	if EQ jump (m) Lc_basic_passthrough_connect_42;

8420041e <Lc_basic_passthrough_connect_40>:
8420041e:	c8 24       	Null = rMAC - 3;
84200420:	03 60       	if EQ jump (m) Lc_basic_passthrough_connect_42;

84200422 <Lc_basic_passthrough_connect_41>:
84200422:	88 26       	Null = rMAC - 10;
84200424:	03 62       	if NE jump (m) Lc_basic_passthrough_connect_43;

84200426 <Lc_basic_passthrough_connect_42>:
    {
       return (DAWTH / 8);
84200426:	03 21       	r1 = Null + 4;
84200428:	05 6e       	jump (m) Lc_basic_passthrough_connect_44;

8420042a <Lc_basic_passthrough_connect_43>:
    else /* AUDIO_DATA_FORMAT_16_BIT, AUDIO_DATA_FORMAT_16_BIT_WITH_METADATA,
            AUDIO_DATA_FORMAT_16_BIT_BYTE_SWAP, AUDIO_DATA_FORMAT_16_BIT_BYTE_SWAP_WITH_METADATA,
            AUDIO_DATA_FORMAT_13_BIT, AUDIO_DATA_FORMAT_8_BIT, AUDIO_DATA_FORMAT_MU_LAW,
            AUDIO_DATA_FORMAT_A_LAW*/
    {
        return 2;
8420042a:	03 21       	r1 = Null + 4;
8420042c:	08 27       	Null = rMAC - 12;
8420042e:	a1 f0 43 ce 	if NE r1 = Null + 2;

84200432 <Lc_basic_passthrough_connect_44>:
                            if (buff_has_metadata(opx_data->channel[i]->op_buffer))
                            {
                                opx_data->metadata_op_buffer = opx_data->channel[i]->op_buffer;
                                /* Set the usable octets for the metadata. */
                                buff_metadata_set_usable_octets(opx_data->metadata_op_buffer,
                                        get_octets_per_word(opx_data->op_format));
84200432:	ff fd 8b f0 	call (m) 0x11c28;
84200436:	37 ef 
84200438:	81 6f       	jump (m) Lc_basic_passthrough_connect_15;

8420043a <Lc_basic_passthrough_connect_45>:
        return 3;
    }
    else if ((format == AUDIO_DATA_FORMAT_FIXP) ||
             (format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA) ||
             (format == SPDIF_INPUT_DATA_FORMAT) ||
             (format == USB_AUDIO_DATA_FORMAT))
8420043a:	48 24       	Null = rMAC - 1;
8420043c:	05 60       	if EQ jump (m) Lc_basic_passthrough_connect_48;

8420043e <Lc_basic_passthrough_connect_46>:
8420043e:	c8 24       	Null = rMAC - 3;
84200440:	03 60       	if EQ jump (m) Lc_basic_passthrough_connect_48;

84200442 <Lc_basic_passthrough_connect_47>:
84200442:	88 26       	Null = rMAC - 10;
84200444:	03 62       	if NE jump (m) Lc_basic_passthrough_connect_49;

84200446 <Lc_basic_passthrough_connect_48>:
    {
       return (DAWTH / 8);
84200446:	03 21       	r1 = Null + 4;
84200448:	05 6e       	jump (m) Lc_basic_passthrough_connect_50;

8420044a <Lc_basic_passthrough_connect_49>:
    else /* AUDIO_DATA_FORMAT_16_BIT, AUDIO_DATA_FORMAT_16_BIT_WITH_METADATA,
            AUDIO_DATA_FORMAT_16_BIT_BYTE_SWAP, AUDIO_DATA_FORMAT_16_BIT_BYTE_SWAP_WITH_METADATA,
            AUDIO_DATA_FORMAT_13_BIT, AUDIO_DATA_FORMAT_8_BIT, AUDIO_DATA_FORMAT_MU_LAW,
            AUDIO_DATA_FORMAT_A_LAW*/
    {
        return 2;
8420044a:	03 21       	r1 = Null + 4;
8420044c:	08 27       	Null = rMAC - 12;
8420044e:	a1 f0 43 ce 	if NE r1 = Null + 2;

84200452 <Lc_basic_passthrough_connect_50>:
                        if (buff_has_metadata(opx_data->channel[i]->op_buffer))
                        {
                            opx_data->metadata_op_buffer = opx_data->channel[i]->op_buffer;
                            /* Set the usable octets for the metadata. */
                            buff_metadata_set_usable_octets(opx_data->metadata_op_buffer,
                                    get_octets_per_word(opx_data->op_format));
84200452:	ff fd 8b f0 	call (m) 0x11c28;
84200456:	37 ee 
84200458:	4e 6f       	jump (m) Lc_basic_passthrough_connect_5;

8420045a <Lc_basic_passthrough_connect_51>:
            break;
        }
    }

    return TRUE;
}
8420045a:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420045c:	d8 4c       	rts;

8420045e <$_basic_passthrough_disconnect>:


bool basic_passthrough_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420045e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200460:	28 09       	r6 = r3 + Null;
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
84200462:	16 99       	r4 = M[r0 + 48];
    unsigned terminal_id = ((unsigned*)message_data)[0];
84200464:	1f e8       	r5 = M[r1 + Null];
    unsigned i, channel;

    *response_id = OPCMD_DISCONNECT;
84200466:	81 21       	rMAC = Null + 6;
84200468:	21 ee       	M[r2 + Null] = rMAC;
    if (!base_op_build_std_response(STATUS_OK, op_data->id, response_data))
8420046a:	53 88       	r1 = M[r0 + 4];
8420046c:	02 00       	r0 = Null + Null;
8420046e:	44 08       	r2 = r6 + Null;
84200470:	ef fd fe ff 	call (m) 0x204;
84200474:	35 ec 
84200476:	10 04       	Null = r0 - Null;
84200478:	03 62       	if NE jump (m) Lc_basic_passthrough_disconnect_3;

8420047a <Lc_basic_passthrough_disconnect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
8420047a:	02 00       	r0 = Null + Null;
8420047c:	dc 6e       	jump (m) Lc_basic_passthrough_disconnect_51;

8420047e <Lc_basic_passthrough_disconnect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
8420047e:	bf ff 79 ff 	r7 = r5 AND 0xff7fffff;
84200482:	ff 1f 
    if (channel >= MAX_CHANS)
84200484:	90 f0 08 24 	Null = r7 - 8;
84200488:	07 64       	if NC jump (m) Lc_basic_passthrough_disconnect_5;

8420048a <Lc_basic_passthrough_disconnect_4>:
8420048a:	01 f0 03 60 	rMAC = Null + 4099;
8420048e:	82 f0 00 e8 	r0 = M[r6 + Null];
84200492:	51 8e       	M[r0 + 4] = rMAC;
84200494:	c0 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

84200496 <Lc_basic_passthrough_disconnect_5>:
84200496:	03 f0 00 60 	r1 = Null + 4096;
    /* To perform a disconnect find the appropriate channel from the list. Make
     * sure that channel is in the inactive part of the list, and then mark the
     * terminal's buffer as NULL. If that makes the channel empty then free
     * the memory for that channel.
     */
    for (i = 0; i < MAX_CHANS; i++)
8420049a:	02 00       	r0 = Null + Null;
8420049c:	31 31       	rMAC = r4 + 36;

8420049e <Lc_basic_passthrough_disconnect_6>:
    {
        if (opx_data->channel[i] != NULL)
8420049e:	0c e8       	r2 = M[rMAC + Null];
842004a0:	b3 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_46;

842004a2 <Lc_basic_passthrough_disconnect_7>:
        {
            if (channel == opx_data->channel[i]->channel_num)
842004a2:	64 89       	r2 = M[r2 + 20];
842004a4:	4f f9 00 c2 	Null = r7 - r2;
842004a8:	b2 62       	if NE jump (m) Lc_basic_passthrough_disconnect_47;

842004aa <Lc_basic_passthrough_disconnect_8>:
            {
                /* Channel structure found */
                if (terminal_id & TERMINAL_SINK_MASK)
842004aa:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842004ae:	00 00 
842004b0:	59 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_28;

842004b2 <Lc_basic_passthrough_disconnect_9>:
                {
                    if (opx_data->channel[i]->ip_buffer != NULL)
842004b2:	53 54       	r1 = r0 LSHIFT 2;
842004b4:	31 00       	rMAC = r4 + Null;
842004b6:	59 00       	rMAC = r1 + rMAC;
842004b8:	1a f0 24 20 	r8 = rMAC + 36;
842004bc:	a1 f0 00 e8 	rMAC = M[r8 + Null];
842004c0:	09 e8       	rMAC = M[rMAC + Null];
842004c2:	4a 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_27;

842004c4 <Lc_basic_passthrough_disconnect_10>:
                    {
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_ip_buffer == opx_data->channel[i]->ip_buffer)
842004c4:	b3 a8       	r1 = M[r4 + 72];
842004c6:	58 04       	Null = r1 - rMAC;
842004c8:	11 62       	if NE jump (m) Lc_basic_passthrough_disconnect_18;

842004ca <Lc_basic_passthrough_disconnect_11>:
                        {
                            unsigned j;
                            bool found_alternative = FALSE;
                            for (j = 0; j < MAX_CHANS; j++)
842004ca:	03 00       	r1 = Null + Null;
842004cc:	31 31       	rMAC = r4 + 36;

842004ce <Lc_basic_passthrough_disconnect_12>:
                            {
                                if (j == i)
842004ce:	98 04       	Null = r1 - r0;
842004d0:	08 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_16;

842004d2 <Lc_basic_passthrough_disconnect_13>:
                                {
                                    continue;
                                }
                                if (opx_data->channel[j] != NULL &&
                                   (opx_data->channel[j]->ip_buffer != NULL &&
                                    buff_has_metadata(opx_data->channel[j]->ip_buffer)))
842004d2:	0c e8       	r2 = M[rMAC + Null];
842004d4:	06 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_16;

842004d6 <Lc_basic_passthrough_disconnect_14>:
842004d6:	24 e8       	r2 = M[r2 + Null];
842004d8:	04 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_16;

842004da <Lc_basic_passthrough_disconnect_15>:
842004da:	64 89       	r2 = M[r2 + 20];
842004dc:	64 c6       	r2 = r2 AND 0x8000;
842004de:	9d 62       	if NE jump (m) Lc_basic_passthrough_disconnect_49;

842004e0 <Lc_basic_passthrough_disconnect_16>:
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_ip_buffer == opx_data->channel[i]->ip_buffer)
                        {
                            unsigned j;
                            bool found_alternative = FALSE;
                            for (j = 0; j < MAX_CHANS; j++)
842004e0:	5b 20       	r1 = r1 + 1;
842004e2:	09 21       	rMAC = rMAC + 4;
842004e4:	18 26       	Null = r1 - 8;
842004e6:	f4 65       	if NC jump (m) Lc_basic_passthrough_disconnect_12;

842004e8 <Lc_basic_passthrough_disconnect_17>:
                                    break;
                                }
                            }
                            if (!found_alternative)
                            {
                                opx_data->metadata_ip_buffer = NULL;
842004e8:	b0 ae       	M[r4 + 72] = Null;

842004ea <Lc_basic_passthrough_disconnect_18>:
                            }
                        }
#endif /* INSTALL_METADATA */

                        if (opx_data->channel[i]->op_buffer != NULL )
842004ea:	a7 f0 00 e8 	r5 = M[r8 + Null];
842004ee:	79 88       	rMAC = M[r5 + 4];
842004f0:	22 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_22;

842004f2 <Lc_basic_passthrough_disconnect_19>:
                        {
                            unsigned last_active_chan = opx_data->num_active_chans - 1;
842004f2:	f1 89       	rMAC = M[r4 + 28];
842004f4:	18 f0 01 24 	r6 = rMAC - 1;
                            /* It's possible this was the last active entry in
                             * the list anyway in which case we don't need to do
                             * an expensive swap with interrupts blocked to stop
                             * a channel being executed twice.
                             */
                            if (i == last_active_chan)
842004f8:	8f f2 00 c2 	Null = r0 - r6;
842004fc:	10 62       	if NE jump (m) Lc_basic_passthrough_disconnect_21;

842004fe <Lc_basic_passthrough_disconnect_20>:
                            {
                                LOCK_INTERRUPTS;
842004fe:	ff fd 63 f1 	call (m) 0x2cc9c;
84200502:	3f ec 
                                opx_data->channel[i] = opx_data->channel[last_active_chan];
84200504:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84200508:	31 00       	rMAC = r4 + Null;
8420050a:	51 00       	rMAC = r0 + rMAC;
8420050c:	09 31       	rMAC = rMAC + 36;
8420050e:	0a e8       	r0 = M[rMAC + Null];
84200510:	a2 f0 00 ee 	M[r8 + Null] = r0;
                                opx_data->channel[last_active_chan] = deactivate;
84200514:	0f ee       	M[rMAC + Null] = r5;
                                UNLOCK_INTERRUPTS;
84200516:	ff fd 63 f1 	call (m) 0x2ccb8;
8420051a:	23 ed 

8420051c <Lc_basic_passthrough_disconnect_21>:
                            }
                            /* Deactivate the channel from being processed before
                             * nulling the buffer pointer. */
                            opx_data->num_active_chans--;
8420051c:	f1 89       	rMAC = M[r4 + 28];
8420051e:	49 24       	rMAC = rMAC - 1;
84200520:	f1 8f       	M[r4 + 28] = rMAC;
                            opx_data->active_chans &= ~CHANNEL_MASK(channel);
84200522:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
84200526:	ff f2 51 d6 	rMAC = -1 - r0;
8420052a:	32 98       	r0 = M[r4 + 32];
8420052c:	89 10       	rMAC = rMAC AND r0;
8420052e:	31 9e       	M[r4 + 32] = rMAC;
                            deactivate->ip_buffer = NULL;
84200530:	38 ee       	M[r5 + Null] = Null;
84200532:	71 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

84200534 <Lc_basic_passthrough_disconnect_22>:
84200534:	d0 25       	Null = r0 - 7;
84200536:	02 f0 95 e0 	if C jump (m) Lc__loop0;

8420053a <Lc_basic_passthrough_disconnect_23>:
8420053a:	03 f2 5c d6 	r10 = 7 - r0;
8420053e:	06 4c       	do (m) Lc__loop0;

84200540 <Lc_basic_passthrough_disconnect_24>:
                             */
                            PASSTHROUGH_CHANNEL *old_channel = opx_data->channel[i];

                            for (; i < MAX_CHANS - 1; i++)
                            {
                                opx_data->channel[i] = opx_data->channel[i + 1];
84200540:	a1 f0 01 88 	rMAC = M[r8 + 4];
84200544:	a1 f0 00 ee 	M[r8 + Null] = rMAC;
84200548:	22 75       	r8 = r8 + 4;

8420054a <Lc__loop0>:
                             * condition if the operator is running so interrupts don't need
                             * to be blocked here.
                             */
                            PASSTHROUGH_CHANNEL *old_channel = opx_data->channel[i];

                            for (; i < MAX_CHANS - 1; i++)
8420054a:	30 ae       	M[r4 + 64] = Null;
                            {
                                opx_data->channel[i] = opx_data->channel[i + 1];
                            }
                            /* The last entry has to be NULL as we've removed an element */
                            opx_data->channel[MAX_CHANS - 1] = NULL;
                            pdelete(old_channel);
8420054c:	3a 00       	r0 = r5 + Null;
8420054e:	ff fd 25 f0 	call (m) 0x4f62;
84200552:	35 e0 
84200554:	60 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

84200556 <Lc_basic_passthrough_disconnect_27>:
84200556:	01 f0 00 60 	rMAC = Null + 4096;
8420055a:	82 f0 00 e8 	r0 = M[r6 + Null];
8420055e:	51 8e       	M[r0 + 4] = rMAC;
84200560:	5a 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

84200562 <Lc_basic_passthrough_disconnect_28>:
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                    }
                }
                else
                {
                    if (opx_data->channel[i]->op_buffer != NULL)
84200562:	53 54       	r1 = r0 LSHIFT 2;
84200564:	31 00       	rMAC = r4 + Null;
84200566:	59 00       	rMAC = r1 + rMAC;
84200568:	1a f0 24 20 	r8 = rMAC + 36;
8420056c:	a1 f0 00 e8 	rMAC = M[r8 + Null];
84200570:	49 88       	rMAC = M[rMAC + 4];
84200572:	f2 61       	if EQ jump (m) Lc_basic_passthrough_disconnect_27;

84200574 <Lc_basic_passthrough_disconnect_29>:
                    {
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_op_buffer == opx_data->channel[i]->op_buffer)
84200574:	f3 a8       	r1 = M[r4 + 76];
84200576:	58 04       	Null = r1 - rMAC;
84200578:	11 62       	if NE jump (m) Lc_basic_passthrough_disconnect_37;

8420057a <Lc_basic_passthrough_disconnect_30>:
                        {
                            unsigned j;
                            bool found_alternative = FALSE;
                            for (j = 0; j < MAX_CHANS; j++)
8420057a:	03 00       	r1 = Null + Null;
8420057c:	31 31       	rMAC = r4 + 36;

8420057e <Lc_basic_passthrough_disconnect_31>:
                            {
                                if (j == i)
8420057e:	98 04       	Null = r1 - r0;
84200580:	08 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_35;

84200582 <Lc_basic_passthrough_disconnect_32>:
                                {
                                    continue;
                                }
                                if (opx_data->channel[j] != NULL &&
                                   (opx_data->channel[j]->op_buffer != NULL &&
                                    buff_has_metadata(opx_data->channel[j]->op_buffer)))
84200582:	0c e8       	r2 = M[rMAC + Null];
84200584:	06 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_35;

84200586 <Lc_basic_passthrough_disconnect_33>:
84200586:	64 88       	r2 = M[r2 + 4];
84200588:	04 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_35;

8420058a <Lc_basic_passthrough_disconnect_34>:
8420058a:	64 89       	r2 = M[r2 + 20];
8420058c:	64 c6       	r2 = r2 AND 0x8000;
8420058e:	4c 62       	if NE jump (m) Lc_basic_passthrough_disconnect_50;

84200590 <Lc_basic_passthrough_disconnect_35>:
#ifdef INSTALL_METADATA
                        if (opx_data->metadata_op_buffer == opx_data->channel[i]->op_buffer)
                        {
                            unsigned j;
                            bool found_alternative = FALSE;
                            for (j = 0; j < MAX_CHANS; j++)
84200590:	5b 20       	r1 = r1 + 1;
84200592:	09 21       	rMAC = rMAC + 4;
84200594:	18 26       	Null = r1 - 8;
84200596:	f4 65       	if NC jump (m) Lc_basic_passthrough_disconnect_31;

84200598 <Lc_basic_passthrough_disconnect_36>:
                                    break;
                                }
                            }
                            if (!found_alternative)
                            {
                                opx_data->metadata_op_buffer = NULL;
84200598:	f0 ae       	M[r4 + 76] = Null;

8420059a <Lc_basic_passthrough_disconnect_37>:

                        /* If the input buffer is still connected put this channel
                         * in the deactivated part of the channel list. If it
                         * isn't then remove the structure entirely.
                         */
                        if (opx_data->channel[i]->ip_buffer)
8420059a:	a7 f0 00 e8 	r5 = M[r8 + Null];
8420059e:	39 e8       	rMAC = M[r5 + Null];
842005a0:	22 60       	if EQ jump (m) Lc_basic_passthrough_disconnect_41;

842005a2 <Lc_basic_passthrough_disconnect_38>:
                        {
                            unsigned last_active_chan = opx_data->num_active_chans - 1;
842005a2:	f1 89       	rMAC = M[r4 + 28];
842005a4:	18 f0 01 24 	r6 = rMAC - 1;
                            /* It's possible this was the last active entry in
                             * the list anyway in which case we don't need to do
                             * an expensive swap with interrupts blocked to stop
                             * a channel being executed twice.
                             */
                            if (i == last_active_chan)
842005a8:	8f f2 00 c2 	Null = r0 - r6;
842005ac:	10 62       	if NE jump (m) Lc_basic_passthrough_disconnect_40;

842005ae <Lc_basic_passthrough_disconnect_39>:
                            {
                                LOCK_INTERRUPTS;
842005ae:	ff fd 63 f1 	call (m) 0x2cc9c;
842005b2:	2f e7 
                                opx_data->channel[i] = opx_data->channel[last_active_chan];
842005b4:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
842005b8:	31 00       	rMAC = r4 + Null;
842005ba:	51 00       	rMAC = r0 + rMAC;
842005bc:	09 31       	rMAC = rMAC + 36;
842005be:	0a e8       	r0 = M[rMAC + Null];
842005c0:	a2 f0 00 ee 	M[r8 + Null] = r0;
                                opx_data->channel[last_active_chan] = deactivate;
842005c4:	0f ee       	M[rMAC + Null] = r5;
                                UNLOCK_INTERRUPTS;
842005c6:	ff fd 63 f1 	call (m) 0x2ccb8;
842005ca:	33 e7 

842005cc <Lc_basic_passthrough_disconnect_40>:
                            }
                            /* Deactivate the channel from being processed before
                             * nulling the buffer pointer. */
                            opx_data->num_active_chans--;
842005cc:	f1 89       	rMAC = M[r4 + 28];
842005ce:	49 24       	rMAC = rMAC - 1;
842005d0:	f1 8f       	M[r4 + 28] = rMAC;
                            opx_data->active_chans &= ~CHANNEL_MASK(channel);
842005d2:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
842005d6:	ff f2 51 d6 	rMAC = -1 - r0;
842005da:	32 98       	r0 = M[r4 + 32];
842005dc:	89 10       	rMAC = rMAC AND r0;
842005de:	31 9e       	M[r4 + 32] = rMAC;
                            deactivate->op_buffer = NULL;
842005e0:	78 8e       	M[r5 + 4] = Null;
842005e2:	19 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

842005e4 <Lc_basic_passthrough_disconnect_41>:
842005e4:	d0 25       	Null = r0 - 7;
842005e6:	02 f0 95 e0 	if C jump (m) Lc__loop1;

842005ea <Lc_basic_passthrough_disconnect_42>:
842005ea:	03 f2 5c d6 	r10 = 7 - r0;
842005ee:	06 4c       	do (m) Lc__loop1;

842005f0 <Lc_basic_passthrough_disconnect_43>:
                             */
                            PASSTHROUGH_CHANNEL *old_channel = opx_data->channel[i];

                            for (; i < MAX_CHANS - 1; i++)
                            {
                                opx_data->channel[i] = opx_data->channel[i + 1];
842005f0:	a1 f0 01 88 	rMAC = M[r8 + 4];
842005f4:	a1 f0 00 ee 	M[r8 + Null] = rMAC;
842005f8:	22 75       	r8 = r8 + 4;

842005fa <Lc__loop1>:
                             * condition if the operator is running so interrupts don't need
                             * to be blocked here.
                             */
                            PASSTHROUGH_CHANNEL *old_channel = opx_data->channel[i];

                            for (; i < MAX_CHANS - 1; i++)
842005fa:	30 ae       	M[r4 + 64] = Null;
                            {
                                opx_data->channel[i] = opx_data->channel[i + 1];
                            }
                            /* The last entry has to be NULL as we've removed an element */
                            opx_data->channel[MAX_CHANS - 1] = NULL;
                            pdelete(old_channel);
842005fc:	3a 00       	r0 = r5 + Null;
842005fe:	ff fd 24 f0 	call (m) 0x4f62;
84200602:	25 eb 
84200604:	08 6e       	jump (m) Lc_basic_passthrough_disconnect_48;

84200606 <Lc_basic_passthrough_disconnect_46>:
84200606:	84 f0 00 e8 	r2 = M[r6 + Null];
8420060a:	63 8e       	M[r2 + 4] = r1;

8420060c <Lc_basic_passthrough_disconnect_47>:
    /* To perform a disconnect find the appropriate channel from the list. Make
     * sure that channel is in the inactive part of the list, and then mark the
     * terminal's buffer as NULL. If that makes the channel empty then free
     * the memory for that channel.
     */
    for (i = 0; i < MAX_CHANS; i++)
8420060c:	52 20       	r0 = r0 + 1;
8420060e:	09 21       	rMAC = rMAC + 4;
84200610:	10 26       	Null = r0 - 8;
84200612:	46 65       	if NC jump (m) Lc_basic_passthrough_disconnect_6;

84200614 <Lc_basic_passthrough_disconnect_48>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel >= MAX_CHANS)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200614:	42 20       	r0 = Null + 1;
84200616:	0f 6e       	jump (m) Lc_basic_passthrough_disconnect_51;

84200618 <Lc_basic_passthrough_disconnect_49>:
                                }
                                if (opx_data->channel[j] != NULL &&
                                   (opx_data->channel[j]->ip_buffer != NULL &&
                                    buff_has_metadata(opx_data->channel[j]->ip_buffer)))
                                {
                                    opx_data->metadata_ip_buffer = opx_data->channel[j]->ip_buffer;
84200618:	5b 54       	r1 = r1 LSHIFT 2;
8420061a:	31 00       	rMAC = r4 + Null;
8420061c:	59 00       	rMAC = r1 + rMAC;
8420061e:	49 98       	rMAC = M[rMAC + 36];
84200620:	09 e8       	rMAC = M[rMAC + Null];
84200622:	b1 ae       	M[r4 + 72] = rMAC;
                                    found_alternative = TRUE;
                                    break;
84200624:	63 6f       	jump (m) Lc_basic_passthrough_disconnect_18;

84200626 <Lc_basic_passthrough_disconnect_50>:
                                }
                                if (opx_data->channel[j] != NULL &&
                                   (opx_data->channel[j]->op_buffer != NULL &&
                                    buff_has_metadata(opx_data->channel[j]->op_buffer)))
                                {
                                    opx_data->metadata_op_buffer = opx_data->channel[j]->op_buffer;
84200626:	5b 54       	r1 = r1 LSHIFT 2;
84200628:	31 00       	rMAC = r4 + Null;
8420062a:	59 00       	rMAC = r1 + rMAC;
8420062c:	49 98       	rMAC = M[rMAC + 36];
8420062e:	49 88       	rMAC = M[rMAC + 4];
84200630:	f1 ae       	M[r4 + 76] = rMAC;
                                    found_alternative = TRUE;
                                    break;
84200632:	b4 6f       	jump (m) Lc_basic_passthrough_disconnect_37;

84200634 <Lc_basic_passthrough_disconnect_51>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        }
    }

    return TRUE;
}
84200634:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200636:	d8 4c       	rts;

84200638 <$_basic_passthrough_buffer_details>:


bool basic_passthrough_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200638:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420063a:	19 09       	r7 = r1 + Null;
8420063c:	2e 00       	r4 = r3 + Null;
#if !defined(DISABLE_IN_PLACE) || defined(INSTALL_METADATA)
    unsigned terminal_id = ((unsigned *)message_data)[0];
8420063e:	97 f0 00 e8 	r5 = M[r7 + Null];
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
84200642:	28 f0 0c 88 	r6 = M[r0 + 48];
    unsigned buffer_size;

#endif /* DISABLE_IN_PLACE */
#endif /* !defined(DISABLE_IN_PLACE) || defined(INSTALL_METADATA) */

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200646:	ef fd fd ff 	call (m) 0xbe;
8420064a:	39 e3 
8420064c:	10 04       	Null = r0 - Null;
8420064e:	03 62       	if NE jump (m) Lc_basic_passthrough_buffer_details_3;

84200650 <Lc_basic_passthrough_buffer_details_2>:
    {
        return FALSE;
84200650:	02 00       	r0 = Null + Null;
84200652:	5a 6e       	jump (m) Lc_basic_passthrough_buffer_details_21;

84200654 <Lc_basic_passthrough_buffer_details_3>:
    }

    buffer_size = ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size;
84200654:	33 e8       	r1 = M[r4 + Null];
84200656:	1a 89       	r0 = M[r1 + 16];
    {
        /* If an input/output connection is already present and has metadata then
         * we are obliged to return that buffer so that metadata can be shared
         * between channels. */
        tCbuffer *meta_buff;
        if ((terminal_id & TERMINAL_SINK_MASK) == TERMINAL_SINK_MASK)
84200658:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420065c:	00 00 
8420065e:	04 60       	if EQ jump (m) Lc_basic_passthrough_buffer_details_5;

84200660 <Lc_basic_passthrough_buffer_details_4>:
        {
            meta_buff = opx_data->metadata_ip_buffer;
84200660:	81 f0 12 88 	rMAC = M[r6 + 72];
84200664:	03 6e       	jump (m) Lc_basic_passthrough_buffer_details_6;

84200666 <Lc_basic_passthrough_buffer_details_5>:
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
84200666:	81 f0 13 88 	rMAC = M[r6 + 76];

8420066a <Lc_basic_passthrough_buffer_details_6>:
        }

        ((OP_BUF_DETAILS_RSP*)*response_data)->metadata_buffer = meta_buff;
8420066a:	d9 8e       	M[r1 + 12] = rMAC;
        ((OP_BUF_DETAILS_RSP*)*response_data)->supports_metadata = TRUE;
8420066c:	31 e8       	rMAC = M[r4 + Null];
8420066e:	09 22       	rMAC = rMAC + 8;
84200670:	0b e2       	r1 = MBU[rMAC + Null];
84200672:	33 ff ef 1f 	r1 = r1 AND 0xffffffef;
84200676:	db c9       	r1 = r1 OR 0x10;
84200678:	0b ea       	MB[rMAC + Null] = r1;
    }
#endif /* INSTALL_METADATA */

#ifndef DISABLE_IN_PLACE
    channel = terminal_id & (~TERMINAL_SINK_MASK);
8420067a:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
8420067e:	ff 1f 
    if (channel >= MAX_CHANS)
84200680:	08 26       	Null = rMAC - 8;
84200682:	06 64       	if NC jump (m) Lc_basic_passthrough_buffer_details_8;

84200684 <Lc_basic_passthrough_buffer_details_7>:
84200684:	01 f0 03 60 	rMAC = Null + 4099;
84200688:	32 e8       	r0 = M[r4 + Null];
8420068a:	51 8e       	M[r0 + 4] = rMAC;
8420068c:	3c 6e       	jump (m) Lc_basic_passthrough_buffer_details_20;

8420068e <Lc_basic_passthrough_buffer_details_8>:
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    ((OP_BUF_DETAILS_RSP*)*response_data)->runs_in_place = TRUE;
8420068e:	33 ff f7 1f 	r1 = r1 AND 0xfffffff7;
84200692:	34 e8       	r2 = M[r4 + Null];
84200694:	5b c9       	r1 = r1 OR 0x8;
84200696:	23 9a       	MB[r2 + 8] = r1;
    if (opx_data->latency_buffer_size != 0)
84200698:	83 f0 05 88 	r1 = M[r6 + 20];
8420069c:	07 60       	if EQ jump (m) Lc_basic_passthrough_buffer_details_10;

8420069e <Lc_basic_passthrough_buffer_details_9>:
    {
        /* Use the requested latency buffer size */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.size = opx_data->latency_buffer_size;
8420069e:	32 e8       	r0 = M[r4 + Null];
842006a0:	53 8f       	M[r0 + 20] = r1;
        opx_data->kick_on_full_output = TRUE;
842006a2:	42 20       	r0 = Null + 1;
842006a4:	82 f0 11 8e 	M[r6 + 68] = r0;
842006a8:	03 6e       	jump (m) Lc_basic_passthrough_buffer_details_11;

842006aa <Lc_basic_passthrough_buffer_details_10>:
    }
    else
    {
        /* return the calculated size from base_op_buffer_details */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.size = buffer_size;
842006aa:	33 e8       	r1 = M[r4 + Null];
842006ac:	5a 8f       	M[r1 + 20] = r0;

842006ae <Lc_basic_passthrough_buffer_details_11>:
    }
    ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.buffer = NULL;
842006ae:	32 e8       	r0 = M[r4 + Null];
842006b0:	90 8f       	M[r0 + 24] = Null;
842006b2:	82 f0 24 20 	r0 = r6 + 36;

    /* search for the channel. */
    for (i = 0; i < MAX_CHANS; i++)
842006b6:	44 71       	r10 = Null + 8;
842006b8:	12 4c       	do (m) Lc__loop2;

842006ba <Lc_basic_passthrough_buffer_details_12>:
    {
        if (opx_data->channel[i])
842006ba:	13 e8       	r1 = M[r0 + Null];
842006bc:	0f 60       	if EQ jump (m) Lc_basic_passthrough_buffer_details_17;

842006be <Lc_basic_passthrough_buffer_details_13>:
        {
            if (channel == opx_data->channel[i]->channel_num)
842006be:	5c 89       	r2 = M[r1 + 20];
842006c0:	08 05       	Null = rMAC - r2;
842006c2:	0c 62       	if NE jump (m) Lc_basic_passthrough_buffer_details_17;

842006c4 <Lc_basic_passthrough_buffer_details_14>:
            {

                if (terminal_id & TERMINAL_SINK_MASK)
842006c4:	40 f0 74 f0 	r2 = r5 AND 0x800000;
842006c8:	00 00 
842006ca:	05 60       	if EQ jump (m) Lc_basic_passthrough_buffer_details_16;

842006cc <Lc_basic_passthrough_buffer_details_15>:
                {

                    /*input terminal. give the output buffer for the channel */
                    ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.buffer =
                            opx_data->channel[i]->op_buffer;
842006cc:	5b 88       	r1 = M[r1 + 4];
842006ce:	34 e8       	r2 = M[r4 + Null];
842006d0:	a3 8f       	M[r2 + 24] = r1;
842006d2:	04 6e       	jump (m) Lc_basic_passthrough_buffer_details_17;

842006d4 <Lc_basic_passthrough_buffer_details_16>:
                }
                else
                {
                    /*output terminal. give the input buffer for the channel */
                    ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.buffer =
                            opx_data->channel[i]->ip_buffer;
842006d4:	1b e8       	r1 = M[r1 + Null];
842006d6:	34 e8       	r2 = M[r4 + Null];
842006d8:	a3 8f       	M[r2 + 24] = r1;

842006da <Lc_basic_passthrough_buffer_details_17>:
842006da:	12 21       	r0 = r0 + 4;

842006dc <Lc__loop2>:
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.size = buffer_size;
    }
    ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.buffer = NULL;

    /* search for the channel. */
    for (i = 0; i < MAX_CHANS; i++)
842006dc:	91 f0 00 e8 	rMAC = M[r7 + Null];
842006e0:	32 e8       	r0 = M[r4 + Null];
842006e2:	08 f0 00 f0 	rMAC = rMAC XOR 0x800000;
842006e6:	00 f1 91 c8 
842006ea:	11 8f       	M[r0 + 16] = rMAC;
    }

    /* Choose the opposite terminal. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.in_place_terminal = ((unsigned *)message_data)[0] ^TERMINAL_SINK_MASK;

    L4_DBG_MSG1("basic_passthrough_buffer_details  %d \n", ((OP_BUF_DETAILS_RSP*)*response_data)->b.in_place_buff_params.size);
842006ec:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842006f0:	08 25       	Null = rMAC - 4;
842006f2:	09 68       	if LT jump (m) Lc_basic_passthrough_buffer_details_20;

842006f4 <Lc_basic_passthrough_buffer_details_19>:
842006f4:	31 e8       	rMAC = M[r4 + Null];
842006f6:	4b 89       	r1 = M[rMAC + 20];
842006f8:	55 f1 02 f0 	r0 = Null + 357564416;
842006fc:	00 40 
842006fe:	ff fd 01 f0 	call (m) 0x9b4;
84200702:	37 e5 

84200704 <Lc_basic_passthrough_buffer_details_20>:
#ifndef DISABLE_IN_PLACE
    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel >= MAX_CHANS)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200704:	42 20       	r0 = Null + 1;

84200706 <Lc_basic_passthrough_buffer_details_21>:
    }
    L4_DBG_MSG1("basic_passthrough_buffer_details  %d \n", ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size);
#endif /* DISABLE_IN_PLACE */

    return TRUE;
}
84200706:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200708:	d8 4c       	rts;

8420070a <$_basic_passthrough_get_sched_info>:


bool basic_passthrough_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420070a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420070c:	17 00       	r5 = r0 + Null;
8420070e:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    if (!base_op_get_sched_info(op_data, message_data, response_id, response_data))
84200710:	ef fd fd ff 	call (m) 0x158;
84200714:	29 e2 
84200716:	10 04       	Null = r0 - Null;
84200718:	09 62       	if NE jump (m) Lc_basic_passthrough_get_sched_info_3;

8420071a <Lc_basic_passthrough_get_sched_info_2>:
    {
        return base_op_build_std_response(STATUS_CMD_FAILED, op_data->id, response_data);
8420071a:	7b 88       	r1 = M[r5 + 4];
8420071c:	02 f0 00 60 	r0 = Null + 4096;
84200720:	34 00       	r2 = r4 + Null;
84200722:	ef fd fd ff 	call (m) 0x204;
84200726:	23 e7 
84200728:	0a 6e       	jump (m) Lc_basic_passthrough_get_sched_info_4;

8420072a <Lc_basic_passthrough_get_sched_info_3>:
8420072a:	31 e8       	rMAC = M[r4 + Null];
8420072c:	48 8e       	M[rMAC + 4] = Null;
    }
    /* Populate the response*/
    base_op_change_response_status(response_data, STATUS_OK);
    resp = *response_data;
8420072e:	31 e8       	rMAC = M[r4 + Null];
    resp->op_id = op_data->id;
84200730:	7a 88       	r0 = M[r5 + 4];
84200732:	0a ee       	M[rMAC + Null] = r0;
    /* Same buffer size for sink and source.
       No additional verification needed.*/
    resp->block_size = BASIC_PASSTHROUGH_DEFAULT_BLOCK_SIZE;
84200734:	42 20       	r0 = Null + 1;
84200736:	8a 8e       	M[rMAC + 8] = r0;
    resp->run_period = 0;
84200738:	c8 8e       	M[rMAC + 12] = Null;

    *response_data = resp;
8420073a:	31 ee       	M[r4 + Null] = rMAC;

8420073c <Lc_basic_passthrough_get_sched_info_4>:
    return TRUE;
8420073c:	f2 48       	popm <FP, r4, r5, rLink>;
8420073e:	d8 4c       	rts;

84200740 <$_basic_passthrough_get_data_format>:
}


bool basic_passthrough_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200740:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200742:	10 09       	r6 = r0 + Null;
84200744:	1e 00       	r4 = r1 + Null;
84200746:	2f 00       	r5 = r3 + Null;
    BASIC_PASSTHROUGH_OP_DATA *opx_data;
    if (!base_op_get_data_format(op_data, message_data, response_id, response_data))
84200748:	ef fd fd ff 	call (m) 0x17a;
8420074c:	33 e1 
8420074e:	10 04       	Null = r0 - Null;
84200750:	03 62       	if NE jump (m) Lc_basic_passthrough_get_data_format_3;

84200752 <Lc_basic_passthrough_get_data_format_2>:
    {
        return FALSE;
84200752:	02 00       	r0 = Null + Null;
84200754:	10 6e       	jump (m) Lc_basic_passthrough_get_data_format_7;

84200756 <Lc_basic_passthrough_get_data_format_3>:
    }

    opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
84200756:	81 f0 0c 88 	rMAC = M[r6 + 48];
    /* return the terminal's data format - purely based on terminal data direction flag */
    if((((unsigned*)message_data)[0] & TERMINAL_SINK_MASK) == 0)
8420075a:	32 e8       	r0 = M[r4 + Null];
8420075c:	40 f0 22 f0 	r0 = r0 AND 0x800000;
84200760:	00 00 
84200762:	05 62       	if NE jump (m) Lc_basic_passthrough_get_data_format_5;

84200764 <Lc_basic_passthrough_get_data_format_4>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->op_format;
84200764:	89 88       	rMAC = M[rMAC + 8];
84200766:	3a e8       	r0 = M[r5 + Null];
84200768:	91 8e       	M[r0 + 8] = rMAC;
8420076a:	04 6e       	jump (m) Lc_basic_passthrough_get_data_format_6;

8420076c <Lc_basic_passthrough_get_data_format_5>:
    }
    else
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->ip_format;
8420076c:	49 88       	rMAC = M[rMAC + 4];
8420076e:	3a e8       	r0 = M[r5 + Null];
84200770:	91 8e       	M[r0 + 8] = rMAC;

84200772 <Lc_basic_passthrough_get_data_format_6>:
    }

    return TRUE;
84200772:	42 20       	r0 = Null + 1;

84200774 <Lc_basic_passthrough_get_data_format_7>:
}
84200774:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200776:	d8 4c       	rts;

84200778 <$_basic_passthrough_opmsg_enable_fadeout>:
    }
    return TRUE;
}

bool basic_passthrough_opmsg_enable_fadeout(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200778:	c8 1c       	pushm <FP(=SP), rLink>;
    return set_fadeout_state(op_data, RUNNING_STATE);
8420077a:	43 20       	r1 = Null + 1;
8420077c:	02 f0 21 e9 	call (m) Lc_set_fadeout_state_1;

84200780 <Lc_basic_passthrough_opmsg_enable_fadeout_2>:
}
84200780:	c8 48       	popm <FP, rLink>;
84200782:	d8 4c       	rts;

84200784 <$_basic_passthrough_opmsg_disable_fadeout>:


bool basic_passthrough_opmsg_disable_fadeout(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200784:	c8 1c       	pushm <FP(=SP), rLink>;
    return set_fadeout_state(op_data, NOT_RUNNING_STATE);
84200786:	03 00       	r1 = Null + Null;
84200788:	02 f0 35 e8 	call (m) Lc_set_fadeout_state_1;

8420078c <Lc_basic_passthrough_opmsg_disable_fadeout_2>:
}
8420078c:	c8 48       	popm <FP, rLink>;
8420078e:	d8 4c       	rts;

84200790 <$_basic_passthrough_change_input_data_type>:
/*
 * basic_passthrough_change_single_input_data_type
 */
bool basic_passthrough_change_input_data_type(OPERATOR_DATA *op_data, void *message_data,
                                            unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200790:	c8 1c       	pushm <FP(=SP), rLink>;
84200792:	19 00       	rMAC = r1 + Null;
    /* The input data type determines whether to perform a straight copy
     * or apply a gain, if this is a basic passthrough operator.
     * Audio = apply a gain.
     */
    if ((BASIC_PASS_CAP_ID == op_data->cap_data->id) || (TTP_PASS_CAP_ID == op_data->cap_data->id))
84200794:	53 89       	r1 = M[r0 + 20];
84200796:	1b e8       	r1 = M[r1 + Null];
84200798:	01 f0 30 f0 	Null = r1 - 16386;
8420079c:	02 24 
8420079e:	05 60       	if EQ jump (m) Lc_basic_passthrough_change_input_data_type_3;

842007a0 <Lc_basic_passthrough_change_input_data_type_2>:
842007a0:	01 f0 30 f0 	Null = r1 - 16487;
842007a4:	67 24 
842007a6:	0f 62       	if NE jump (m) Lc_basic_passthrough_change_input_data_type_6;

842007a8 <Lc_basic_passthrough_change_input_data_type_3>:
    {
        if (AUDIO_DATA_FORMAT_FIXP == ((unsigned*)message_data)[3])
842007a8:	cb 88       	r1 = M[rMAC + 12];
842007aa:	58 24       	Null = r1 - 1;
842007ac:	07 62       	if NE jump (m) Lc_basic_passthrough_change_input_data_type_5;

842007ae <Lc_basic_passthrough_change_input_data_type_4>:
        {
            ((BASIC_PASSTHROUGH_OP_DATA*)(op_data->extra_op_data))->copy_function = (void *)(&mono_audio_loop);
842007ae:	42 f0 13 f0 	r1 = Null + 69215833;
842007b2:	59 4a 
842007b4:	14 99       	r2 = M[r0 + 48];
842007b6:	23 ee       	M[r2 + Null] = r1;
842007b8:	06 6e       	jump (m) Lc_basic_passthrough_change_input_data_type_6;

842007ba <Lc_basic_passthrough_change_input_data_type_5>:
        }
        else
        {
            ((BASIC_PASSTHROUGH_OP_DATA*)(op_data->extra_op_data))->copy_function = (void *)(&mono_data_loop);
842007ba:	42 f0 13 f0 	r1 = Null + 69215859;
842007be:	73 4a 
842007c0:	14 99       	r2 = M[r0 + 48];
842007c2:	23 ee       	M[r2 + Null] = r1;

842007c4 <Lc_basic_passthrough_change_input_data_type_6>:
        }
    }
    /* Call with sink terminal 0 (which then basically has ID == TERMINAL_SINK_MASK) */
    return common_change_terminal_data_type(op_data, TRUE, message_data);
842007c4:	43 20       	r1 = Null + 1;
842007c6:	0c 00       	r2 = rMAC + Null;
842007c8:	02 f0 29 e8 	call (m) Lc_common_change_terminal_data_type_1;

842007cc <Lc_basic_passthrough_change_input_data_type_7>:
}
842007cc:	c8 48       	popm <FP, rLink>;
842007ce:	d8 4c       	rts;

842007d0 <$_basic_passthrough_change_output_data_type>:
/*
 * basic_passthrough_change_single_output_data_type
 */
bool basic_passthrough_change_output_data_type(OPERATOR_DATA *op_data, void *message_data,
                                           unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842007d0:	c8 1c       	pushm <FP(=SP), rLink>;
842007d2:	19 00       	rMAC = r1 + Null;
    /* Call with source terminal ID 0 */
    return common_change_terminal_data_type(op_data, FALSE, message_data);
842007d4:	03 00       	r1 = Null + Null;
842007d6:	0c 00       	r2 = rMAC + Null;
842007d8:	02 f0 39 e7 	call (m) Lc_common_change_terminal_data_type_1;

842007dc <Lc_basic_passthrough_change_output_data_type_2>:
}
842007dc:	c8 48       	popm <FP, rLink>;
842007de:	d8 4c       	rts;

842007e0 <$_basic_passthrough_data_stream_based>:
 */
bool basic_passthrough_data_stream_based(OPERATOR_DATA *op_data, void *message_data,
                                            unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    /* The 3rd message word is a boolean value */
    ((BASIC_PASSTHROUGH_OP_DATA*)(op_data->extra_op_data))->simple_data_test_safe = ((unsigned*)message_data)[3];
842007e0:	d9 88       	rMAC = M[r1 + 12];
842007e2:	12 99       	r0 = M[r0 + 48];
842007e4:	d1 8e       	M[r0 + 12] = rMAC;

    return TRUE;
842007e6:	42 20       	r0 = Null + 1;

842007e8 <Lc_basic_passthrough_data_stream_based_2>:
842007e8:	d8 4c       	rts;

842007ea <$_basic_passthrough_opmsg_obpm_set_control>:
#endif

/* **************************** Operator message handlers ******************************** */

bool basic_passthrough_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842007ea:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842007ec:	18 09       	r6 = r1 + Null;
842007ee:	2a 09       	r8 = r3 + Null;
842007f0:	23 00       	r1 = r2 + Null;
    BASIC_PASSTHROUGH_OP_DATA     *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
842007f2:	16 99       	r4 = M[r0 + 48];
    unsigned            i,num_controls,cntrl_value;

    CPS_CONTROL_SOURCE  cntrl_src;

    unsigned result = OPMSG_RESULT_STATES_NORMAL_STATE;
842007f4:	01 09       	r7 = Null + Null;

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
842007f6:	c5 11       	r3 = FP + 28;
842007f8:	54 08       	r2 = r8 + Null;
842007fa:	42 08       	r0 = r6 + Null;
842007fc:	ef fd ff ff 	call (m) 0x7c6;
84200800:	2b ee 
84200802:	10 04       	Null = r0 - Null;
84200804:	03 62       	if NE jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_3;

84200806 <Lc_basic_passthrough_opmsg_obpm_set_control_2>:
    {
       return FALSE;
84200806:	02 00       	r0 = Null + Null;
84200808:	39 6e       	jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_19;

8420080a <Lc_basic_passthrough_opmsg_obpm_set_control_3>:
    }

    for(i=0;i<num_controls;i++)
8420080a:	07 00       	r5 = Null + Null;
8420080c:	05 6e       	jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_7;

8420080e <Lc_basic_passthrough_opmsg_obpm_set_control_4>:
        {
            result = OPMSG_RESULT_STATES_INVALID_CONTROL_VALUE;
            break;
        }
        /* Control is Mode */
        if(cntrl_src == CPS_SOURCE_HOST)
8420080e:	22 d1       	r0 = MBS[FP + 36];
84200810:	1f 62       	if NE jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_14;

84200812 <Lc_basic_passthrough_opmsg_obpm_set_control_5>:
        {
            op_extra_data->Host_mode = cntrl_value;
84200812:	31 be       	M[r4 + 96] = rMAC;

84200814 <Lc_basic_passthrough_opmsg_obpm_set_control_6>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
       return FALSE;
    }

    for(i=0;i<num_controls;i++)
84200814:	7f 20       	r5 = r5 + 1;

84200816 <Lc_basic_passthrough_opmsg_obpm_set_control_7>:
84200816:	39 d8       	rMAC = M[FP + 28];
84200818:	78 04       	Null = r5 - rMAC;
8420081a:	02 f0 99 e0 	if C jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_10;

8420081e <Lc_basic_passthrough_opmsg_obpm_set_control_8>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
8420081e:	45 12       	r3 = FP + 36;
84200820:	04 12       	r2 = FP + 32;
84200822:	3b 00       	r1 = r5 + Null;
84200824:	42 08       	r0 = r6 + Null;
84200826:	ef fd ff ff 	call (m) 0x812;
8420082a:	2d ef 

        if(cntrl_id != OPMSG_CONTROL_MODE_ID)
8420082c:	50 24       	Null = r0 - 1;
8420082e:	09 60       	if EQ jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_12;

84200830 <Lc_basic_passthrough_opmsg_obpm_set_control_9>:
        {
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
84200830:	21 71       	r7 = Null + 4;

84200832 <Lc_basic_passthrough_opmsg_obpm_set_control_10>:
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  0 : BASIC_PASSTHROUGH_CONTROL_MODE_OVERRIDE;
            op_extra_data->Obpm_mode = cntrl_value;
        }
    }

    if(op_extra_data->Ovr_Control & BASIC_PASSTHROUGH_CONTROL_MODE_OVERRIDE)
84200832:	b1 b8       	rMAC = M[r4 + 104];
84200834:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
84200838:	14 60       	if EQ jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_15;

8420083a <Lc_basic_passthrough_opmsg_obpm_set_control_11>:
    {
       op_extra_data->Cur_mode = op_extra_data->Obpm_mode;
8420083a:	71 b8       	rMAC = M[r4 + 100];
8420083c:	f1 af       	M[r4 + 92] = rMAC;
8420083e:	13 6e       	jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_16;

84200840 <Lc_basic_passthrough_opmsg_obpm_set_control_12>:
        {
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
            break;
        }

        cntrl_value &= 0xFF;
84200840:	41 d8       	rMAC = M[FP + 32];
84200842:	89 c3       	rMAC = rMAC AND 0xff;
84200844:	41 de       	M[FP + 32] = rMAC;
        if (cntrl_value >= BASIC_PASSTHROUGH_SYSMODE_MAX_MODES)
84200846:	c8 24       	Null = rMAC - 3;
84200848:	e3 65       	if NC jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_4;

8420084a <Lc_basic_passthrough_opmsg_obpm_set_control_13>:
        {
            result = OPMSG_RESULT_STATES_INVALID_CONTROL_VALUE;
8420084a:	29 71       	r7 = Null + 5;
            break;
8420084c:	f3 6f       	jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_10;

8420084e <Lc_basic_passthrough_opmsg_obpm_set_control_14>:
        {
            op_extra_data->Host_mode = cntrl_value;
        }
        else
        {
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  0 : BASIC_PASSTHROUGH_CONTROL_MODE_OVERRIDE;
8420084e:	11 f0 00 40 	rMAC = Null + 8192;
84200852:	d0 24       	Null = r0 - 3;
84200854:	00 f0 01 c0 	if EQ rMAC = Null + Null;
84200858:	b1 be       	M[r4 + 104] = rMAC;
            op_extra_data->Obpm_mode = cntrl_value;
8420085a:	41 d8       	rMAC = M[FP + 32];
8420085c:	71 be       	M[r4 + 100] = rMAC;
8420085e:	db 6f       	jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_6;

84200860 <Lc_basic_passthrough_opmsg_obpm_set_control_15>:
    {
       op_extra_data->Cur_mode = op_extra_data->Obpm_mode;
    }
    else
    {
      op_extra_data->Cur_mode = op_extra_data->Host_mode;
84200860:	31 b8       	rMAC = M[r4 + 96];
84200862:	f1 af       	M[r4 + 92] = rMAC;

84200864 <Lc_basic_passthrough_opmsg_obpm_set_control_16>:
    }

    cps_response_set_result(resp_data,result);
84200864:	4b 08       	r1 = r7 + Null;
84200866:	52 08       	r0 = r8 + Null;
84200868:	ef fd ff ff 	call (m) 0x854;
8420086c:	2d ef 

    /* Set the Reinit flag after setting the paramters */
    if (result == OPMSG_RESULT_STATES_NORMAL_STATE)
8420086e:	0f f9 00 c2 	Null = r7 - Null;
84200872:	03 62       	if NE jump (m) Lc_basic_passthrough_opmsg_obpm_set_control_18;

84200874 <Lc_basic_passthrough_opmsg_obpm_set_control_17>:
    {
        op_extra_data->ReInitFlag = 1;
84200874:	41 20       	rMAC = Null + 1;
84200876:	b1 af       	M[r4 + 88] = rMAC;

84200878 <Lc_basic_passthrough_opmsg_obpm_set_control_18>:
    }
    return TRUE;
84200878:	42 20       	r0 = Null + 1;

8420087a <Lc_basic_passthrough_opmsg_obpm_set_control_19>:
}
8420087a:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
8420087c:	d8 4c       	rts;

8420087e <$_basic_passthrough_opmsg_obpm_get_params>:

bool basic_passthrough_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420087e:	c8 1c       	pushm <FP(=SP), rLink>;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
84200880:	11 99       	rMAC = M[r0 + 48];

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84200882:	12 f0 90 20 	r0 = rMAC + 144;
84200886:	ef fd fd ff 	call (m) 0x482;
8420088a:	3d ef 

8420088c <Lc_basic_passthrough_opmsg_obpm_get_params_2>:
}
8420088c:	c8 48       	popm <FP, rLink>;
8420088e:	d8 4c       	rts;

84200890 <$_basic_passthrough_opmsg_obpm_get_defaults>:

bool basic_passthrough_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200890:	c8 1c       	pushm <FP(=SP), rLink>;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
84200892:	11 99       	rMAC = M[r0 + 48];

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84200894:	12 f0 90 20 	r0 = rMAC + 144;
84200898:	ef fd fe ff 	call (m) 0x532;
8420089c:	3b e4 

8420089e <Lc_basic_passthrough_opmsg_obpm_get_defaults_2>:
}
8420089e:	c8 48       	popm <FP, rLink>;
842008a0:	d8 4c       	rts;

842008a2 <$_basic_passthrough_opmsg_obpm_set_params>:

bool basic_passthrough_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842008a2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
842008a4:	16 99       	r4 = M[r0 + 48];
    bool retval;

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842008a6:	62 f0 90 20 	r0 = r4 + 144;
842008aa:	ef fd fe ff 	call (m) 0x612;
842008ae:	29 eb 

    /* Set the Reinit flag after setting the paramters */
    op_extra_data->ReInitFlag = 1;
842008b0:	41 20       	rMAC = Null + 1;
842008b2:	b1 af       	M[r4 + 88] = rMAC;

842008b4 <Lc_basic_passthrough_opmsg_obpm_set_params_2>:

    return retval;
842008b4:	f1 48       	popm <FP, r4, rLink>;
842008b6:	d8 4c       	rts;

842008b8 <$_basic_passthrough_opmsg_obpm_get_status>:
}

bool basic_passthrough_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842008b8:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842008ba:	19 00       	rMAC = r1 + Null;
842008bc:	23 00       	r1 = r2 + Null;
842008be:	2c 00       	r2 = r3 + Null;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
842008c0:	16 99       	r4 = M[r0 + 48];
    unsigned  *resp;

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(BASIC_PASSTHROUGH_STATISTICS),&resp))
842008c2:	c2 10       	r0 = FP + 12;
842008c4:	11 1c       	pushm <r0>;
842008c6:	05 32       	r3 = Null + 40;
842008c8:	0a 00       	r0 = rMAC + Null;
842008ca:	ef fd ff ff 	call (m) 0x868;
842008ce:	3f ec 
842008d0:	7f 4c       	SP = SP + -4;
842008d2:	10 04       	Null = r0 - Null;
842008d4:	03 62       	if NE jump (m) Lc_basic_passthrough_opmsg_obpm_get_status_3;

842008d6 <Lc_basic_passthrough_opmsg_obpm_get_status_2>:
    {
         return FALSE;
842008d6:	02 00       	r0 = Null + Null;
842008d8:	3b 6e       	jump (m) Lc_basic_passthrough_opmsg_obpm_get_status_6;

842008da <Lc_basic_passthrough_opmsg_obpm_get_status_3>:
    }

    if(resp)
842008da:	1c d8       	r2 = M[FP + 12];
842008dc:	38 60       	if EQ jump (m) Lc_basic_passthrough_opmsg_obpm_get_status_5;

842008de <Lc_basic_passthrough_opmsg_obpm_get_status_4>:
    {
    resp = cpsPackWords(&op_extra_data->Cur_mode, &op_extra_data->peak_level_1, resp);
842008de:	63 f0 70 20 	r1 = r4 + 112;
842008e2:	62 f0 5c 20 	r0 = r4 + 92;
842008e6:	ff fd 5b f1 	call (m) 0x2c056;
842008ea:	31 eb 
842008ec:	1a de       	M[FP + 12] = r0;
    resp = cpsPackWords(&op_extra_data->peak_level_2, &op_extra_data->peak_level_3, resp);
842008ee:	1c d8       	r2 = M[FP + 12];
842008f0:	63 f0 78 20 	r1 = r4 + 120;
842008f4:	62 f0 74 20 	r0 = r4 + 116;
842008f8:	ff fd 5b f1 	call (m) 0x2c056;
842008fc:	3f ea 
842008fe:	1a de       	M[FP + 12] = r0;
    resp = cpsPackWords(&op_extra_data->peak_level_4, &op_extra_data->peak_level_5, resp);
84200900:	1c d8       	r2 = M[FP + 12];
84200902:	63 f0 80 20 	r1 = r4 + 128;
84200906:	62 f0 7c 20 	r0 = r4 + 124;
8420090a:	ff fd 5b f1 	call (m) 0x2c056;
8420090e:	2d ea 
84200910:	1a de       	M[FP + 12] = r0;
    resp = cpsPackWords(&op_extra_data->peak_level_6, &op_extra_data->peak_level_7, resp);
84200912:	1c d8       	r2 = M[FP + 12];
84200914:	63 f0 88 20 	r1 = r4 + 136;
84200918:	62 f0 84 20 	r0 = r4 + 132;
8420091c:	ff fd 5b f1 	call (m) 0x2c056;
84200920:	3b e9 
84200922:	1a de       	M[FP + 12] = r0;
    cpsPackWords((unsigned*)&op_extra_data->peak_level_8, &op_extra_data->Ovr_Control, resp);
84200924:	1c d8       	r2 = M[FP + 12];
84200926:	63 f0 68 20 	r1 = r4 + 104;
8420092a:	62 f0 8c 20 	r0 = r4 + 140;
8420092e:	ff fd 5b f1 	call (m) 0x2c056;
84200932:	29 e9 
    op_extra_data->peak_level_1 = 0;
84200934:	30 bf       	M[r4 + 112] = Null;
    op_extra_data->peak_level_2 = 0;
84200936:	70 bf       	M[r4 + 116] = Null;
    op_extra_data->peak_level_3 = 0;
84200938:	b0 bf       	M[r4 + 120] = Null;
    op_extra_data->peak_level_4 = 0;
8420093a:	f0 bf       	M[r4 + 124] = Null;
    op_extra_data->peak_level_5 = 0;
8420093c:	60 f0 20 8e 	M[r4 + 128] = Null;
    op_extra_data->peak_level_6 = 0;
84200940:	60 f0 21 8e 	M[r4 + 132] = Null;
    op_extra_data->peak_level_7 = 0;
84200944:	60 f0 22 8e 	M[r4 + 136] = Null;
    op_extra_data->peak_level_8 = 0;
84200948:	60 f0 23 8e 	M[r4 + 140] = Null;

8420094c <Lc_basic_passthrough_opmsg_obpm_get_status_5>:
    }

    return TRUE;
8420094c:	42 20       	r0 = Null + 1;

8420094e <Lc_basic_passthrough_opmsg_obpm_get_status_6>:
}
8420094e:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84200950:	d8 4c       	rts;

84200952 <$_basic_passthrough_opmsg_set_ucid>:


bool basic_passthrough_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200952:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200954:	10 09       	r6 = r0 + Null;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
84200956:	86 f0 0c 88 	r4 = M[r6 + 48];
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
8420095a:	62 f0 90 20 	r0 = r4 + 144;
8420095e:	ef fd fe ff 	call (m) 0x6b2;
84200962:	35 ea 
84200964:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(op_data->cap_data->id, op_extra_data->parms_def.ucid, OPMSG_P_STORE_PARAMETER_SUB_ID);
84200966:	61 f0 28 88 	rMAC = M[r4 + 160];
8420096a:	8a c2       	r0 = rMAC AND 0x3f;
8420096c:	12 54       	r0 = r0 LSHIFT 1;
8420096e:	81 f0 05 88 	rMAC = M[r6 + 20];
84200972:	09 e8       	rMAC = M[rMAC + Null];
84200974:	8b c6       	r1 = rMAC AND 0xffff;
84200976:	9b 55       	r1 = r1 LSHIFT 7;
84200978:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_basic_passthrough);
8420097a:	42 f0 05 f0 	r3 = Null + 69208921;
8420097e:	59 53 
84200980:	04 00       	r2 = Null + Null;
84200982:	42 08       	r0 = r6 + Null;
84200984:	ff fd 24 f1 	call (m) 0x25204;
84200988:	21 e4 

    return retval;
8420098a:	3a 00       	r0 = r5 + Null;

8420098c <Lc_basic_passthrough_opmsg_set_ucid_2>:
}
8420098c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420098e:	d8 4c       	rts;

84200990 <$_basic_passthrough_opmsg_set_buffer_size>:
    return TRUE;
}

bool basic_passthrough_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
84200990:	11 99       	rMAC = M[r0 + 48];
    opx_data->latency_buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
84200992:	da 88       	r0 = M[r1 + 12];
84200994:	92 c6       	r0 = r0 AND 0xffff;
84200996:	4a 8f       	M[rMAC + 20] = r0;

    return TRUE;
84200998:	42 20       	r0 = Null + 1;

8420099a <Lc_basic_passthrough_opmsg_set_buffer_size_2>:
8420099a:	d8 4c       	rts;

8420099c <$_basic_passthrough_opmsg_get_ps_id>:

    return retval;
}

bool basic_passthrough_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420099c:	c8 1c       	pushm <FP(=SP), rLink>;
8420099e:	19 00       	rMAC = r1 + Null;
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)op_data->extra_op_data;
842009a0:	12 99       	r0 = M[r0 + 48];

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,CAP_ID_PEQ,message_data,resp_length,resp_data);
842009a2:	29 1c       	pushm <r3>;
842009a4:	03 f0 49 40 	r1 = Null + 73;
842009a8:	02 f0 90 44 	r0 = r0 + 144;
842009ac:	25 00       	r3 = r2 + Null;
842009ae:	0c 00       	r2 = rMAC + Null;
842009b0:	ef fd fe ff 	call (m) 0x6d2;
842009b4:	23 e9 
842009b6:	7f 4c       	SP = SP + -4;

842009b8 <Lc_basic_passthrough_opmsg_get_ps_id_2>:
}
842009b8:	c8 48       	popm <FP, rLink>;
842009ba:	d8 4c       	rts;

842009bc <$_basic_passthrough_opmsg_load_config>:


bool basic_passthrough_opmsg_load_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    return(TRUE);
842009bc:	42 20       	r0 = Null + 1;

842009be <Lc_basic_passthrough_opmsg_load_config_2>:
842009be:	d8 4c       	rts;

842009c0 <$_basic_passthrough_opmsg_set_sample_rate>:
}

bool basic_passthrough_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    BASIC_PASSTHROUGH_OP_DATA *p_ext_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
842009c0:	11 99       	rMAC = M[r0 + 48];

    /* We received client ID, length and then opmsgID and OBPM params */
    p_ext_data->sample_rate = 25 * ((unsigned*)message_data)[3];
842009c2:	da 88       	r0 = M[r1 + 12];
842009c4:	52 46       	r0 = r0 * 25 (int);
842009c6:	8a 8f       	M[rMAC + 24] = r0;
    p_ext_data->ReInitFlag = 1;
842009c8:	42 20       	r0 = Null + 1;
842009ca:	8a af       	M[rMAC + 88] = r0;

842009cc <Lc_basic_passthrough_opmsg_set_sample_rate_2>:

    return(TRUE);
842009cc:	d8 4c       	rts;

842009ce <$_basic_passthrough_process_data>:
#endif /* INSTALL_OPERATOR_TTP_PASS */


RUN_FROM_PM_RAM
void basic_passthrough_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
842009ce:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
842009d0:	42 de       	M[FP + 32] = r0;
842009d2:	11 00       	rMAC = r0 + Null;
842009d4:	4b de       	M[FP + 36] = r1;
#if BASIC_PASSTHROUGH_DEFAULT_BLOCK_SIZE != 1
#error The process data function kick backwards logic is only valid when block size is 1
#endif
    unsigned i, data_to_process, num_active_chans, output_space;
    /* Alias channels up front as all paths need it. */
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
842009d6:	09 99       	rMAC = M[rMAC + 48];
842009d8:	51 de       	M[FP + 40] = rMAC;
    PASSTHROUGH_CHANNEL **channels = opx_data->channel;
842009da:	09 31       	rMAC = rMAC + 36;
842009dc:	59 de       	M[FP + 44] = rMAC;
    bool buffers_16bit_ex = FALSE;
842009de:	60 de       	M[FP + 48] = Null;
    unsigned (*input_samples_fn)(tCbuffer *cbuffer) = cbuffer_calc_amount_data_in_words;
842009e0:	61 f1 09 42 	rMAC = Null + 180745;
842009e4:	69 de       	M[FP + 52] = rMAC;
    unsigned (*output_space_fn)(tCbuffer *cbuffer) = cbuffer_calc_amount_space_in_words;
842009e6:	6b f1 b7 41 	r9 = Null + 180663;

    if (opx_data->num_active_chans == 0)
842009ea:	51 d8       	rMAC = M[FP + 40];
842009ec:	c9 89       	rMAC = M[rMAC + 28];
842009ee:	b3 60       	if EQ jump (m) Lc_basic_passthrough_process_data_46;

842009f0 <Lc_basic_passthrough_process_data_2>:
        /* Unlike other capabilities, basic_passthrough can be started even if
        it is not connected properly. This is used for test purposes. The
        following early return prevents dereferencing NULL pointers. */
        return;
    }
    else if (opx_data->simple_data_test_safe)
842009f0:	52 d8       	r0 = M[FP + 40];
842009f2:	d0 88       	Null = M[r0 + 12];
842009f4:	04 60       	if EQ jump (m) Lc_basic_passthrough_process_data_4;

842009f6 <Lc_basic_passthrough_process_data_3>:
    {
        num_active_chans = 1;
842009f6:	41 20       	rMAC = Null + 1;
842009f8:	71 de       	M[FP + 56] = rMAC;
842009fa:	02 6e       	jump (m) Lc_basic_passthrough_process_data_5;

842009fc <Lc_basic_passthrough_process_data_4>:
    else
    {
        /* Alias the thing we want to iterate in the loop as this stops the compiler
         * deciding to access it in a suboptimal way.
         */
        num_active_chans = opx_data->num_active_chans;
842009fc:	71 de       	M[FP + 56] = rMAC;

842009fe <Lc_basic_passthrough_process_data_5>:
    }

#if defined(INSTALL_CBUFFER_EX)
    if (opx_data->ip_format != opx_data->op_format)
842009fe:	51 d8       	rMAC = M[FP + 40];
84200a00:	0a 00       	r0 = rMAC + Null;
84200a02:	49 88       	rMAC = M[rMAC + 4];
84200a04:	92 88       	r0 = M[r0 + 8];
84200a06:	88 04       	Null = rMAC - r0;
84200a08:	09 60       	if EQ jump (m) Lc_basic_passthrough_process_data_7;

84200a0a <Lc_basic_passthrough_process_data_6>:
    {
        fault_diatribe(FAULT_AUDIO_PASSTHROUGH_FORMAT_MISMATCH,op_data->id);
84200a0a:	41 d8       	rMAC = M[FP + 32];
84200a0c:	4b 88       	r1 = M[rMAC + 4];
84200a0e:	02 f0 58 40 	r0 = Null + 88;
84200a12:	ff fd 98 f0 	call (m) 0x13bcc;
84200a16:	3b ed 
84200a18:	0e 6e       	jump (m) Lc_basic_passthrough_process_data_11;

84200a1a <Lc_basic_passthrough_process_data_7>:
    {
        /* Check if the buffers need special processing
         * Checks during connect ensure that all of the buffers are the same
         * configuration, so we just need to check channel 0.
         */
        switch (opx_data->ip_format)
84200a1a:	08 04       	Null = rMAC - Null;
84200a1c:	03 60       	if EQ jump (m) Lc_basic_passthrough_process_data_9;

84200a1e <Lc_basic_passthrough_process_data_8>:
84200a1e:	88 24       	Null = rMAC - 2;
84200a20:	09 62       	if NE jump (m) Lc_basic_passthrough_process_data_10;

84200a22 <Lc_basic_passthrough_process_data_9>:
        {
        case AUDIO_DATA_FORMAT_16_BIT:
        case AUDIO_DATA_FORMAT_16_BIT_WITH_METADATA:
            buffers_16bit_ex = TRUE;
84200a22:	41 20       	rMAC = Null + 1;
84200a24:	61 de       	M[FP + 48] = rMAC;
            input_samples_fn = cbuffer_calc_amount_data_ex;
84200a26:	71 f1 b7 69 	rMAC = Null + 193975;
84200a2a:	69 de       	M[FP + 52] = rMAC;
            output_space_fn = cbuffer_calc_amount_space_ex;
84200a2c:	7b f1 05 6a 	r9 = Null + 194053;
            break;
84200a30:	02 6e       	jump (m) Lc_basic_passthrough_process_data_11;

84200a32 <Lc_basic_passthrough_process_data_10>:

        default:
            buffers_16bit_ex = FALSE;
84200a32:	60 de       	M[FP + 48] = Null;

84200a34 <Lc_basic_passthrough_process_data_11>:
    }
#endif /* INSTALL_CBUFFER_EX */

    /* work out minimum amount of input data and output space this is what can
     * be processed and ensure synchronisation between channels. */
    data_to_process = input_samples_fn(channels[0]->ip_buffer);
84200a34:	59 d8       	rMAC = M[FP + 44];
84200a36:	09 e8       	rMAC = M[rMAC + Null];
84200a38:	0a e8       	r0 = M[rMAC + Null];
84200a3a:	69 d8       	rMAC = M[FP + 52];
84200a3c:	d1 4c       	call rMAC;
84200a3e:	12 09       	r8 = r0 + Null;
    EXIT_IF_INSUFFICIENT_DATA(data_to_process);
84200a40:	8a 60       	if EQ jump (m) Lc_basic_passthrough_process_data_46;

84200a42 <Lc_basic_passthrough_process_data_12>:

    output_space = output_space_fn(channels[0]->op_buffer);
84200a42:	59 d8       	rMAC = M[FP + 44];
84200a44:	09 e8       	rMAC = M[rMAC + Null];
84200a46:	4a 88       	r0 = M[rMAC + 4];
84200a48:	0f fb 00 ce 	call r9;
84200a4c:	10 09       	r6 = r0 + Null;

    if (opx_data->kick_on_full_output && (data_to_process > output_space))
84200a4e:	51 d8       	rMAC = M[FP + 40];
84200a50:	48 a8       	Null = M[rMAC + 68];
84200a52:	09 60       	if EQ jump (m) Lc_basic_passthrough_process_data_15;

84200a54 <Lc_basic_passthrough_process_data_13>:
84200a54:	8f fa 00 c2 	Null = r8 - r6;
84200a58:	09 f0 8d e0 	if LS jump (m) Lc_basic_passthrough_process_data_15;

84200a5c <Lc_basic_passthrough_process_data_14>:
    {
        /* Kick forwards to keep data flowing in case the next operator is a splitter */
        touched->sources = opx_data->active_chans;
84200a5c:	51 d8       	rMAC = M[FP + 40];
84200a5e:	4a d8       	r0 = M[FP + 36];
84200a60:	09 98       	rMAC = M[rMAC + 32];
84200a62:	11 ee       	M[r0 + Null] = rMAC;

84200a64 <Lc_basic_passthrough_process_data_15>:
    }

    EXIT_IF_INSUFFICIENT_DATA(output_space);
84200a64:	0f f8 00 c2 	Null = r6 - Null;
84200a68:	76 60       	if EQ jump (m) Lc_basic_passthrough_process_data_46;

84200a6a <Lc_basic_passthrough_process_data_16>:

    for (i = 1; i < num_active_chans; i++)
84200a6a:	46 20       	r4 = Null + 1;
84200a6c:	59 d8       	rMAC = M[FP + 44];
84200a6e:	0f 21       	r5 = rMAC + 4;

84200a70 <Lc_basic_passthrough_process_data_17>:
84200a70:	71 d8       	rMAC = M[FP + 56];
84200a72:	70 04       	Null = r4 - rMAC;
84200a74:	02 f0 b7 e0 	if C jump (m) Lc_basic_passthrough_process_data_25;

84200a78 <Lc_basic_passthrough_process_data_18>:
    {
        /* Alias the channel as a hint to the compiler that it's useful (also
         * makes the code more readable) */
        PASSTHROUGH_CHANNEL *this_channel = channels[i];
84200a78:	79 f0 00 e8 	r7 = M[r5 + Null];

        /* The Kymera scheduling strategy relies on operators yielding quickly
         * when they have nothing to do. The check is almost free so if there is
         * insufficient data or space then return.
         */
        unsigned amount = input_samples_fn(this_channel->ip_buffer);
84200a7c:	92 f0 00 e8 	r0 = M[r7 + Null];
84200a80:	69 d8       	rMAC = M[FP + 52];
84200a82:	d1 4c       	call rMAC;
        EXIT_IF_INSUFFICIENT_DATA(amount);
84200a84:	10 04       	Null = r0 - Null;
84200a86:	67 60       	if EQ jump (m) Lc_basic_passthrough_process_data_46;

84200a88 <Lc_basic_passthrough_process_data_19>:
        data_to_process = MIN(data_to_process,amount);
84200a88:	2f fa 00 c2 	Null = r8 - r0;
84200a8c:	02 64       	if NC jump (m) Lc_basic_passthrough_process_data_21;

84200a8e <Lc_basic_passthrough_process_data_20>:
84200a8e:	12 09       	r8 = r0 + Null;

84200a90 <Lc_basic_passthrough_process_data_21>:

        amount = output_space_fn(this_channel->op_buffer);
84200a90:	92 f0 01 88 	r0 = M[r7 + 4];
84200a94:	0f fb 00 ce 	call r9;
        EXIT_IF_INSUFFICIENT_DATA(amount);
84200a98:	10 04       	Null = r0 - Null;
84200a9a:	5d 60       	if EQ jump (m) Lc_basic_passthrough_process_data_46;

84200a9c <Lc_basic_passthrough_process_data_22>:
        output_space = MIN(output_space,amount);
84200a9c:	2f f8 00 c2 	Null = r6 - r0;
84200aa0:	02 64       	if NC jump (m) Lc_basic_passthrough_process_data_24;

84200aa2 <Lc_basic_passthrough_process_data_23>:
84200aa2:	10 09       	r6 = r0 + Null;

84200aa4 <Lc_basic_passthrough_process_data_24>:
        touched->sources = opx_data->active_chans;
    }

    EXIT_IF_INSUFFICIENT_DATA(output_space);

    for (i = 1; i < num_active_chans; i++)
84200aa4:	76 20       	r4 = r4 + 1;
84200aa6:	3f 21       	r5 = r5 + 4;
84200aa8:	e4 6f       	jump (m) Lc_basic_passthrough_process_data_17;

84200aaa <Lc_basic_passthrough_process_data_25>:
        EXIT_IF_INSUFFICIENT_DATA(amount);
        output_space = MIN(output_space,amount);
    }

    /* We have got this far, so we have something to do on every output */
    touched->sources = opx_data->active_chans;
84200aaa:	51 d8       	rMAC = M[FP + 40];
84200aac:	4a d8       	r0 = M[FP + 36];
84200aae:	09 98       	rMAC = M[rMAC + 32];
84200ab0:	11 ee       	M[r0 + Null] = rMAC;

    /* Now determine if we will empty (at least one) input */
    if (output_space >= data_to_process)
84200ab2:	af f8 00 c2 	Null = r6 - r8;
84200ab6:	04 64       	if NC jump (m) Lc_basic_passthrough_process_data_27;

84200ab8 <Lc_basic_passthrough_process_data_26>:
    {
        touched->sinks = touched->sources;
84200ab8:	4a d8       	r0 = M[FP + 36];
84200aba:	51 8e       	M[r0 + 4] = rMAC;
84200abc:	02 6e       	jump (m) Lc_basic_passthrough_process_data_28;

84200abe <Lc_basic_passthrough_process_data_27>:
    }
    else
    {
        data_to_process = output_space;
84200abe:	42 09       	r8 = r6 + Null;

84200ac0 <Lc_basic_passthrough_process_data_28>:
    }

    /* Is fadeout enabled? if yes, do it on the current input data */
    if(   channels[0]->fadeout_parameters.fadeout_state != NOT_RUNNING_STATE
       && !buffers_16bit_ex)
84200ac0:	59 d8       	rMAC = M[FP + 44];
84200ac2:	09 e8       	rMAC = M[rMAC + Null];
84200ac4:	09 91       	rMAC = MBS[rMAC + 12];
84200ac6:	21 60       	if EQ jump (m) Lc_basic_passthrough_process_data_37;

84200ac8 <Lc_basic_passthrough_process_data_29>:
84200ac8:	61 d8       	rMAC = M[FP + 48];
84200aca:	1f 62       	if NE jump (m) Lc_basic_passthrough_process_data_37;

84200acc <Lc_basic_passthrough_process_data_30>:
    {
        bool fadeout_done = FALSE;
84200acc:	00 09       	r6 = Null + Null;

        /* The number of active channels is now known it's the output of the last
         * loop. So no need to check how many channels to process. Unless i == MAX_CHANS
         * add 1 as the loop was broken out of.
         */
        for (i = 0; i < opx_data->num_active_chans; i++)
84200ace:	06 00       	r4 = Null + Null;
84200ad0:	5f d8       	r5 = M[FP + 44];

84200ad2 <Lc_basic_passthrough_process_data_31>:
84200ad2:	51 d8       	rMAC = M[FP + 40];
84200ad4:	c9 89       	rMAC = M[rMAC + 28];
84200ad6:	70 04       	Null = r4 - rMAC;
84200ad8:	02 f0 9f e0 	if C jump (m) Lc_basic_passthrough_process_data_35;

84200adc <Lc_basic_passthrough_process_data_32>:
        {
            /* the wrapper below takes operator data - this might be lifted out to a common function */
            if(mono_cbuffer_fadeout(channels[i]->ip_buffer, data_to_process,
                                       &(channels[i]->fadeout_parameters)))
84200adc:	39 e8       	rMAC = M[r5 + Null];
84200ade:	0c 22       	r2 = rMAC + 8;
84200ae0:	0a e8       	r0 = M[rMAC + Null];
84200ae2:	53 08       	r1 = r8 + Null;
84200ae4:	ff fd 77 f1 	call (m) 0x2fa0a;
84200ae8:	27 e9 
84200aea:	10 04       	Null = r0 - Null;
84200aec:	02 60       	if EQ jump (m) Lc_basic_passthrough_process_data_34;

84200aee <Lc_basic_passthrough_process_data_33>:
            {
                fadeout_done = TRUE;
84200aee:	08 71       	r6 = Null + 1;

84200af0 <Lc_basic_passthrough_process_data_34>:

        /* The number of active channels is now known it's the output of the last
         * loop. So no need to check how many channels to process. Unless i == MAX_CHANS
         * add 1 as the loop was broken out of.
         */
        for (i = 0; i < opx_data->num_active_chans; i++)
84200af0:	76 20       	r4 = r4 + 1;
84200af2:	3f 21       	r5 = r5 + 4;
84200af4:	ef 6f       	jump (m) Lc_basic_passthrough_process_data_31;

84200af6 <Lc_basic_passthrough_process_data_35>:
            {
                fadeout_done = TRUE;
            }
        }

        if (fadeout_done)
84200af6:	0f f8 00 c2 	Null = r6 - Null;
84200afa:	07 60       	if EQ jump (m) Lc_basic_passthrough_process_data_37;

84200afc <Lc_basic_passthrough_process_data_36>:
        {
            common_send_simple_unsolicited_message(op_data, OPMSG_REPLY_ID_FADEOUT_DONE);
84200afc:	13 f0 00 40 	r1 = Null + 8192;
84200b00:	42 d8       	r0 = M[FP + 32];
84200b02:	ef fd fb ff 	call (m) 0x252;
84200b06:	31 ea 

84200b08 <Lc_basic_passthrough_process_data_37>:
        }
    }
#ifdef INSTALL_OPERATOR_TTP_PASS
    if (op_data->cap_data->id == TTP_PASS_CAP_ID)
84200b08:	41 d8       	rMAC = M[FP + 32];
84200b0a:	49 89       	rMAC = M[rMAC + 20];
84200b0c:	09 e8       	rMAC = M[rMAC + Null];
84200b0e:	01 f0 10 f0 	Null = rMAC - 16487;
84200b12:	67 24 
84200b14:	05 62       	if NE jump (m) Lc_basic_passthrough_process_data_39;

84200b16 <Lc_basic_passthrough_process_data_38>:
    {
        metadata_transport_with_ttp(opx_data, data_to_process);
84200b16:	53 08       	r1 = r8 + Null;
84200b18:	52 d8       	r0 = M[FP + 40];
84200b1a:	57 4e       	call (m) Lc_metadata_transport_with_ttp_1;
84200b1c:	12 6e       	jump (m) Lc_basic_passthrough_process_data_43;

84200b1e <Lc_basic_passthrough_process_data_39>:
#ifdef INSTALL_METADATA
    {
        /* Propagate any metadata to the output. Any handling of its presence or
         * not is handled by the metadata library */
        unsigned data_size = buffers_16bit_ex ? 1 /* octets */
                                                    : buff_metadata_get_usable_octets(opx_data->metadata_ip_buffer);
84200b1e:	61 d8       	rMAC = M[FP + 48];
84200b20:	03 60       	if EQ jump (m) Lc_basic_passthrough_process_data_41;

84200b22 <Lc_basic_passthrough_process_data_40>:
84200b22:	42 20       	r0 = Null + 1;
84200b24:	06 6e       	jump (m) Lc_basic_passthrough_process_data_42;

84200b26 <Lc_basic_passthrough_process_data_41>:
84200b26:	51 d8       	rMAC = M[FP + 40];
84200b28:	8a a8       	r0 = M[rMAC + 72];
84200b2a:	ff fd 88 f0 	call (m) 0x11c9a;
84200b2e:	31 eb 

84200b30 <Lc_basic_passthrough_process_data_42>:

        metadata_strict_transport(opx_data->metadata_ip_buffer, opx_data->metadata_op_buffer,
                                  data_to_process * data_size);
84200b30:	af f2 84 c9 	r2 = r0 * r8 (int);
84200b34:	51 d8       	rMAC = M[FP + 40];
84200b36:	cb a8       	r1 = M[rMAC + 76];
84200b38:	8a a8       	r0 = M[rMAC + 72];
84200b3a:	ff fd 8a f0 	call (m) 0x12076;
84200b3e:	3d e9 

84200b40 <Lc_basic_passthrough_process_data_43>:
    }
#endif  /* INSTALL_METADATA */

    /* Now copy the actual data across channels */
#if defined(INSTALL_CBUFFER_EX)
    if (buffers_16bit_ex)
84200b40:	61 d8       	rMAC = M[FP + 48];
84200b42:	05 60       	if EQ jump (m) Lc_basic_passthrough_process_data_45;

84200b44 <Lc_basic_passthrough_process_data_44>:
    {
        /* call ASM function */
        basic_passthrough_processing_ex(opx_data, data_to_process);
84200b44:	53 08       	r1 = r8 + Null;
84200b46:	52 d8       	r0 = M[FP + 40];
84200b48:	17 4e       	call (m) Lc_basic_passthrough_processing_ex_1;
84200b4a:	05 6e       	jump (m) Lc_basic_passthrough_process_data_46;

84200b4c <Lc_basic_passthrough_process_data_45>:
    }
    else
#endif /* INSTALL_CBUFFER_EX */
    {
        /* call ASM function */
        basic_passthrough_processing(opx_data, data_to_process);
84200b4c:	53 08       	r1 = r8 + Null;
84200b4e:	52 d8       	r0 = M[FP + 40];
84200b50:	0d f0 2b e3 	call (m) $_basic_passthrough_processing;

84200b54 <Lc_basic_passthrough_process_data_46>:
    }
}
84200b54:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200b56:	d8 4c       	rts;

84200b58 <$_ups_params_basic_passthrough>:
    return(TRUE);
}

bool ups_params_basic_passthrough(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                 uint16 length,  unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84200b58:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200b5a:	2b 00       	r1 = r3 + Null;
    /* returns true if succesful, false if failed */
    BASIC_PASSTHROUGH_OP_DATA   *op_extra_data = (BASIC_PASSTHROUGH_OP_DATA*)((OPERATOR_DATA*)instance_data)->extra_op_data;
84200b5c:	16 99       	r4 = M[r0 + 48];

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
84200b5e:	e5 d5       	r3 = MHS[FP + -8];
84200b60:	fc d9       	r2 = M[FP + -4];
84200b62:	62 f0 90 20 	r0 = r4 + 144;
84200b66:	ef fd fd ff 	call (m) 0x712;
84200b6a:	2d ed 

    /* Set the Reinit flag after setting the paramters */
    op_extra_data->ReInitFlag = 1;
84200b6c:	41 20       	rMAC = Null + 1;
84200b6e:	b1 af       	M[r4 + 88] = rMAC;

    return(TRUE);
84200b70:	0a 00       	r0 = rMAC + Null;

84200b72 <Lc_ups_params_basic_passthrough_2>:
}
84200b72:	f1 48       	popm <FP, r4, rLink>;
84200b74:	d8 4c       	rts;

84200b76 <Lc_basic_passthrough_processing_ex_1>:
/* C version of the basic_passthrough_processing loop.
 * We don't need/want to worry about the copy function in this case as
 * the function is only called if we have _ex buffers.
 */
static void basic_passthrough_processing_ex(BASIC_PASSTHROUGH_OP_DATA *op_data, unsigned octets)
{
84200b76:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200b78:	10 09       	r6 = r0 + Null;
84200b7a:	1e 00       	r4 = r1 + Null;
    PASSTHROUGH_CHANNEL **channels = op_data->channel;
84200b7c:	8a f0 24 20 	r8 = r6 + 36;
    unsigned i;

    for (i = 0;i < op_data->num_active_chans;i++)
84200b80:	07 00       	r5 = Null + Null;
84200b82:	06 6e       	jump (m) Lc_basic_passthrough_processing_ex_4;

84200b84 <Lc_basic_passthrough_processing_ex_2>:
            cbuffer_advance_write_ptr_ex(channel->op_buffer, octets);
            cbuffer_advance_read_ptr_ex(channel->ip_buffer, octets);
        }
        else
        {
            cbuffer_copy_16bit_be_zero_shift_ex(channel->op_buffer,channel->ip_buffer,octets);
84200b84:	34 00       	r2 = r4 + Null;
84200b86:	ff fd 16 f1 	call (m) 0x23924;
84200b8a:	3f ec 

84200b8c <Lc_basic_passthrough_processing_ex_3>:
static void basic_passthrough_processing_ex(BASIC_PASSTHROUGH_OP_DATA *op_data, unsigned octets)
{
    PASSTHROUGH_CHANNEL **channels = op_data->channel;
    unsigned i;

    for (i = 0;i < op_data->num_active_chans;i++)
84200b8c:	7f 20       	r5 = r5 + 1;

84200b8e <Lc_basic_passthrough_processing_ex_4>:
84200b8e:	81 f0 07 88 	rMAC = M[r6 + 28];
84200b92:	78 04       	Null = r5 - rMAC;
84200b94:	02 f0 b1 e0 	if C jump (m) Lc_basic_passthrough_processing_ex_7;

84200b98 <Lc_basic_passthrough_processing_ex_5>:
    {
        PASSTHROUGH_CHANNEL *channel = channels[i];
84200b98:	7a 54       	r0 = r5 LSHIFT 2;
84200b9a:	a9 f0 02 e8 	r7 = M[r8 + r0];
        if (channel->op_buffer->base_addr == channel->ip_buffer->base_addr)
84200b9e:	92 f0 01 88 	r0 = M[r7 + 4];
84200ba2:	93 f0 00 e8 	r1 = M[r7 + Null];
84200ba6:	d1 88       	rMAC = M[r0 + 12];
84200ba8:	dc 88       	r2 = M[r1 + 12];
84200baa:	08 05       	Null = rMAC - r2;
84200bac:	ec 63       	if NE jump (m) Lc_basic_passthrough_processing_ex_2;

84200bae <Lc_basic_passthrough_processing_ex_6>:
        {
            /* In place buffer, just advance the pointers */
            cbuffer_advance_write_ptr_ex(channel->op_buffer, octets);
84200bae:	33 00       	r1 = r4 + Null;
84200bb0:	ff fd 75 f1 	call (m) 0x2f6ea;
84200bb4:	3b e9 
            cbuffer_advance_read_ptr_ex(channel->ip_buffer, octets);
84200bb6:	92 f0 00 e8 	r0 = M[r7 + Null];
84200bba:	33 00       	r1 = r4 + Null;
84200bbc:	ff fd 75 f1 	call (m) 0x2f746;
84200bc0:	2b ec 
84200bc2:	e5 6f       	jump (m) Lc_basic_passthrough_processing_ex_3;

84200bc4 <Lc_basic_passthrough_processing_ex_7>:
        else
        {
            cbuffer_copy_16bit_be_zero_shift_ex(channel->op_buffer,channel->ip_buffer,octets);
        }
    }
}
84200bc4:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200bc6:	d8 4c       	rts;

84200bc8 <Lc_metadata_transport_with_ttp_1>:
/* Transport metadata from input to output,
 * either adding time-to-play on existing tags or creating new ones if none are present
 * This inevitably looks very similar to metadata_strict_transport
 */
static void metadata_transport_with_ttp(BASIC_PASSTHROUGH_OP_DATA *opx_data, unsigned samples)
{
84200bc8:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200bca:	11 09       	r7 = r0 + Null;
84200bcc:	1a 09       	r8 = r1 + Null;
    metadata_tag *mtag;
    unsigned b4idx, afteridx;
    if (opx_data->metadata_ip_buffer != NULL)
84200bce:	92 f0 12 88 	r0 = M[r7 + 72];
84200bd2:	14 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_5;

84200bd4 <Lc_metadata_transport_with_ttp_2>:
    {
        /* transport metadata, first (attempt to) consume tag associated with src */
        mtag = buff_metadata_remove(opx_data->metadata_ip_buffer, samples * OCTETS_PER_SAMPLE, &b4idx, &afteridx);
84200bd4:	05 12       	r3 = FP + 32;
84200bd6:	c4 11       	r2 = FP + 28;
84200bd8:	01 fa d3 c8 	r1 = r8 LSHIFT 2;
84200bdc:	ff fd 88 f0 	call (m) 0x11d7a;
84200be0:	3f ec 
84200be2:	10 09       	r6 = r0 + Null;
        {
            mtag->length = samples * OCTETS_PER_SAMPLE;
        }
    }

    if (mtag != NULL)
84200be4:	18 62       	if NE jump (m) Lc_metadata_transport_with_ttp_7;

84200be6 <Lc_metadata_transport_with_ttp_3>:
            list_tag = list_tag->next;
        }

    }

    if (opx_data->metadata_op_buffer != NULL)
84200be6:	92 f0 13 88 	r0 = M[r7 + 76];
84200bea:	53 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_13;

84200bec <Lc_metadata_transport_with_ttp_4>:
    {
        buff_metadata_append(opx_data->metadata_op_buffer, mtag, b4idx, afteridx);
84200bec:	45 d8       	r3 = M[FP + 32];
84200bee:	3c d8       	r2 = M[FP + 28];
84200bf0:	43 08       	r1 = r6 + Null;
84200bf2:	ff fd 87 f0 	call (m) 0x11adc;
84200bf6:	2b e7 
84200bf8:	50 6e       	jump (m) Lc_metadata_transport_with_ttp_14;

84200bfa <Lc_metadata_transport_with_ttp_5>:
        mtag = buff_metadata_remove(opx_data->metadata_ip_buffer, samples * OCTETS_PER_SAMPLE, &b4idx, &afteridx);
    }
    else
    {
        /* Create a new tag for the output */
        b4idx = 0;
84200bfa:	38 de       	M[FP + 28] = Null;
        afteridx = samples * OCTETS_PER_SAMPLE;
84200bfc:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84200c00:	42 de       	M[FP + 32] = r0;
        mtag = buff_metadata_new_tag();
84200c02:	ff fd 86 f0 	call (m) 0x11862;
84200c06:	21 e3 
84200c08:	10 09       	r6 = r0 + Null;
        if (mtag != NULL)
84200c0a:	ee 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_3;

84200c0c <Lc_metadata_transport_with_ttp_6>:
        {
            mtag->length = samples * OCTETS_PER_SAMPLE;
84200c0c:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84200c10:	82 f0 03 8e 	M[r6 + 12] = r0;

84200c14 <Lc_metadata_transport_with_ttp_7>:
    }

    if (mtag != NULL)
    {
        ttp_status status;
        metadata_tag *list_tag = mtag->next;
84200c14:	86 f0 00 e8 	r4 = M[r6 + Null];
        unsigned list_octets = mtag->length;
84200c18:	87 f0 03 88 	r5 = M[r6 + 12];
        TIME ttp_reference_time;
        if (IS_TIME_OF_ARRIVAL_TAG(mtag))
84200c1c:	81 f0 01 88 	rMAC = M[r6 + 4];
84200c20:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200c24:	10 f0 40 24 	Null = rMAC - 64;
84200c28:	04 62       	if NE jump (m) Lc_metadata_transport_with_ttp_9;

84200c2a <Lc_metadata_transport_with_ttp_8>:
        {
            /* We have incoming ToA, so use that as the TTP reference */
            ttp_reference_time = mtag->timestamp;
84200c2a:	83 f0 04 88 	r1 = M[r6 + 16];
84200c2e:	05 6e       	jump (m) Lc_metadata_transport_with_ttp_10;

84200c30 <Lc_metadata_transport_with_ttp_9>:
        }
        else
        {
            /* No ToA, so just use the current time */
            ttp_reference_time = hal_get_time();
84200c30:	ff fd 85 f1 	call (m) 0x317e8;
84200c34:	39 ed 
84200c36:	13 00       	r1 = r0 + Null;

84200c38 <Lc_metadata_transport_with_ttp_10>:
        }

        ttp_update_ttp(opx_data->time_to_play, ttp_reference_time, samples, &status);
84200c38:	45 12       	r3 = FP + 36;
84200c3a:	92 f0 04 88 	r0 = M[r7 + 16];
84200c3e:	54 08       	r2 = r8 + Null;
84200c40:	ff fd ae f0 	call (m) 0x16860;
84200c44:	21 e1 
        /* Populate the metadata tag from the TTP status */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
84200c46:	81 f0 01 88 	rMAC = M[r6 + 4];
84200c4a:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84200c4e:	81 f0 01 8e 	M[r6 + 4] = rMAC;
        ttp_utils_populate_tag(mtag, &status);
84200c52:	43 12       	r1 = FP + 36;
84200c54:	42 08       	r0 = r6 + Null;
84200c56:	ef fd fe ff 	call (m) 0x8d0;
84200c5a:	3b e3 
        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84200c5c:	60 de       	M[FP + 48] = Null;

84200c5e <Lc_metadata_transport_with_ttp_11>:

        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        while (list_tag != NULL)
84200c5e:	30 04       	Null = r4 - Null;
84200c60:	c3 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_3;

84200c62 <Lc_metadata_transport_with_ttp_12>:
        {
            status.ttp = ttp_get_next_timestamp(mtag->timestamp, list_octets / OCTETS_PER_SAMPLE, opx_data->sample_rate, status.sp_adjustment);
84200c62:	55 d8       	r3 = M[FP + 40];
84200c64:	94 f0 06 88 	r2 = M[r7 + 24];
84200c68:	7b 50       	r1 = r5 LSHIFT -2;
84200c6a:	82 f0 04 88 	r0 = M[r6 + 16];
84200c6e:	ff fd af f0 	call (m) 0x16aa2;
84200c72:	35 e1 
84200c74:	4a de       	M[FP + 36] = r0;
            METADATA_TIME_OF_ARRIVAL_UNSET(list_tag);
84200c76:	71 88       	rMAC = M[r4 + 4];
84200c78:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84200c7c:	71 8e       	M[r4 + 4] = rMAC;
            ttp_utils_populate_tag(list_tag, &status);
84200c7e:	43 12       	r1 = FP + 36;
84200c80:	32 00       	r0 = r4 + Null;
84200c82:	ef fd fe ff 	call (m) 0x8d0;
84200c86:	2f e2 
            list_octets += list_tag->length;
84200c88:	f1 88       	rMAC = M[r4 + 12];
84200c8a:	cf 01       	r5 = rMAC + r5;
            list_tag = list_tag->next;
84200c8c:	36 e8       	r4 = M[r4 + Null];
        status.stream_restart = FALSE;

        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        while (list_tag != NULL)
84200c8e:	e8 6f       	jump (m) Lc_metadata_transport_with_ttp_11;

84200c90 <Lc_metadata_transport_with_ttp_13>:
    {
        buff_metadata_append(opx_data->metadata_op_buffer, mtag, b4idx, afteridx);
    }
    else
    {
        buff_metadata_tag_list_delete(mtag);
84200c90:	42 08       	r0 = r6 + Null;
84200c92:	ff fd 86 f0 	call (m) 0x11906;
84200c96:	35 e3 

84200c98 <Lc_metadata_transport_with_ttp_14>:
    }

}
84200c98:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200c9a:	d8 4c       	rts;

84200c9c <Lc_set_fadeout_state_1>:
    return(TRUE);
}
/* **************************** Operator message handlers ******************************** */

static bool set_fadeout_state(OPERATOR_DATA *op_data, FADEOUT_STATE state)
{
84200c9c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200c9e:	1e 00       	r4 = r1 + Null;
    unsigned i;
    BASIC_PASSTHROUGH_OP_DATA *opx_data = (BASIC_PASSTHROUGH_OP_DATA *)(op_data->extra_op_data);
84200ca0:	11 99       	rMAC = M[r0 + 48];

    /* Fadeout is only possible when the input data format is audio */
    if (AUDIO_DATA_FORMAT_FIXP != opx_data->ip_format)
84200ca2:	4a 88       	r0 = M[rMAC + 4];
84200ca4:	50 24       	Null = r0 - 1;
84200ca6:	03 60       	if EQ jump (m) Lc_set_fadeout_state_3;

84200ca8 <Lc_set_fadeout_state_2>:
    {
        return FALSE;
84200ca8:	02 00       	r0 = Null + Null;
84200caa:	11 6e       	jump (m) Lc_set_fadeout_state_7;

84200cac <Lc_set_fadeout_state_3>:
    }

    for (i = 0; i < MAX_CHANS; i++)
84200cac:	07 00       	r5 = Null + Null;
84200cae:	18 f0 24 20 	r6 = rMAC + 36;

84200cb2 <Lc_set_fadeout_state_4>:
    {
        /* There are no more active channels if an empty channel entry is reached */
        if (!opx_data->channel[i])
84200cb2:	81 f0 00 e8 	rMAC = M[r6 + Null];
84200cb6:	0a 60       	if EQ jump (m) Lc_set_fadeout_state_6;

84200cb8 <Lc_set_fadeout_state_5>:
        {
            break;
        }
        /* if input terminal has audio data type, extra op data is allocated and
         * fadeout is not already enabled/running */
        common_set_fadeout_state(&opx_data->channel[i]->fadeout_parameters, state);
84200cb8:	0a 22       	r0 = rMAC + 8;
84200cba:	33 00       	r1 = r4 + Null;
84200cbc:	ef fd fa ff 	call (m) 0x22c;
84200cc0:	31 eb 
    if (AUDIO_DATA_FORMAT_FIXP != opx_data->ip_format)
    {
        return FALSE;
    }

    for (i = 0; i < MAX_CHANS; i++)
84200cc2:	7f 20       	r5 = r5 + 1;
84200cc4:	20 75       	r6 = r6 + 4;
84200cc6:	38 26       	Null = r5 - 8;
84200cc8:	f5 65       	if NC jump (m) Lc_set_fadeout_state_4;

84200cca <Lc_set_fadeout_state_6>:
        }
        /* if input terminal has audio data type, extra op data is allocated and
         * fadeout is not already enabled/running */
        common_set_fadeout_state(&opx_data->channel[i]->fadeout_parameters, state);
    }
    return TRUE;
84200cca:	42 20       	r0 = Null + 1;

84200ccc <Lc_set_fadeout_state_7>:
}
84200ccc:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200cce:	d8 4c       	rts;

84200cd0 <Lc_common_change_terminal_data_type_1>:
 * \param  resp_data  Pointer to a pointer to response message structure, allocated in this function.
 */
static bool common_change_terminal_data_type(OPERATOR_DATA *op_data, bool is_input, void *message_data)
{
    /* success/failure outcome will be signalled to caller via return value */
    if(op_data->state != OP_NOT_RUNNING)
84200cd0:	11 b0       	rMAC = MBS[r0 + 24];
84200cd2:	48 24       	Null = rMAC - 1;
84200cd4:	03 60       	if EQ jump (m) Lc_common_change_terminal_data_type_3;

84200cd6 <Lc_common_change_terminal_data_type_2>:
    {
        /* Let opmsg handler pick up the pieces - it will construct a "command failed" response.
         * No extra info is given from this level.
         */
        return FALSE;
84200cd6:	02 00       	r0 = Null + Null;
84200cd8:	0b 6e       	jump (m) Lc_common_change_terminal_data_type_7;

84200cda <Lc_common_change_terminal_data_type_3>:
    }

    if(is_input)
84200cda:	18 04       	Null = r1 - Null;
84200cdc:	05 60       	if EQ jump (m) Lc_common_change_terminal_data_type_5;

84200cde <Lc_common_change_terminal_data_type_4>:
    {
        /* 4th field in message is the data format */
        ((BASIC_PASSTHROUGH_OP_DATA*)(op_data->extra_op_data))->ip_format = ((unsigned*)message_data)[3];
84200cde:	e1 88       	rMAC = M[r2 + 12];
84200ce0:	12 99       	r0 = M[r0 + 48];
84200ce2:	51 8e       	M[r0 + 4] = rMAC;
84200ce4:	04 6e       	jump (m) Lc_common_change_terminal_data_type_6;

84200ce6 <Lc_common_change_terminal_data_type_5>:
    }
    else
    {
        ((BASIC_PASSTHROUGH_OP_DATA*)(op_data->extra_op_data))->op_format = ((unsigned*)message_data)[3];
84200ce6:	e1 88       	rMAC = M[r2 + 12];
84200ce8:	12 99       	r0 = M[r0 + 48];
84200cea:	91 8e       	M[r0 + 8] = rMAC;

84200cec <Lc_common_change_terminal_data_type_6>:
    }

    /* here we don't validate data type - other ops may well do */
    return TRUE;
84200cec:	42 20       	r0 = Null + 1;

84200cee <Lc_common_change_terminal_data_type_7>:
84200cee:	d8 4c       	rts;

84200cf0 <$_BASIC_PASSTHROUGH_GetDefaults>:
   0x00002080u,			// CONFIG
   0x00000000u			// GAIN
};

unsigned *BASIC_PASSTHROUGH_GetDefaults(unsigned capid){
	switch(capid){
84200cf0:	50 24       	Null = r0 - 1;
84200cf2:	0b 60       	if EQ jump (m) Lc_BASIC_PASSTHROUGH_GetDefaults_5;

84200cf4 <Lc_BASIC_PASSTHROUGH_GetDefaults_2>:
84200cf4:	10 3f       	Null = r0 - 60;
84200cf6:	09 60       	if EQ jump (m) Lc_BASIC_PASSTHROUGH_GetDefaults_5;

84200cf8 <Lc_BASIC_PASSTHROUGH_GetDefaults_3>:
84200cf8:	01 f0 20 f0 	Null = r0 - 16386;
84200cfc:	02 24 
84200cfe:	05 60       	if EQ jump (m) Lc_BASIC_PASSTHROUGH_GetDefaults_5;

84200d00 <Lc_BASIC_PASSTHROUGH_GetDefaults_4>:
84200d00:	01 f0 20 f0 	Null = r0 - 16487;
84200d04:	67 24 
84200d06:	05 62       	if NE jump (m) Lc_BASIC_PASSTHROUGH_GetDefaults_6;

84200d08 <Lc_BASIC_PASSTHROUGH_GetDefaults_5>:
		case 0x0001: return defaults_basic_passthroughTTP;
84200d08:	f8 ff 02 f0 	r0 = Null + -8388492;
84200d0c:	74 40 
84200d0e:	02 6e       	jump (m) Lc_BASIC_PASSTHROUGH_GetDefaults_7;

84200d10 <Lc_BASIC_PASSTHROUGH_GetDefaults_6>:
		case 0x4002: return defaults_basic_passthroughTTP;
		case 0x003C: return defaults_basic_passthroughTTP;
		case 0x4067: return defaults_basic_passthroughTTP;
	}
	return((unsigned *)0);
84200d10:	02 00       	r0 = Null + Null;

84200d12 <Lc_BASIC_PASSTHROUGH_GetDefaults_7>:
84200d12:	d8 4c       	rts;

84200d14 <Lc_download_self_test_create_1>:
};

/* ********************************** API functions ************************************* */

static bool download_self_test_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200d14:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200d16:	12 09       	r8 = r0 + Null;
84200d18:	43 de       	M[FP + 32] = r1;
84200d1a:	4c de       	M[FP + 36] = r2;
84200d1c:	2b 09       	r9 = r3 + Null;

        L0_DBG_MSG( "debug log test: Test log level. Log 4 should be missing\n");
        L4_DBG_MSG1("debug log test: %d \n", 1);

        L0_DBG_MSG( "debug log test: Test string prints! \n");
        L0_DBG_MSG1("debug log test: %d \n", string1);
84200d1e:	55 f1 06 f0 	r4 = Null + 357564455;
84200d22:	27 40 
        L0_DBG_MSG2("debug log test: %s %d \n", string1, 1);
        L0_DBG_MSG2("debug log test: %s %s \n", string1, string2);
84200d24:	55 f1 09 f0 	r7 = Null + 357564791;
84200d28:	77 41 
84200d2a:	55 f1 08 f0 	r6 = Null + 357564461;
84200d2e:	2d 40 
/* ********************************** API functions ************************************* */

static bool download_self_test_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    DOWNLOAD_SELF_TEST_OP_DATA *self_test_data;
    int i=0;
84200d30:	07 00       	r5 = Null + Null;

84200d32 <Lc_download_self_test_create_2>:
    AUDIO_LOG_STRING(string2, "Hello there");

    /* Test debug logging*/
    while(i<10000)
    {
        L0_DBG_MSG( "debug log test: Test normal logging. \n");
84200d32:	55 f1 02 f0 	r0 = Null + 357564473;
84200d36:	39 40 
84200d38:	ef fd fe ff 	call (m) 0x9a2;
84200d3c:	2b e3 
        L0_DBG_MSG1("debug log test: i = %d \n", i);
84200d3e:	55 f1 02 f0 	r0 = Null + 357564512;
84200d42:	60 40 
84200d44:	3b 00       	r1 = r5 + Null;
84200d46:	ef fd fe ff 	call (m) 0x9b4;
84200d4a:	2f e3 
        L0_DBG_MSG2("debug log test: %d %d \n", 1, 2);
84200d4c:	84 20       	r2 = Null + 2;
84200d4e:	43 20       	r1 = Null + 1;
84200d50:	55 f1 02 f0 	r0 = Null + 357564537;
84200d54:	79 40 
84200d56:	ef fd fe ff 	call (m) 0x9c8;
84200d5a:	33 e3 
        L0_DBG_MSG3("debug log test: %d %d %d \n", 1, 2, 3);
84200d5c:	c5 20       	r3 = Null + 3;
84200d5e:	84 20       	r2 = Null + 2;
84200d60:	43 20       	r1 = Null + 1;
84200d62:	55 f1 02 f0 	r0 = Null + 357564561;
84200d66:	91 40 
84200d68:	ef fd fe ff 	call (m) 0x9de;
84200d6c:	37 e3 
        L0_DBG_MSG4("debug log test: %d %d %d %d \n", 1, 2, 3, 4);
84200d6e:	00 f0 54 e0 	push Null + 4;
84200d72:	c5 20       	r3 = Null + 3;
84200d74:	84 20       	r2 = Null + 2;
84200d76:	43 20       	r1 = Null + 1;
84200d78:	55 f1 02 f0 	r0 = Null + 357564588;
84200d7c:	ac 40 
84200d7e:	ef fd fe ff 	call (m) 0x9f6;
84200d82:	39 e3 
84200d84:	7f 4c       	SP = SP + -4;
        L0_DBG_MSG5("debug log test: %d %d %d %d %d \n", 1, 2, 3, 4, 5);
84200d86:	00 f0 55 e0 	push Null + 5;
84200d8a:	c5 20       	r3 = Null + 3;
84200d8c:	84 20       	r2 = Null + 2;
84200d8e:	43 20       	r1 = Null + 1;
84200d90:	00 f0 54 e0 	push Null + 4;
84200d94:	55 f1 02 f0 	r0 = Null + 357564618;
84200d98:	ca 40 
84200d9a:	ef fd fe ff 	call (m) 0xa12;
84200d9e:	39 e3 
84200da0:	7e 4c       	SP = SP + -8;

        L0_DBG_MSG( "debug log test: Test log level. Log 4 should be missing\n");
84200da2:	55 f1 02 f0 	r0 = Null + 357564651;
84200da6:	eb 40 
84200da8:	ef fd fd ff 	call (m) 0x9a2;
84200dac:	3b ef 
        L4_DBG_MSG1("debug log test: %d \n", 1);
84200dae:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200db2:	08 25       	Null = rMAC - 4;
84200db4:	08 68       	if LT jump (m) Lc_download_self_test_create_4;

84200db6 <Lc_download_self_test_create_3>:
84200db6:	43 20       	r1 = Null + 1;
84200db8:	55 f1 02 f0 	r0 = Null + 357564708;
84200dbc:	24 41 
84200dbe:	ef fd fd ff 	call (m) 0x9b4;
84200dc2:	37 ef 

84200dc4 <Lc_download_self_test_create_4>:

        L0_DBG_MSG( "debug log test: Test string prints! \n");
84200dc4:	55 f1 02 f0 	r0 = Null + 357564729;
84200dc8:	39 41 
84200dca:	ef fd fd ff 	call (m) 0x9a2;
84200dce:	39 ee 
        L0_DBG_MSG1("debug log test: %d \n", string1);
84200dd0:	55 f1 02 f0 	r0 = Null + 357564708;
84200dd4:	24 41 
84200dd6:	33 00       	r1 = r4 + Null;
84200dd8:	ef fd fd ff 	call (m) 0x9b4;
84200ddc:	3d ee 
        L0_DBG_MSG2("debug log test: %s %d \n", string1, 1);
84200dde:	44 20       	r2 = Null + 1;
84200de0:	55 f1 02 f0 	r0 = Null + 357564767;
84200de4:	5f 41 
84200de6:	33 00       	r1 = r4 + Null;
84200de8:	ef fd fd ff 	call (m) 0x9c8;
84200dec:	21 ef 
        L0_DBG_MSG2("debug log test: %s %s \n", string1, string2);
84200dee:	44 08       	r2 = r6 + Null;
84200df0:	33 00       	r1 = r4 + Null;
84200df2:	4a 08       	r0 = r7 + Null;
84200df4:	ef fd fd ff 	call (m) 0x9c8;
84200df8:	35 ee 
        L0_DBG_MSG4("debug log test: %s %s \n", 0, string1, string2, 1);
84200dfa:	00 f0 51 e0 	push Null + 1;
84200dfe:	03 00       	r1 = Null + Null;
84200e00:	45 08       	r3 = r6 + Null;
84200e02:	34 00       	r2 = r4 + Null;
84200e04:	4a 08       	r0 = r7 + Null;
84200e06:	ef fd fd ff 	call (m) 0x9f6;
84200e0a:	31 ef 
84200e0c:	7f 4c       	SP = SP + -4;

        L0_DBG_MSG( "debug log test: From here comes some errors! \n");
84200e0e:	55 f1 02 f0 	r0 = Null + 357564815;
84200e12:	8f 41 
84200e14:	ef fd fd ff 	call (m) 0x9a2;
84200e18:	2f ec 
        L0_DBG_MSG4("debug log test: %d %d \n", 1, 2, 3, 4);
84200e1a:	00 f0 54 e0 	push Null + 4;
84200e1e:	c5 20       	r3 = Null + 3;
84200e20:	84 20       	r2 = Null + 2;
84200e22:	43 20       	r1 = Null + 1;
84200e24:	55 f1 02 f0 	r0 = Null + 357564537;
84200e28:	79 40 
84200e2a:	ef fd fd ff 	call (m) 0x9f6;
84200e2e:	2d ee 
84200e30:	7f 4c       	SP = SP + -4;
        L0_DBG_MSG3("debug log test: %d %d %d %d %d \n", 1, 2, 3);
84200e32:	c5 20       	r3 = Null + 3;
84200e34:	84 20       	r2 = Null + 2;
84200e36:	43 20       	r1 = Null + 1;
84200e38:	55 f1 02 f0 	r0 = Null + 357564618;
84200e3c:	ca 40 
84200e3e:	ef fd fd ff 	call (m) 0x9de;
84200e42:	21 ed 
        L0_DBG_MSG( "debug log test: End of the errors! \n");
84200e44:	55 f1 02 f0 	r0 = Null + 357564862;
84200e48:	be 41 
84200e4a:	ef fd fd ff 	call (m) 0x9a2;
84200e4e:	39 ea 
        
        i++;
84200e50:	7f 20       	r5 = r5 + 1;
    int i=0;
    AUDIO_LOG_STRING(string1, "Hello");
    AUDIO_LOG_STRING(string2, "Hello there");

    /* Test debug logging*/
    while(i<10000)
84200e52:	00 f0 70 f2 	Null = r5 - 10000;
84200e56:	10 2f 
84200e58:	6d 69       	if LT jump (m) Lc_download_self_test_create_2;

84200e5a <Lc_download_self_test_create_5>:
        
        i++;
    }

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200e5a:	5d 08       	r3 = r9 + Null;
84200e5c:	52 08       	r0 = r8 + Null;
84200e5e:	4c d8       	r2 = M[FP + 36];
84200e60:	43 d8       	r1 = M[FP + 32];
84200e62:	ef fd f9 ff 	call (m) 0x8c;
84200e66:	2b e1 
84200e68:	10 04       	Null = r0 - Null;
84200e6a:	03 62       	if NE jump (m) Lc_download_self_test_create_7;

84200e6c <Lc_download_self_test_create_6>:
    {
        return FALSE;
84200e6c:	02 00       	r0 = Null + Null;
84200e6e:	06 6e       	jump (m) Lc_download_self_test_create_8;

84200e70 <Lc_download_self_test_create_7>:
    }
    self_test_data = (DOWNLOAD_SELF_TEST_OP_DATA *)op_data->extra_op_data;
84200e70:	a1 f0 0c 88 	rMAC = M[r8 + 48];
    self_test_data->ip_format = AUDIO_DATA_FORMAT_FIXP;
84200e74:	42 20       	r0 = Null + 1;
84200e76:	8a 8e       	M[rMAC + 8] = r0;
    self_test_data->op_format = AUDIO_DATA_FORMAT_FIXP;
84200e78:	ca 8e       	M[rMAC + 12] = r0;

84200e7a <Lc_download_self_test_create_8>:
    return TRUE;
84200e7a:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200e7c:	d8 4c       	rts;

84200e7e <Lc_download_self_test_opmsg_start_self_test_1>:

/* Duplicated in download_self_test_util.c */
static unsigned int my_static_array[] = {0, 1, 2};

static bool download_self_test_opmsg_start_self_test(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200e7e:	f3 1e       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x20;
84200e80:	26 00       	r4 = r2 + Null;
84200e82:	2f 00       	r5 = r3 + Null;
    unsigned int test_result = 0xBAD;
    /* Compiler will convert func_ptr into an anonymous symbol L_lcx, and pull in C-runtime __CRT_wcpy function
     * Build system must deal with this
     * */
    unsigned int (*func_ptr[])(void) = {&download_self_test_branch_test, &download_self_test_var_ref_test_minim, &download_self_test_var_ref_test_maxim};
84200e84:	07 f0 03 f0 	r1 = Null + 7340396;
84200e88:	6c 41 
84200e8a:	42 11       	r0 = FP + 20;
84200e8c:	c4 20       	r2 = Null + 3;
84200e8e:	ff fd b1 f0 	call (m) 0x17116;
84200e92:	29 e4 
    unsigned int* my_local_array[] = {&my_static_array[0], &my_static_array[1], &my_static_array[2]};
84200e94:	07 f0 03 f0 	r1 = Null + 7340408;
84200e98:	78 41 
84200e9a:	02 12       	r0 = FP + 32;
84200e9c:	c4 20       	r2 = Null + 3;
84200e9e:	ff fd b1 f0 	call (m) 0x17116;
84200ea2:	39 e3 
    unsigned int i;
    L4_DBG_MSG("download_self_test_opmsg_start_self_test  \n");
84200ea4:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200ea8:	08 25       	Null = rMAC - 4;
84200eaa:	07 68       	if LT jump (m) Lc_download_self_test_opmsg_start_self_test_3;

84200eac <Lc_download_self_test_opmsg_start_self_test_2>:
84200eac:	55 f1 02 f0 	r0 = Null + 357564899;
84200eb0:	e3 41 
84200eb2:	ef fd fd ff 	call (m) 0x9a2;
84200eb6:	31 e7 

84200eb8 <Lc_download_self_test_opmsg_start_self_test_3>:
    set_a(1);
84200eb8:	42 20       	r0 = Null + 1;
84200eba:	02 f0 21 e1 	call (m) $_set_a;
    /* Set up the a default success response information */
    /* length is 1 word, msgID */
    *resp_length = OPMSG_RSP_PAYLOAD_SIZE_RAW_DATA(0);
84200ebe:	41 20       	rMAC = Null + 1;
84200ec0:	31 ee       	M[r4 + Null] = rMAC;
	*resp_data = (OP_OPMSG_RSP_PAYLOAD *)xpnewn(*resp_length, unsigned);
84200ec2:	c3 20       	r1 = Null + 3;
84200ec4:	02 21       	r0 = Null + 4;
84200ec6:	ff fd 1f f0 	call (m) 0x4e2e;
84200eca:	29 eb 
    if (*resp_data == NULL)
84200ecc:	3a ee       	M[r5 + Null] = r0;
84200ece:	03 62       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_5;

84200ed0 <Lc_download_self_test_opmsg_start_self_test_4>:
    {
        return FALSE;
84200ed0:	02 00       	r0 = Null + Null;
84200ed2:	67 6e       	jump (m) Lc_download_self_test_opmsg_start_self_test_24;

84200ed4 <Lc_download_self_test_opmsg_start_self_test_5>:
    }
    /* Check calls between Minim/Maxim code sections */
    test_result = download_self_test_call_from_maxim_to_minim_test_maxim();
84200ed4:	f8 ff 3c ec 	call $_download_self_test_call_from_maxim_to_minim_test_maxim;
    if (test_result != 0x600D)
84200ed8:	01 f0 20 f2 	Null = r0 - 24589;
84200edc:	0d 24 
84200ede:	f9 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200ee0 <Lc_download_self_test_opmsg_start_self_test_6>:
    {
        return FALSE;
    }
    /* Check multiple variable sizes referencing */
    test_result = download_self_test_variable_size_vars_test_maxim_asm();
84200ee0:	f9 ff 3c e0 	call $_download_self_test_variable_size_vars_test_maxim_asm;
    if (test_result != 0x600D)
84200ee4:	01 f0 20 f2 	Null = r0 - 24589;
84200ee8:	0d 24 
84200eea:	f3 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200eec <Lc_download_self_test_opmsg_start_self_test_7>:
    {
        return FALSE;
    }
    test_result = download_self_test_variable_size_vars_test_minim_asm();
84200eec:	0c f0 2b e4 	call (m) $_download_self_test_variable_size_vars_test_minim_asm;
    if (test_result != 0x600D)
84200ef0:	01 f0 20 f2 	Null = r0 - 24589;
84200ef4:	0d 24 
84200ef6:	ed 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200ef8 <Lc_download_self_test_opmsg_start_self_test_8>:
    {
        return FALSE;
    }
    test_result = download_self_test_variable_size_vars_test_c();
84200ef8:	57 4e       	call (m) Lc_download_self_test_variable_size_vars_test_c_1;
    if (test_result != 0x600D)
84200efa:	01 f0 20 f2 	Null = r0 - 24589;
84200efe:	0d 24 
84200f00:	e8 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f02 <Lc_download_self_test_opmsg_start_self_test_9>:
    {
        return FALSE;
    }
    test_result = download_self_test_symbol_not_found_in_varLut();
84200f02:	a1 4e       	call (m) Lc_download_self_test_symbol_not_found_in_varLut_1;
    if (test_result != 0x600D)
84200f04:	01 f0 20 f2 	Null = r0 - 24589;
84200f08:	0d 24 
84200f0a:	e3 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f0c <Lc_download_self_test_opmsg_start_self_test_10>:
    {
        return FALSE;
    }
    test_result = download_self_test_array_offset_access();
84200f0c:	01 f0 3b eb 	call (m) $_download_self_test_array_offset_access;
    if (test_result != 0x600D)
84200f10:	01 f0 20 f2 	Null = r0 - 24589;
84200f14:	0d 24 
84200f16:	dd 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f18 <Lc_download_self_test_opmsg_start_self_test_11>:
    {
        return FALSE;
    }
    test_result = download_self_test_array_offset_access_check();
84200f18:	01 f0 21 e9 	call (m) $_download_self_test_array_offset_access_check;
    if (test_result != 0x600D)
84200f1c:	01 f0 20 f2 	Null = r0 - 24589;
84200f20:	0d 24 
84200f22:	d7 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f24 <Lc_download_self_test_opmsg_start_self_test_12>:
    {
        return FALSE;
    }
    test_result = download_self_test_AddSub_B_instruction(0, -1);
84200f24:	43 24       	r1 = Null - 1;
84200f26:	02 00       	r0 = Null + Null;
84200f28:	01 f0 3b ec 	call (m) $_download_self_test_AddSub_B_instruction;
    if (test_result != 0x600D)
84200f2c:	01 f0 20 f2 	Null = r0 - 24589;
84200f30:	0d 24 
84200f32:	cf 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f34 <Lc_download_self_test_opmsg_start_self_test_13>:
    {
        return FALSE;
    }
    test_result = download_self_test_call_from_maxim_to_insert32_instr_test_maxim();
84200f34:	f8 ff 20 ed 	call $_download_self_test_call_from_maxim_to_insert32_instr_test_maxim;
    if (test_result != 0x600D)
84200f38:	01 f0 20 f2 	Null = r0 - 24589;
84200f3c:	0d 24 
84200f3e:	c9 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f40 <Lc_download_self_test_opmsg_start_self_test_14>:
    {
        return FALSE;
    }
    test_result = download_self_test_call_from_minim_to_insert32_instr_test_minim();
84200f40:	0c f0 3b e0 	call (m) $_download_self_test_call_from_minim_to_insert32_instr_test_minim;
    if (test_result != 0x600D)
84200f44:	01 f0 20 f2 	Null = r0 - 24589;
84200f48:	0d 24 
84200f4a:	c3 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f4c <Lc_download_self_test_opmsg_start_self_test_15>:
    {
        return FALSE;
    }
    test_result = download_self_test_variables_arrangement();
84200f4c:	7f 4e       	call (m) Lc_download_self_test_variables_arrangement_1;
    if (test_result != 0x600D)
84200f4e:	01 f0 20 f2 	Null = r0 - 24589;
84200f52:	0d 24 
84200f54:	be 63       	if NE jump (m) Lc_download_self_test_opmsg_start_self_test_4;

84200f56 <Lc_download_self_test_opmsg_start_self_test_16>:
    {
        return FALSE;
    }
    /* Call assembly functions and change the already allocated response to the result of the test */
    for (i = 0; i < ARRAY_SIZE(func_ptr); i++)
84200f56:	06 00       	r4 = Null + Null;
84200f58:	e8 f0 14 20 	r6 = FP + 20;

84200f5c <Lc_download_self_test_opmsg_start_self_test_17>:
    {
        test_result = func_ptr[i]();
84200f5c:	81 f0 00 e8 	rMAC = M[r6 + Null];
84200f60:	d1 4c       	call rMAC;
        if (test_result != 0x600D)
84200f62:	01 f0 20 f2 	Null = r0 - 24589;
84200f66:	0d 24 
84200f68:	04 60       	if EQ jump (m) Lc_download_self_test_opmsg_start_self_test_19;

84200f6a <Lc_download_self_test_opmsg_start_self_test_18>:
        {
            /* Return BAD (0xBAD) */
            (*resp_data)->msg_id = test_result;
84200f6a:	39 e8       	rMAC = M[r5 + Null];
84200f6c:	0a ee       	M[rMAC + Null] = r0;
84200f6e:	18 6e       	jump (m) Lc_download_self_test_opmsg_start_self_test_23;

84200f70 <Lc_download_self_test_opmsg_start_self_test_19>:
    if (test_result != 0x600D)
    {
        return FALSE;
    }
    /* Call assembly functions and change the already allocated response to the result of the test */
    for (i = 0; i < ARRAY_SIZE(func_ptr); i++)
84200f70:	76 20       	r4 = r4 + 1;
84200f72:	20 75       	r6 = r6 + 4;
84200f74:	f0 24       	Null = r4 - 3;
84200f76:	f3 65       	if NC jump (m) Lc_download_self_test_opmsg_start_self_test_17;

84200f78 <Lc_download_self_test_opmsg_start_self_test_20>:
84200f78:	07 f0 01 f0 	rMAC = Null + 7340716;
84200f7c:	ac 42 
84200f7e:	02 12       	r0 = FP + 32;
            (*resp_data)->msg_id = test_result;
            return TRUE;
        }
    }
    /* This loop forces the creation of anonymous initialisation tables L_lcx */
    for (i = 0; i < ARRAY_SIZE(my_static_array); i++)
84200f80:	1c 71       	r10 = Null + 3;
84200f82:	06 4c       	do (m) Lc__loop0;

84200f84 <Lc_download_self_test_opmsg_start_self_test_21>:
    {
        my_static_array[i] = *my_local_array[i];
84200f84:	13 e8       	r1 = M[r0 + Null];
84200f86:	1b e8       	r1 = M[r1 + Null];
84200f88:	12 21       	r0 = r0 + 4;
84200f8a:	0b ee       	M[rMAC + Null] = r1;
84200f8c:	09 21       	rMAC = rMAC + 4;

84200f8e <Lc__loop0>:
            (*resp_data)->msg_id = test_result;
            return TRUE;
        }
    }
    /* This loop forces the creation of anonymous initialisation tables L_lcx */
    for (i = 0; i < ARRAY_SIZE(my_static_array); i++)
84200f8e:	07 f0 06 f0 	r4 = Null + 7340716;
84200f92:	ac 42 
    {
        my_static_array[i] = *my_local_array[i];
    }
    /* Force linking of another C module for this capability */
    my_static_array[0] = download_self_test_util_helper();
84200f94:	d8 4e       	call (m) $_download_self_test_util_helper;
84200f96:	32 ee       	M[r4 + Null] = r0;
    /* return GOOD (0x600D) or BAD (0xBAD)*/
    (*resp_data)->msg_id = my_static_array[0];
84200f98:	31 e8       	rMAC = M[r4 + Null];
84200f9a:	3a e8       	r0 = M[r5 + Null];
84200f9c:	11 ee       	M[r0 + Null] = rMAC;

84200f9e <Lc_download_self_test_opmsg_start_self_test_23>:
        test_result = func_ptr[i]();
        if (test_result != 0x600D)
        {
            /* Return BAD (0xBAD) */
            (*resp_data)->msg_id = test_result;
            return TRUE;
84200f9e:	42 20       	r0 = Null + 1;

84200fa0 <Lc_download_self_test_opmsg_start_self_test_24>:
    /* Force linking of another C module for this capability */
    my_static_array[0] = download_self_test_util_helper();
    /* return GOOD (0x600D) or BAD (0xBAD)*/
    (*resp_data)->msg_id = my_static_array[0];
    return TRUE;
}
84200fa0:	f3 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, rLink>;
84200fa2:	d8 4c       	rts;

84200fa4 <Lc_download_self_test_process_data_c_1>:
/* ************************************* Data processing-related functions and wrappers **********************************/

static void download_self_test_process_data_c(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
    /* Does nothing, it's not expected to be called as we don't run as a normal operator */
    return ;
84200fa4:	d8 4c       	rts;

84200fa6 <Lc_download_self_test_variable_size_vars_test_c_1>:
volatile unsigned secondHalf[3] = {0xBEEF,0xDEAD, 0xABCD};
volatile uint16 secondHalf1 = 0xBEEF;

static unsigned int download_self_test_variable_size_vars_test_c(void)
{
    if (firstByte != 0xC)
84200fa6:	80 f3 01 f0 	rMAC = MBU[Null + $_firstByte];
84200faa:	68 92 
84200fac:	08 27       	Null = rMAC - 12;
84200fae:	04 60       	if EQ jump (m) Lc_download_self_test_variable_size_vars_test_c_3;

84200fb0 <Lc_download_self_test_variable_size_vars_test_c_2>:
    {
        return 0xBAD;
84200fb0:	02 f0 ad 53 	r0 = Null + 2989;
84200fb4:	47 6e       	jump (m) Lc_download_self_test_variable_size_vars_test_c_14;

84200fb6 <Lc_download_self_test_variable_size_vars_test_c_3>:
    }
    if (firstWord != 0x87654321UL)
84200fb6:	e0 f0 01 f0 	rMAC = M[Null + $_firstWord];
84200fba:	9b 88 
84200fbc:	21 f0 95 fd 	Null = rMAC - -2023406815;
84200fc0:	10 f0 21 27 
84200fc4:	f6 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200fc6 <Lc_download_self_test_variable_size_vars_test_c_4>:
    {
        return 0xBAD;
    }
    if (firstHalf != 0xABCD)
84200fc6:	c0 f1 01 f0 	rMAC = MHU[Null + $_firstHalf];
84200fca:	38 87 
84200fcc:	02 f0 10 f2 	Null = rMAC - 43981;
84200fd0:	cd 37 
84200fd2:	ef 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200fd4 <Lc_download_self_test_variable_size_vars_test_c_5>:
    {
        return 0xBAD;
    }
    if (secondByte != 0x2A)
84200fd4:	80 f3 01 f0 	rMAC = MBU[Null + $_secondByte];
84200fd8:	72 92 
84200fda:	88 36       	Null = rMAC - 42;
84200fdc:	ea 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200fde <Lc_download_self_test_variable_size_vars_test_c_6>:
    {
        return 0xBAD;
    }
    if (thirdByte != 0x2B)
84200fde:	80 f3 01 f0 	rMAC = MBU[Null + $_thirdByte];
84200fe2:	73 92 
84200fe4:	c8 36       	Null = rMAC - 43;
84200fe6:	e5 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200fe8 <Lc_download_self_test_variable_size_vars_test_c_7>:
    {
        return 0xBAD;
    }
    if (fourthByte != 0x2C)
84200fe8:	80 f3 01 f0 	rMAC = MBU[Null + $_fourthByte];
84200fec:	74 92 
84200fee:	08 37       	Null = rMAC - 44;
84200ff0:	e0 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200ff2 <Lc_download_self_test_variable_size_vars_test_c_8>:
    {
        return 0xBAD;
    }
    if (fifthByte != 0x2D)
84200ff2:	80 f3 01 f0 	rMAC = MBU[Null + $_fifthByte];
84200ff6:	75 92 
84200ff8:	48 37       	Null = rMAC - 45;
84200ffa:	db 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84200ffc <Lc_download_self_test_variable_size_vars_test_c_9>:
    {
        return 0xBAD;
    }
    if (ByteArray[2] != 0x30)
84200ffc:	80 f3 01 f0 	rMAC = MBU[Null + 0x700278];
84201000:	78 92 
84201002:	08 3c       	Null = rMAC - 48;
84201004:	d6 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84201006 <Lc_download_self_test_variable_size_vars_test_c_10>:
    {
        return 0xBAD;
    }
    if (secondWord != 0x63)
84201006:	e0 f0 01 f0 	rMAC = M[Null + $_secondWord];
8420100a:	9f 88 
8420100c:	10 f0 63 24 	Null = rMAC - 99;
84201010:	d0 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

84201012 <Lc_download_self_test_variable_size_vars_test_c_11>:
    {
        return 0xBAD;
    }
    if (sixthByte != 0x31)
84201012:	80 f3 01 f0 	rMAC = MBU[Null + $_sixthByte];
84201016:	80 92 
84201018:	48 3c       	Null = rMAC - 49;
8420101a:	cb 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

8420101c <Lc_download_self_test_variable_size_vars_test_c_12>:
    {
        return 0xBAD;
    }
    if (secondHalf[1] != 0xDEAD)
8420101c:	e0 f0 01 f0 	rMAC = M[Null + 0x700288];
84201020:	a2 88 
84201022:	03 f0 10 f1 	Null = rMAC - 57005;
84201026:	ad 3e 
84201028:	c4 63       	if NE jump (m) Lc_download_self_test_variable_size_vars_test_c_2;

8420102a <Lc_download_self_test_variable_size_vars_test_c_13>:
    }
    if (secondHalf1 != 0xBEEF)
    {
        return 0xBAD;
    }
    return 0x600D;
8420102a:	c0 f1 01 f0 	rMAC = MHU[Null + $_secondHalf1];
8420102e:	48 87 
84201030:	33 f0 0d 40 	r1 = Null + 24589;
84201034:	02 f0 ad 53 	r0 = Null + 2989;
84201038:	02 f0 10 f3 	Null = rMAC - 48879;
8420103c:	ef 3e 
8420103e:	00 f3 02 c0 	if EQ r0 = r1 + Null;

84201042 <Lc_download_self_test_variable_size_vars_test_c_14>:
84201042:	d8 4c       	rts;

84201044 <Lc_download_self_test_symbol_not_found_in_varLut_1>:
{
    if (dummy_static_pointer == NULL)
    {
        return 0xBAD;
    }
    return 0x600D;
84201044:	32 f0 0d 40 	r0 = Null + 24589;

84201048 <Lc_download_self_test_symbol_not_found_in_varLut_2>:
84201048:	d8 4c       	rts;

8420104a <Lc_download_self_test_variables_arrangement_1>:
}

static unsigned int download_self_test_variables_arrangement(void)
{
8420104a:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
    static char dict_2[] = "speech";
    static char dict_3[] = "ni";
    static char dict_4[] = "hao";
    static char dict_5[] = "xiao";
    static char dict_6[] = "le";
    int sil = strlen(dict_1);
8420104c:	07 f0 08 f0 	r6 = Null + 7340690;
84201050:	92 42 
84201052:	42 08       	r0 = r6 + Null;
84201054:	ff fd b0 f0 	call (m) 0x170aa;
84201058:	37 e2 
8420105a:	42 de       	M[FP + 32] = r0;
    int speech = strlen(dict_2);
8420105c:	07 f0 0a f0 	r8 = Null + 7340694;
84201060:	96 42 
84201062:	52 08       	r0 = r8 + Null;
84201064:	ff fd b0 f0 	call (m) 0x170aa;
84201068:	27 e2 
8420106a:	4a de       	M[FP + 36] = r0;
    int ni = strlen(dict_3);
8420106c:	07 f0 0b f0 	r9 = Null + 7340701;
84201070:	9d 42 
84201072:	5a 08       	r0 = r9 + Null;
84201074:	ff fd b0 f0 	call (m) 0x170aa;
84201078:	37 e1 
8420107a:	16 00       	r4 = r0 + Null;
    int hao = strlen(dict_4);
8420107c:	07 f0 01 f0 	rMAC = Null + 7340704;
84201080:	a0 42 
84201082:	51 de       	M[FP + 40] = rMAC;
84201084:	0a 00       	r0 = rMAC + Null;
84201086:	ff fd b0 f0 	call (m) 0x170aa;
8420108a:	25 e1 
8420108c:	17 00       	r5 = r0 + Null;
    int xiao = strlen(dict_5);
8420108e:	07 f0 01 f0 	rMAC = Null + 7340708;
84201092:	a4 42 
84201094:	59 de       	M[FP + 44] = rMAC;
84201096:	0a 00       	r0 = rMAC + Null;
84201098:	ff fd b0 f0 	call (m) 0x170aa;
8420109c:	33 e0 
8420109e:	11 09       	r7 = r0 + Null;
    int le = strlen(dict_6);
842010a0:	07 f0 01 f0 	rMAC = Null + 7340713;
842010a4:	a9 42 
842010a6:	61 de       	M[FP + 48] = rMAC;
842010a8:	0a 00       	r0 = rMAC + Null;
842010aa:	ff fd b0 f0 	call (m) 0x170aa;
842010ae:	21 e0 
    if ((sil == 3) && (speech == 6) && (ni == 2) && (hao == 3) && (xiao == 4) && (le == 2))
842010b0:	41 d8       	rMAC = M[FP + 32];
842010b2:	c8 24       	Null = rMAC - 3;
842010b4:	44 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010b6 <Lc_download_self_test_variables_arrangement_2>:
842010b6:	49 d8       	rMAC = M[FP + 36];
842010b8:	88 25       	Null = rMAC - 6;
842010ba:	41 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010bc <Lc_download_self_test_variables_arrangement_3>:
842010bc:	b0 24       	Null = r4 - 2;
842010be:	3f 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010c0 <Lc_download_self_test_variables_arrangement_4>:
842010c0:	f8 24       	Null = r5 - 3;
842010c2:	3d 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010c4 <Lc_download_self_test_variables_arrangement_5>:
842010c4:	90 f0 04 24 	Null = r7 - 4;
842010c8:	3a 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010ca <Lc_download_self_test_variables_arrangement_6>:
842010ca:	90 24       	Null = r0 - 2;
842010cc:	38 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010ce <Lc_download_self_test_variables_arrangement_7>:
    {
        if ((strcmp(dict_1,"sil") == 0) && (strcmp(dict_2,"speech")==0) &&
                (strcmp(dict_3,"ni") == 0) && (strcmp(dict_4,"hao") == 0) &&
                (strcmp(dict_5,"xiao") == 0) && (strcmp(dict_6,"le") == 0))
842010ce:	07 f0 03 f0 	r1 = Null + 7340368;
842010d2:	50 41 
842010d4:	42 08       	r0 = r6 + Null;
842010d6:	02 f0 33 eb 	call (m) $_strcmp;
842010da:	10 04       	Null = r0 - Null;
842010dc:	30 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010de <Lc_download_self_test_variables_arrangement_8>:
842010de:	07 f0 03 f0 	r1 = Null + 7340372;
842010e2:	54 41 
842010e4:	52 08       	r0 = r8 + Null;
842010e6:	02 f0 23 eb 	call (m) $_strcmp;
842010ea:	10 04       	Null = r0 - Null;
842010ec:	28 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010ee <Lc_download_self_test_variables_arrangement_9>:
842010ee:	07 f0 03 f0 	r1 = Null + 7340379;
842010f2:	5b 41 
842010f4:	5a 08       	r0 = r9 + Null;
842010f6:	02 f0 33 ea 	call (m) $_strcmp;
842010fa:	10 04       	Null = r0 - Null;
842010fc:	20 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

842010fe <Lc_download_self_test_variables_arrangement_10>:
842010fe:	07 f0 03 f0 	r1 = Null + 7340382;
84201102:	5e 41 
84201104:	52 d8       	r0 = M[FP + 40];
84201106:	02 f0 23 ea 	call (m) $_strcmp;
8420110a:	10 04       	Null = r0 - Null;
8420110c:	18 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

8420110e <Lc_download_self_test_variables_arrangement_11>:
8420110e:	07 f0 03 f0 	r1 = Null + 7340386;
84201112:	62 41 
84201114:	5a d8       	r0 = M[FP + 44];
84201116:	02 f0 33 e9 	call (m) $_strcmp;
8420111a:	10 04       	Null = r0 - Null;
8420111c:	10 62       	if NE jump (m) Lc_download_self_test_variables_arrangement_13;

8420111e <Lc_download_self_test_variables_arrangement_12>:
8420111e:	07 f0 03 f0 	r1 = Null + 7340391;
84201122:	67 41 
84201124:	62 d8       	r0 = M[FP + 48];
84201126:	02 f0 23 e9 	call (m) $_strcmp;
        {
            return 0x600D;
8420112a:	11 00       	rMAC = r0 + Null;
8420112c:	33 f0 0d 40 	r1 = Null + 24589;
84201130:	02 f0 ad 53 	r0 = Null + 2989;
84201134:	08 04       	Null = rMAC - Null;
84201136:	00 f3 02 c0 	if EQ r0 = r1 + Null;
8420113a:	03 6e       	jump (m) Lc_download_self_test_variables_arrangement_14;

8420113c <Lc_download_self_test_variables_arrangement_13>:
        }
    }
    return 0xBAD;
8420113c:	02 f0 ad 53 	r0 = Null + 2989;

84201140 <Lc_download_self_test_variables_arrangement_14>:
}
84201140:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201142:	d8 4c       	rts;

84201144 <$_download_self_test_util_helper>:
{
    a = n;
}

unsigned int download_self_test_util_helper(void)
{
84201144:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    void (*func_ptr)(void);
    /* Force a reference to a local C function */
    func_ptr = &func_increase_one;
84201146:	42 f0 01 f0 	rMAC = Null + 69210939;
8420114a:	3b 63 
    func_ptr();
8420114c:	d1 4c       	call rMAC;
    /* Force a reference to a global C function */
    func_ptr = &func_decrease_one;
8420114e:	42 f0 06 f0 	r4 = Null + 69210831;
84201152:	cf 62 
    func_ptr();
84201154:	d6 4c       	call r4;
    func_ptr();
84201156:	d6 4c       	call r4;
    func_ptr();
84201158:	d6 4c       	call r4;
    if (a == -1)
8420115a:	e0 f0 01 f0 	rMAC = M[Null + L_a];
8420115e:	b1 88 
84201160:	48 20       	Null = rMAC + 1;
84201162:	06 62       	if NE jump (m) Lc_download_self_test_util_helper_3;

84201164 <Lc_download_self_test_util_helper_2>:
    {
        if (download_self_test_opmsg_start_self_test2() != 0x600D)
84201164:	c5 4e       	call (m) Lc_download_self_test_opmsg_start_self_test2_1;
84201166:	01 f0 20 f2 	Null = r0 - 24589;
8420116a:	0d 24 
8420116c:	04 60       	if EQ jump (m) Lc_download_self_test_util_helper_4;

8420116e <Lc_download_self_test_util_helper_3>:
        {
            return 0xBAD;
8420116e:	02 f0 ad 53 	r0 = Null + 2989;
84201172:	12 6e       	jump (m) Lc_download_self_test_util_helper_6;

84201174 <Lc_download_self_test_util_helper_4>:
        }
        #ifdef CONST_TEST
        if (download_self_test_const_data_test() != 0x600D)
84201174:	01 f0 23 e0 	call (m) Lc_download_self_test_const_data_test_1;
84201178:	01 f0 20 f2 	Null = r0 - 24589;
8420117c:	0d 24 
8420117e:	f8 63       	if NE jump (m) Lc_download_self_test_util_helper_3;

84201180 <Lc_download_self_test_util_helper_5>:
        {
            return 0xBAD;
        }
        #endif
        if (download_self_test_sqrt_test() != 0x600D)
84201180:	0f 4e       	call (m) $_download_self_test_sqrt_test;
        {
            return 0xBAD;
        }
        return 0x600D;
84201182:	11 00       	rMAC = r0 + Null;
84201184:	33 f0 0d 40 	r1 = Null + 24589;
84201188:	02 f0 ad 53 	r0 = Null + 2989;
8420118c:	01 f0 10 f2 	Null = rMAC - 24589;
84201190:	0d 24 
84201192:	00 f3 02 c0 	if EQ r0 = r1 + Null;

84201196 <Lc_download_self_test_util_helper_6>:
    }
    else
    {
        return 0xBAD;
    }
}
84201196:	f1 48       	popm <FP, r4, rLink>;
84201198:	d8 4c       	rts;

8420119a <$_func_increase_one_with_param_c>:
    return *(unsigned int*)((unsigned)b + (unsigned int*)&foo[2]);
}

unsigned int func_increase_one_with_param_c(unsigned int a)
{
    return a + 1;
8420119a:	52 20       	r0 = r0 + 1;

8420119c <Lc_func_increase_one_with_param_c_2>:
8420119c:	d8 4c       	rts;

8420119e <$_download_self_test_sqrt_test>:

    return my_var;
}

unsigned int download_self_test_sqrt_test(void)
{
8420119e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
    float f = 0.40;
842011a0:	ec f3 66 f6 	r4 = Null + 1053609165;
842011a4:	cd 58 
    unsigned increments = 0;
842011a6:	07 00       	r5 = Null + Null;

842011a8 <Lc_download_self_test_sqrt_test_2>:
    while (sqrtf(f)<0.7)
842011a8:	32 00       	r0 = r4 + Null;
842011aa:	01 f0 35 ee 	call (m) $_sqrtf;
842011ae:	08 f0 31 ec 	call (m) $__FLE_f2dn;
842011b2:	fe f3 35 f3 	r3 = Null + 1072064102;
842011b6:	66 4a 
842011b8:	66 f6 34 f3 	r2 = Null + 1717986918;
842011bc:	66 4a 
842011be:	06 f0 2f e3 	call (m) $__FLE_cltd;
842011c2:	10 04       	Null = r0 - Null;
842011c4:	0a 60       	if EQ jump (m) Lc_download_self_test_sqrt_test_4;

842011c6 <Lc_download_self_test_sqrt_test_3>:
    {
        f = f + (float)0.01;
842011c6:	c2 f3 e3 f1 	r1 = Null + 1008981770;
842011ca:	0a 6b 
842011cc:	32 00       	r0 = r4 + Null;
842011ce:	04 f0 2d eb 	call (m) $__FLE_addfn;
842011d2:	16 00       	r4 = r0 + Null;
        increments++;
842011d4:	7f 20       	r5 = r5 + 1;

unsigned int download_self_test_sqrt_test(void)
{
    float f = 0.40;
    unsigned increments = 0;
    while (sqrtf(f)<0.7)
842011d6:	e9 6f       	jump (m) Lc_download_self_test_sqrt_test_2;

842011d8 <Lc_download_self_test_sqrt_test_4>:
        f = f + (float)0.01;
        increments++;
    }
    if (increments == 10)
    {
        return 0x600D;
842011d8:	31 f0 0d 40 	rMAC = Null + 24589;
842011dc:	02 f0 ad 53 	r0 = Null + 2989;
842011e0:	b8 26       	Null = r5 - 10;
842011e2:	00 f1 02 c0 	if EQ r0 = rMAC + Null;

842011e6 <Lc_download_self_test_sqrt_test_5>:
    }
    return 0xBAD;
}
842011e6:	f2 48       	popm <FP, r4, r5, rLink>;
842011e8:	d8 4c       	rts;

842011ea <$_func_return_struct_ptr>:
{
    return a + 1;
}

DOWNLOAD_SELF_TEST_OP_DATA* func_return_struct_ptr(void)
{
842011ea:	c8 1c       	pushm <FP(=SP), rLink>;
    /* Allocate zeroed memory */
    DOWNLOAD_SELF_TEST_OP_DATA *my_var = xzpmalloc(sizeof(DOWNLOAD_SELF_TEST_OP_DATA));
842011ec:	c3 20       	r1 = Null + 3;
842011ee:	02 2a       	r0 = Null + 24;
842011f0:	ff fd 1e f0 	call (m) 0x4f2a;
842011f4:	3b e9 

842011f6 <Lc_func_return_struct_ptr_2>:

    return my_var;
842011f6:	c8 48       	popm <FP, rLink>;
842011f8:	d8 4c       	rts;

842011fa <$_func_insert32_instr_c>:
    }
    return 0xBAD;
}

unsigned int func_insert32_instr_c(unsigned int a)
{
842011fa:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
    DOWNLOAD_SELF_TEST_OP_DATA *op_data = func_return_struct_ptr();
842011fc:	f7 4f       	call (m) $_func_return_struct_ptr;
842011fe:	16 00       	r4 = r0 + Null;

    unsigned j;
    unsigned k = 0;
84201200:	07 00       	r5 = Null + Null;
    static unsigned test_var;
    unsigned i = 4;
    unsigned old_val = op_data->helper_struct->entries[0].helper_var;
84201202:	71 89       	rMAC = M[r4 + 20];
84201204:	18 f0 00 e8 	r6 = M[rMAC + Null];
    unsigned new_val = func_increase_one_with_param_c(i);
84201208:	02 21       	r0 = Null + 4;
8420120a:	c8 4f       	call (m) $_func_increase_one_with_param_c;
    /* Insert32 instruction */
    test_var = new_val - old_val;
8420120c:	07 f0 03 f0 	M[L_test_var] = r0 - r6;
84201210:	7c f8 92 c3 

    /*
     * Do something before returning test_var to avoid the optimisation of
     * the code which could put test_var in a register.
     */
    for(j = 0; j <= i; j++)
84201214:	00 09       	r6 = Null + Null;

84201216 <Lc_func_insert32_instr_c_2>:
    {
        k = func_increase_one_with_param_c(k);
84201216:	3a 00       	r0 = r5 + Null;
84201218:	c1 4f       	call (m) $_func_increase_one_with_param_c;
8420121a:	17 00       	r5 = r0 + Null;

    /*
     * Do something before returning test_var to avoid the optimisation of
     * the code which could put test_var in a register.
     */
    for(j = 0; j <= i; j++)
8420121c:	08 75       	r6 = r6 + 1;
8420121e:	80 f0 04 24 	Null = r6 - 4;
84201222:	f9 ff f5 ef 	if LS jump (m) Lc_func_insert32_instr_c_2;

84201226 <Lc_func_insert32_instr_c_3>:
    {
        k = func_increase_one_with_param_c(k);
    }
    pfree(op_data);
84201226:	32 00       	r0 = r4 + Null;
84201228:	ff fd 1e f0 	call (m) 0x4f62;
8420122c:	3b e9 

    return test_var;
8420122e:	e0 f0 02 f0 	r0 = M[Null + L_test_var];
84201232:	df 88 

84201234 <Lc_func_insert32_instr_c_4>:
}
84201234:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201236:	d8 4c       	rts;

84201238 <$_download_self_test_array_offset_access_check>:
    *z = 0x1FFD;
    return 0x600D;
}

unsigned int download_self_test_array_offset_access_check(void)
{
84201238:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
    /* Force a relocation record in DM to y_array with an offset
     * KCSMaker will find the address of y_array by examining 
     * the contents of z[1] and subtracting the offset (2).
     * Making the pointer volatile prevents the compiler from referencing
     * the base address of y_array */
    unsigned int * volatile z[] = {&y_array[2], &y_array[2], 0};
8420123a:	07 f0 03 f0 	r1 = Null + 7340420;
8420123e:	84 41 
84201240:	c2 10       	r0 = FP + 12;
84201242:	c4 20       	r2 = Null + 3;
84201244:	ff fd af f0 	call (m) 0x17116;
84201248:	33 e6 
    unsigned int * volatile x = &z_array[2];
8420124a:	f8 ff 01 f0 	rMAC = Null + -8388540;
8420124e:	44 40 
84201250:	11 de       	M[FP + 8] = rMAC;
    unsigned int res = 0;
84201252:	01 00       	rMAC = Null + Null;
    for (int i = 2; i >= 0; i--)
84201254:	82 20       	r0 = Null + 2;
84201256:	1c 71       	r10 = Null + 3;
84201258:	07 4c       	do (m) Lc__loop0;

8420125a <Lc_download_self_test_array_offset_access_check_2>:
    {
        res = res + *(x-i);
8420125a:	13 d8       	r1 = M[FP + 8];
8420125c:	54 54       	r2 = r0 LSHIFT 2;
8420125e:	04 05       	r2 = Null - r2;
84201260:	1b e9       	r1 = M[r1 + r2];
84201262:	59 00       	rMAC = r1 + rMAC;
     * Making the pointer volatile prevents the compiler from referencing
     * the base address of y_array */
    unsigned int * volatile z[] = {&y_array[2], &y_array[2], 0};
    unsigned int * volatile x = &z_array[2];
    unsigned int res = 0;
    for (int i = 2; i >= 0; i--)
84201264:	52 24       	r0 = r0 - 1;

84201266 <Lc__loop0>:
84201266:	80 f3 02 f0 	r0 = MBU[Null + 0x700311];
8420126a:	11 93 
8420126c:	00 fe 03 f0 	r1 = MHU[Null + 0xff80004c];
84201270:	26 86 
84201272:	9a 00       	r0 = r1 + r0;
84201274:	23 d8       	r1 = M[FP + 16];
84201276:	3f f2 82 c0 	r0 = r0 + M[r1];
8420127a:	1b d8       	r1 = M[FP + 12];
8420127c:	3f f2 82 c0 	r0 = r0 + M[r1];
84201280:	8a 00       	r0 = rMAC + r0;

84201282 <Lc_download_self_test_array_offset_access_check_4>:
    {
        res = res + *(x-i);
    }
    return res + *z[1] + *z[0] + uint16_array[2] + uint8_array[1];
}
84201282:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84201284:	d8 4c       	rts;

84201286 <$_download_self_test_array_offset_access>:
static volatile uint16 uint16_array[3] = {0, 0, 2};
static volatile uint8 uint8_array[3] = {0, 3, 0};
static unsigned int y_array[3] = {5, 6, 4};

unsigned int download_self_test_array_offset_access(void)
{
84201286:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
    /* Force a relocation record in PM to z_array with an offset
     * KCSMaker will find the address of z_array by examining 
     * the opcode's immediate and subtracting the offset (-2).
     * Making the pointer volatile prevents the compiler from referencing
     * the base address of z_array */
    unsigned int * volatile z = &z_array[-2];
84201288:	f8 ff 01 f0 	rMAC = Null + -8388556;
8420128c:	34 40 
8420128e:	09 de       	M[FP + 4] = rMAC;
    z += 4;
84201290:	09 d8       	rMAC = M[FP + 4];
84201292:	09 28       	rMAC = rMAC + 16;
84201294:	09 de       	M[FP + 4] = rMAC;
    *z = 0x2000;
84201296:	11 f0 00 40 	rMAC = Null + 8192;
8420129a:	0a d8       	r0 = M[FP + 4];
8420129c:	11 ee       	M[r0 + Null] = rMAC;
    z--;
8420129e:	09 d8       	rMAC = M[FP + 4];
842012a0:	09 25       	rMAC = rMAC - 4;
842012a2:	09 de       	M[FP + 4] = rMAC;
    *z = 0x2003;
842012a4:	11 f0 03 40 	rMAC = Null + 8195;
842012a8:	0a d8       	r0 = M[FP + 4];
842012aa:	11 ee       	M[r0 + Null] = rMAC;
    z--;
842012ac:	09 d8       	rMAC = M[FP + 4];
842012ae:	09 25       	rMAC = rMAC - 4;
842012b0:	09 de       	M[FP + 4] = rMAC;
    *z = 0x1FFD;
842012b2:	01 f0 fd 7b 	rMAC = Null + 8189;
842012b6:	0a d8       	r0 = M[FP + 4];
842012b8:	11 ee       	M[r0 + Null] = rMAC;
    return 0x600D;
842012ba:	32 f0 0d 40 	r0 = Null + 24589;

842012be <Lc_download_self_test_array_offset_access_2>:
}
842012be:	48 49       	SP = SP - 0x10, popm <FP>;
842012c0:	d8 4c       	rts;

842012c2 <$_download_self_test_AddSub_B_instruction>:

#pragma datasection dm2
static int foo[] = {10,0x600D,20};
unsigned int download_self_test_AddSub_B_instruction(int a, int b)
{
    return *(unsigned int*)((unsigned)b + (unsigned int*)&foo[2]);
842012c2:	5a 54       	r0 = r1 LSHIFT 2;
842012c4:	00 fe 21 f0 	rMAC = r0 + -8388528;
842012c8:	50 20 
842012ca:	8a 88       	r0 = M[rMAC + 8];

842012cc <Lc_download_self_test_AddSub_B_instruction_2>:
842012cc:	d8 4c       	rts;

842012ce <$_func_decrease_one>:

    return test_var;
}

void func_decrease_one(void)
{
842012ce:	c8 1c       	pushm <FP(=SP), rLink>;
    func_increase_one();
842012d0:	35 4e       	call (m) Lc_func_increase_one_1;
    func_decrease(2);
842012d2:	82 20       	r0 = Null + 2;
842012d4:	26 4e       	call (m) Lc_func_decrease_1;

842012d6 <Lc_func_decrease_one_2>:
}
842012d6:	c8 48       	popm <FP, rLink>;
842012d8:	d8 4c       	rts;

842012da <$_set_a>:

void set_a(int n)
{
    a = n;
842012da:	e0 f0 02 f0 	M[Null + L_a] = r0;
842012de:	b1 8e 

842012e0 <Lc_set_a_2>:
842012e0:	d8 4c       	rts;

842012e2 <Lc_func_returns_good_1>:
/* In a downloadable capability we cannot have two functions with the same name
 * even if they are static. Build system would complain if this occurs. */

static unsigned int func_returns_good(void)
{
    return 0x600D;
842012e2:	32 f0 0d 40 	r0 = Null + 24589;

842012e6 <Lc_func_returns_good_2>:
842012e6:	d8 4c       	rts;

842012e8 <Lc_func_returns_bad_1>:
}

static unsigned int func_returns_bad(void)
{
    return 0xBAD;
842012e8:	02 f0 ad 53 	r0 = Null + 2989;

842012ec <Lc_func_returns_bad_2>:
842012ec:	d8 4c       	rts;

842012ee <Lc_download_self_test_opmsg_start_self_test2_1>:
}
#endif

static unsigned int download_self_test_opmsg_start_self_test2(void)
{
842012ee:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
    /* This will create an anonymous variable */
    unsigned int* my_local_array[] = {&my_static_array[0], &my_static_array[1], &my_static_array[2]};
842012f0:	07 f0 03 f0 	r1 = Null + 7340432;
842012f4:	90 41 
842012f6:	82 10       	r0 = FP + 8;
842012f8:	c4 20       	r2 = Null + 3;
842012fa:	ff fd af f0 	call (m) 0x17116;
842012fe:	3d e0 
84201300:	07 f0 01 f0 	rMAC = Null + 7340728;
84201304:	b8 42 
84201306:	82 10       	r0 = FP + 8;
    int i = 0;
    /* This loop forces the creation of anonymous initialisation tables L_lcx */
    for (i = 0; i < ARRAY_SIZE(my_static_array); i++)
84201308:	1c 71       	r10 = Null + 3;
8420130a:	06 4c       	do (m) Lc__loop1;

8420130c <Lc_download_self_test_opmsg_start_self_test2_2>:
    {
        my_static_array[i] = *(my_local_array[i]);
8420130c:	13 e8       	r1 = M[r0 + Null];
8420130e:	1b e8       	r1 = M[r1 + Null];
84201310:	12 21       	r0 = r0 + 4;
84201312:	0b ee       	M[rMAC + Null] = r1;
84201314:	09 21       	rMAC = rMAC + 4;

84201316 <Lc__loop1>:
{
    /* This will create an anonymous variable */
    unsigned int* my_local_array[] = {&my_static_array[0], &my_static_array[1], &my_static_array[2]};
    int i = 0;
    /* This loop forces the creation of anonymous initialisation tables L_lcx */
    for (i = 0; i < ARRAY_SIZE(my_static_array); i++)
84201316:	e0 f0 02 f0 	r0 = M[Null + L_my_static_array];
8420131a:	ae 88 

8420131c <Lc_download_self_test_opmsg_start_self_test2_4>:
    {
        my_static_array[i] = *(my_local_array[i]);
    }
    return my_static_array[0];
}
8420131c:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
8420131e:	d8 4c       	rts;

84201320 <Lc_func_decrease_1>:

static void func_decrease(unsigned int num)
{
84201320:	c8 1c       	pushm <FP(=SP), rLink>;
    if (num > 0)
84201322:	10 04       	Null = r0 - Null;
84201324:	09 60       	if EQ jump (m) Lc_func_decrease_3;

84201326 <Lc_func_decrease_2>:
    {
        /* Exercise recursion */
        func_decrease(num - 1);
84201326:	52 24       	r0 = r0 - 1;
84201328:	fc 4f       	call (m) Lc_func_decrease_1;
        a--;
8420132a:	07 f0 01 f0 	rMAC = Null + 7340740;
8420132e:	c4 42 
84201330:	ff f1 12 d1 	r0 = M[rMAC] + -1;
84201334:	0a ee       	M[rMAC + Null] = r0;

84201336 <Lc_func_decrease_3>:
    }
}
84201336:	c8 48       	popm <FP, rLink>;
84201338:	d8 4c       	rts;

8420133a <Lc_func_increase_one_1>:

static void func_increase_one(void)
{
    a++;
8420133a:	07 f0 01 f0 	rMAC = Null + 7340740;
8420133e:	c4 42 
84201340:	00 f1 12 d1 	r0 = M[rMAC] + 1;
84201344:	0a ee       	M[rMAC + Null] = r0;

84201346 <Lc_func_increase_one_2>:
84201346:	d8 4c       	rts;

84201348 <Lc_test_dyn_descriptor_1>:
}

#ifdef CONST_TEST

static unsigned int test_dyn_descriptor(void* dsc)
{
84201348:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
8420134a:	41 29       	rMAC = Null + 21;
8420134c:	41 da       	MB[FP + 8] = rMAC;
8420134e:	1a de       	M[FP + 12] = r0;
    uint16 *wbuf16;
    const_data_descriptor const_table_16_dsc_dyn = DEFINE_CONST_DATA_DESCRIPTOR(MEM_TYPE_CONST16,  FORMAT_16BIT_ZERO_PAD, dsc);
    wbuf16 = (uint16 *) const_data_access ( &const_table_16_dsc_dyn, 1*sizeof(uint16), NULL, 6*sizeof(uint16) );
84201350:	05 23       	r3 = Null + 12;
84201352:	83 20       	r1 = Null + 2;
84201354:	82 10       	r0 = FP + 8;
84201356:	04 00       	r2 = Null + Null;
84201358:	ef fd fb ff 	call (m) 0xad8;
8420135c:	21 ec 
    if ((wbuf16[3] != 0x5555U))
    {
        return 0xBAD;
8420135e:	d1 86       	rMAC = MHU[r0 + 6];
84201360:	03 f0 ad 53 	r1 = Null + 2989;
84201364:	32 f0 0d 40 	r0 = Null + 24589;
84201368:	01 f0 10 f1 	Null = rMAC - 21845;
8420136c:	55 2d 
8420136e:	01 f3 02 c0 	if NE r0 = r1 + Null;

84201372 <Lc_test_dyn_descriptor_2>:
    }
    return 0x600D;
}
84201372:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84201374:	d8 4c       	rts;

84201376 <Lc_download_self_test_const_data_test_1>:
 *
 * Test const_data API for a download capability
 *
 * */
static unsigned int download_self_test_const_data_test(void)
{
84201376:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84201378:	80 da       	MB[FP + 16] = Null;
    uint16 *wbuf16;
    unsigned *wbuf;
    /* Test external const memory access in download */
    wbuf16 = (uint16 *) const_data_access ( &const_table_16_dsc, 1*sizeof(uint16), NULL, 6*sizeof(uint16) );
8420137a:	05 23       	r3 = Null + 12;
8420137c:	83 20       	r1 = Null + 2;
8420137e:	07 f0 02 f0 	r0 = Null + 7340744;
84201382:	c8 42 
84201384:	04 00       	r2 = Null + Null;
84201386:	ef fd fb ff 	call (m) 0xad8;
8420138a:	33 ea 
8420138c:	17 00       	r5 = r0 + Null;
    wbuf = (unsigned *) const_data_access ( &const_table_24_dsc, 1*sizeof(unsigned), NULL, 5*sizeof(unsigned) );
8420138e:	05 29       	r3 = Null + 20;
84201390:	03 21       	r1 = Null + 4;
84201392:	07 f0 02 f0 	r0 = Null + 7340760;
84201396:	d8 42 
84201398:	04 00       	r2 = Null + Null;
8420139a:	ef fd fb ff 	call (m) 0xad8;
8420139e:	3f e9 
842013a0:	14 00       	r2 = r0 + Null;
    if ((wbuf16[5] != 0x7777U) || (wbuf[1] != 0xCCCCCCU))
842013a2:	79 87       	rMAC = MHU[r5 + 10];
842013a4:	01 f0 10 f3 	Null = rMAC - 30583;
842013a8:	77 2f 
842013aa:	06 62       	if NE jump (m) Lc_download_self_test_const_data_test_3;

842013ac <Lc_download_self_test_const_data_test_2>:
842013ac:	61 88       	rMAC = M[r2 + 4];
842013ae:	33 f3 10 f0 	Null = rMAC - 13421772;
842013b2:	cc 3c 
842013b4:	04 60       	if EQ jump (m) Lc_download_self_test_const_data_test_4;

842013b6 <Lc_download_self_test_const_data_test_3>:
    {
        return 0xBAD;
842013b6:	02 f0 ad 53 	r0 = Null + 2989;
842013ba:	e0 6e       	jump (m) Lc_download_self_test_const_data_test_15;

842013bc <Lc_download_self_test_const_data_test_4>:
    }
    wbuf = const_data_access ( &const_table_24_dsc_2, 1*sizeof(unsigned), wbuf, 1*sizeof(unsigned) );
842013bc:	05 21       	r3 = Null + 4;
842013be:	2b 00       	r1 = r3 + Null;
842013c0:	07 f0 02 f0 	r0 = Null + 7340768;
842013c4:	e0 42 
842013c6:	ef fd fb ff 	call (m) 0xad8;
842013ca:	33 e8 
    if (wbuf[0] != 0x0B00B5U)
842013cc:	11 e8       	rMAC = M[r0 + Null];
842013ce:	2c f0 10 f0 	Null = rMAC - 721077;
842013d2:	b5 24 
842013d4:	f1 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

842013d6 <Lc_download_self_test_const_data_test_5>:
    {
        return 0xBAD;
    }
    const_data_release(wbuf);
842013d6:	ef fd fb ff 	call (m) 0xade;
842013da:	29 e8 
    /* Access a DMCONST variable which in download gets placed in DM */
    wbuf = const_data_access ( &const_table_dm_dsc, 1*sizeof(unsigned), NULL, 1*sizeof(unsigned) );
842013dc:	05 21       	r3 = Null + 4;
842013de:	07 f0 02 f0 	r0 = Null + 7340776;
842013e2:	e8 42 
842013e4:	2b 00       	r1 = r3 + Null;
842013e6:	04 00       	r2 = Null + Null;
842013e8:	ef fd fb ff 	call (m) 0xad8;
842013ec:	31 e7 
842013ee:	16 00       	r4 = r0 + Null;
    if (wbuf[0] != 0xDEADAAU)
842013f0:	31 e8       	rMAC = M[r4 + Null];
842013f2:	7a f3 10 f2 	Null = rMAC - 14593450;
842013f6:	aa 3d 
842013f8:	df 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

842013fa <Lc_download_self_test_const_data_test_6>:
    {
        return 0xBAD;
    }
    wbuf16 = const_data_access ( &const_table_16_dsc_2, 0*sizeof(uint16), wbuf16, 4*sizeof(uint16));
842013fa:	05 22       	r3 = Null + 8;
842013fc:	07 f0 02 f0 	r0 = Null + 7340752;
84201400:	d0 42 
84201402:	03 00       	r1 = Null + Null;
84201404:	3c 00       	r2 = r5 + Null;
84201406:	ef fd fb ff 	call (m) 0xad8;
8420140a:	33 e6 
    /* Sum of three fields must be equal to last one */
    if (wbuf16[0] + wbuf16[1] + wbuf16[2] != wbuf16[3] )
8420140c:	51 86       	rMAC = MHU[r0 + 2];
8420140e:	13 e6       	r1 = MHU[r0 + Null];
84201410:	59 00       	rMAC = r1 + rMAC;
84201412:	93 86       	r1 = MHU[r0 + 4];
84201414:	59 00       	rMAC = r1 + rMAC;
84201416:	d3 86       	r1 = MHU[r0 + 6];
84201418:	c8 04       	Null = rMAC - r1;
8420141a:	ce 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

8420141c <Lc_download_self_test_const_data_test_7>:
    {
        return 0xBAD;
    }
    const_data_release(wbuf16);
8420141c:	ef fd fb ff 	call (m) 0xade;
84201420:	23 e6 
    const_data_release(wbuf);
84201422:	32 00       	r0 = r4 + Null;
84201424:	ef fd fb ff 	call (m) 0xade;
84201428:	3b e5 

    test_func_ptr* func_ptr_buf;
    /* Test const data access with references into downloaded capability DM and PM */
    /* Using DMCONST */
    func_ptr_buf = (test_func_ptr *) const_data_access ( &const_table_func_ptr_dm_dsc, 0*sizeof(test_func_ptr), NULL, 2*sizeof(test_func_ptr));
8420142a:	07 f0 06 f0 	r4 = Null + 7340784;
8420142e:	f0 42 
84201430:	05 22       	r3 = Null + 8;
84201432:	04 00       	r2 = Null + Null;
84201434:	03 00       	r1 = Null + Null;
84201436:	32 00       	r0 = r4 + Null;
84201438:	ef fd fb ff 	call (m) 0xad8;
8420143c:	21 e5 
8420143e:	17 00       	r5 = r0 + Null;
    if (func_ptr_buf[1]() != 0x600D)
84201440:	79 88       	rMAC = M[r5 + 4];
84201442:	d1 4c       	call rMAC;
84201444:	01 f0 20 f2 	Null = r0 - 24589;
84201448:	0d 24 
8420144a:	b6 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

8420144c <Lc_download_self_test_const_data_test_8>:
    {
        return 0xBAD;
    }
    const_data_release(func_ptr_buf);
8420144c:	3a 00       	r0 = r5 + Null;
8420144e:	ef fd fb ff 	call (m) 0xade;
84201452:	31 e4 
    /* Repeat previous test with an offset */
    func_ptr_buf = (test_func_ptr *) const_data_access ( &const_table_func_ptr_dm_dsc, 1*sizeof(test_func_ptr), NULL, 1*sizeof(test_func_ptr) );
84201454:	05 21       	r3 = Null + 4;
84201456:	04 00       	r2 = Null + Null;
84201458:	2b 00       	r1 = r3 + Null;
8420145a:	32 00       	r0 = r4 + Null;
8420145c:	ef fd fb ff 	call (m) 0xad8;
84201460:	3d e3 
84201462:	16 00       	r4 = r0 + Null;
    if (func_ptr_buf[0]() != 0x600D)
84201464:	31 e8       	rMAC = M[r4 + Null];
84201466:	d1 4c       	call rMAC;
84201468:	01 f0 20 f2 	Null = r0 - 24589;
8420146c:	0d 24 
8420146e:	a4 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

84201470 <Lc_download_self_test_const_data_test_9>:
    {
        return 0xBAD;
    }
    const_data_release(func_ptr_buf);
84201470:	32 00       	r0 = r4 + Null;
84201472:	ef fd fb ff 	call (m) 0xade;
84201476:	2d e3 
    /* Using CONST */
    func_ptr_buf = (test_func_ptr *) const_data_access ( &const_table_func_ptr_const_dsc, 0*sizeof(test_func_ptr), NULL, 3*sizeof(test_func_ptr) );
84201478:	07 f0 06 f0 	r4 = Null + 7340792;
8420147c:	f8 42 
8420147e:	05 23       	r3 = Null + 12;
84201480:	04 00       	r2 = Null + Null;
84201482:	03 00       	r1 = Null + Null;
84201484:	32 00       	r0 = r4 + Null;
84201486:	ef fd fb ff 	call (m) 0xad8;
8420148a:	33 e2 
8420148c:	17 00       	r5 = r0 + Null;
    if (func_ptr_buf[2]() != 0x600D)
8420148e:	b9 88       	rMAC = M[r5 + 8];
84201490:	d1 4c       	call rMAC;
84201492:	01 f0 20 f2 	Null = r0 - 24589;
84201496:	0d 24 
84201498:	8f 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

8420149a <Lc_download_self_test_const_data_test_10>:
    {
        return 0xBAD;
    }
    const_data_release(func_ptr_buf);
8420149a:	3a 00       	r0 = r5 + Null;
8420149c:	ef fd fb ff 	call (m) 0xade;
842014a0:	23 e2 
    /* Repeat previous test with an offset */
    func_ptr_buf = (test_func_ptr *) const_data_access ( &const_table_func_ptr_const_dsc, 1*sizeof(test_func_ptr), NULL, 2*sizeof(test_func_ptr) );
842014a2:	05 22       	r3 = Null + 8;
842014a4:	03 21       	r1 = Null + 4;
842014a6:	04 00       	r2 = Null + Null;
842014a8:	32 00       	r0 = r4 + Null;
842014aa:	ef fd fb ff 	call (m) 0xad8;
842014ae:	2f e1 
842014b0:	16 00       	r4 = r0 + Null;
    if (func_ptr_buf[1]() != 0x600D)
842014b2:	71 88       	rMAC = M[r4 + 4];
842014b4:	d1 4c       	call rMAC;
842014b6:	01 f0 20 f2 	Null = r0 - 24589;
842014ba:	0d 24 
842014bc:	7d 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

842014be <Lc_download_self_test_const_data_test_11>:
    {
        return 0xBAD;
    }
    const_data_release(func_ptr_buf);
842014be:	32 00       	r0 = r4 + Null;
842014c0:	ef fd fb ff 	call (m) 0xade;
842014c4:	3f e0 

    /* Use a CONST table to access another CONST table */
    /* Using DMCONST*/
    const_data_descriptor **desc = (const_data_descriptor **)const_data_access ( &const_table_desc_ptr_dm_dsc, 1*sizeof(const_data_descriptor *), NULL, 1*sizeof(const_data_descriptor *) );
842014c6:	05 21       	r3 = Null + 4;
842014c8:	07 f0 02 f0 	r0 = Null + 7340808;
842014cc:	08 43 
842014ce:	2b 00       	r1 = r3 + Null;
842014d0:	04 00       	r2 = Null + Null;
842014d2:	ef fd fb ff 	call (m) 0xad8;
842014d6:	27 e0 
842014d8:	16 00       	r4 = r0 + Null;
    /* desc[0] should be descriptor const_table_24_dsc_2 */
    wbuf = (unsigned*)const_data_access ( desc[0], 1*sizeof(unsigned), NULL, 2*sizeof(unsigned) );
842014da:	05 22       	r3 = Null + 8;
842014dc:	03 21       	r1 = Null + 4;
842014de:	32 e8       	r0 = M[r4 + Null];
842014e0:	04 00       	r2 = Null + Null;
842014e2:	ef fd fa ff 	call (m) 0xad8;
842014e6:	37 ef 
842014e8:	17 00       	r5 = r0 + Null;
    if (wbuf[1] != 0x0B00DAU)
842014ea:	79 88       	rMAC = M[r5 + 4];
842014ec:	2c f0 10 f0 	Null = rMAC - 721114;
842014f0:	da 24 
842014f2:	62 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

842014f4 <Lc_download_self_test_const_data_test_12>:
    {
        return 0xBAD;
    }
    const_data_release(desc);
842014f4:	32 00       	r0 = r4 + Null;
842014f6:	ef fd fa ff 	call (m) 0xade;
842014fa:	29 ef 
    const_data_release(wbuf);
842014fc:	3a 00       	r0 = r5 + Null;
842014fe:	ef fd fa ff 	call (m) 0xade;
84201502:	21 ef 
    /* Using CONST*/
    desc = (const_data_descriptor **)const_data_access ( &const_table_desc_ptr_const_dsc, 1*sizeof(const_data_descriptor *), NULL, 2*sizeof(const_data_descriptor *) );
84201504:	05 22       	r3 = Null + 8;
84201506:	03 21       	r1 = Null + 4;
84201508:	07 f0 02 f0 	r0 = Null + 7340800;
8420150c:	00 43 
8420150e:	04 00       	r2 = Null + Null;
84201510:	ef fd fa ff 	call (m) 0xad8;
84201514:	29 ee 
84201516:	16 00       	r4 = r0 + Null;
    /* desc[0] should be descriptor const_table_16_dsc */
    wbuf16 = (uint16*)const_data_access ( desc[0], 1*sizeof(uint16), NULL, 4*sizeof(uint16) );
84201518:	05 22       	r3 = Null + 8;
8420151a:	83 20       	r1 = Null + 2;
8420151c:	32 e8       	r0 = M[r4 + Null];
8420151e:	04 00       	r2 = Null + Null;
84201520:	ef fd fa ff 	call (m) 0xad8;
84201524:	39 ed 
84201526:	17 00       	r5 = r0 + Null;
    if (wbuf16[2] != 0x4444U)
84201528:	b9 86       	rMAC = MHU[r5 + 4];
8420152a:	01 f0 10 f0 	Null = rMAC - 17476;
8420152e:	44 2c 
84201530:	43 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

84201532 <Lc_download_self_test_const_data_test_13>:
    {
        return 0xBAD;
    }
    const_data_release(desc);
84201532:	32 00       	r0 = r4 + Null;
84201534:	ef fd fa ff 	call (m) 0xade;
84201538:	2b ed 
    const_data_release(wbuf16);
8420153a:	3a 00       	r0 = r5 + Null;
8420153c:	ef fd fa ff 	call (m) 0xade;
84201540:	23 ed 
    /* Test "dynamic" descriptors to access CONST tables */
    const_data_descriptor const_table_16_dsc_stack = DEFINE_CONST_DATA_DESCRIPTOR(MEM_TYPE_CONST16,  FORMAT_16BIT_ZERO_PAD, const_table_16);
84201542:	07 f0 01 f0 	rMAC = Null + 7340444;
84201546:	9c 41 
84201548:	02 11       	r0 = FP + 16;
8420154a:	0b e8       	r1 = M[rMAC + Null];
8420154c:	4c 88       	r2 = M[rMAC + 4];
8420154e:	13 ee       	M[r0 + Null] = r1;
84201550:	54 8e       	M[r0 + 4] = r2;
    wbuf16 = (uint16 *) const_data_access (&const_table_16_dsc_stack, 1*sizeof(uint16), NULL, 6*sizeof(uint16) );
84201552:	05 23       	r3 = Null + 12;
84201554:	83 20       	r1 = Null + 2;
84201556:	02 11       	r0 = FP + 16;
84201558:	04 00       	r2 = Null + Null;
8420155a:	ef fd fa ff 	call (m) 0xad8;
8420155e:	3f eb 
    if (wbuf16[4] != 0x6666U)
84201560:	11 87       	rMAC = MHU[r0 + 8];
84201562:	01 f0 10 f2 	Null = rMAC - 26214;
84201566:	66 2e 
84201568:	27 63       	if NE jump (m) Lc_download_self_test_const_data_test_3;

8420156a <Lc_download_self_test_const_data_test_14>:
    {
        return 0xBAD;
    }
    const_data_release(wbuf16);
8420156a:	ef fd fa ff 	call (m) 0xade;
8420156e:	35 eb 
    return test_dyn_descriptor((void*)const_table_16);
84201570:	f8 ff 02 f0 	r0 = Null + -8388516;
84201574:	5c 40 
84201576:	fe ff 33 ee 	call (m) Lc_test_dyn_descriptor_1;

8420157a <Lc_download_self_test_const_data_test_15>:
}
8420157a:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420157c:	d8 4c       	rts;

8420157e <$_sqrtf>:
8420157e:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84201580:	17 00       	r5 = r0 + Null;
84201582:	3b 00       	r1 = r5 + Null;
84201584:	04 f0 3f ee 	call (m) $__FLE_cnef;
84201588:	10 04       	Null = r0 - Null;
8420158a:	03 60       	if EQ jump (m) Lc_sqrtf_3;

8420158c <Lc_sqrtf_2>:
8420158c:	3a 00       	r0 = r5 + Null;
8420158e:	5b 6e       	jump (m) Lc_sqrtf_10;

84201590 <Lc_sqrtf_3>:
84201590:	03 00       	r1 = Null + Null;
84201592:	3a 00       	r0 = r5 + Null;
84201594:	04 f0 3b e0 	call (m) $__FLE_clef;
84201598:	10 04       	Null = r0 - Null;
8420159a:	0d 60       	if EQ jump (m) Lc_sqrtf_7;

8420159c <Lc_sqrtf_4>:
8420159c:	03 00       	r1 = Null + Null;
8420159e:	3a 00       	r0 = r5 + Null;
842015a0:	03 f0 31 e9 	call (m) $__FLE_ceqf;
842015a4:	10 04       	Null = r0 - Null;
842015a6:	05 62       	if NE jump (m) Lc_sqrtf_6;

842015a8 <Lc_sqrtf_5>:
842015a8:	41 30       	rMAC = Null + 33;
842015aa:	e0 f0 01 f0 	M[Null + $_errno] = rMAC;
842015ae:	e0 8e 

842015b0 <Lc_sqrtf_6>:
842015b0:	02 00       	r0 = Null + Null;
842015b2:	49 6e       	jump (m) Lc_sqrtf_10;

842015b4 <Lc_sqrtf_7>:
842015b4:	43 11       	r1 = FP + 20;
842015b6:	3a 00       	r0 = r5 + Null;
842015b8:	5d 4e       	call (m) $_frexpf;
842015ba:	16 00       	r4 = r0 + Null;
842015bc:	29 d8       	rMAC = M[FP + 20];
842015be:	0a c0       	r0 = rMAC AND 0x1;
842015c0:	08 60       	if EQ jump (m) Lc_sqrtf_9;

842015c2 <Lc_sqrtf_8>:
842015c2:	49 24       	rMAC = rMAC - 1;
842015c4:	33 00       	r1 = r4 + Null;
842015c6:	29 de       	M[FP + 20] = rMAC;
842015c8:	32 00       	r0 = r4 + Null;
842015ca:	02 f0 31 eb 	call (m) $__FLE_addfn;
842015ce:	16 00       	r4 = r0 + Null;

842015d0 <Lc_sqrtf_9>:
842015d0:	e8 f0 05 88 	r6 = M[FP + 20];
842015d4:	32 00       	r0 = r4 + Null;
842015d6:	06 f0 29 eb 	call (m) $__FLE_f2dn;
842015da:	ff f3 05 f0 	r3 = Null + 1072693248;
842015de:	00 40 
842015e0:	04 00       	r2 = Null + Null;
842015e2:	01 f0 3b e2 	call (m) $__FLE_adddn;
842015e6:	04 f0 3d ee 	call (m) $__FLE_d2fn;
842015ea:	70 f8 d3 d8 	r1 = r6 LSHIFT -31;
842015ee:	43 0c       	r1 = r6 + r1;
842015f0:	1b 58       	r1 = r1 ASHIFT -1;
842015f2:	5b 24       	r1 = r1 - 1;
842015f4:	c3 4e       	call (m) $_ldexpf;
842015f6:	16 00       	r4 = r0 + Null;
842015f8:	33 00       	r1 = r4 + Null;
842015fa:	3a 00       	r0 = r5 + Null;
842015fc:	05 f0 2d e7 	call (m) $__FLE_divfn;
84201600:	33 00       	r1 = r4 + Null;
84201602:	02 f0 39 e9 	call (m) $__FLE_addfn;
84201606:	f0 f3 03 f0 	r1 = Null + 1056964608;
8420160a:	00 40 
8420160c:	06 f0 21 ed 	call (m) $__FLE_mulfn;
84201610:	16 00       	r4 = r0 + Null;
84201612:	33 00       	r1 = r4 + Null;
84201614:	3a 00       	r0 = r5 + Null;
84201616:	05 f0 33 e6 	call (m) $__FLE_divfn;
8420161a:	33 00       	r1 = r4 + Null;
8420161c:	02 f0 3f e8 	call (m) $__FLE_addfn;
84201620:	f0 f3 03 f0 	r1 = Null + 1056964608;
84201624:	00 40 
84201626:	06 f0 27 ec 	call (m) $__FLE_mulfn;
8420162a:	16 00       	r4 = r0 + Null;
8420162c:	33 00       	r1 = r4 + Null;
8420162e:	3a 00       	r0 = r5 + Null;
84201630:	05 f0 39 e5 	call (m) $__FLE_divfn;
84201634:	33 00       	r1 = r4 + Null;
84201636:	02 f0 25 e8 	call (m) $__FLE_addfn;
8420163a:	f0 f3 03 f0 	r1 = Null + 1056964608;
8420163e:	00 40 
84201640:	06 f0 2d eb 	call (m) $__FLE_mulfn;

84201644 <Lc_sqrtf_10>:
84201644:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84201646:	d8 4c       	rts;

84201648 <$_strcmp>:
84201648:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
8420164a:	13 de       	M[FP + 8] = r1;
8420164c:	0a de       	M[FP + 4] = r0;
8420164e:	09 6e       	jump (m) Lc_strcmp_4;

84201650 <Lc_strcmp_2>:
84201650:	12 d8       	r0 = M[FP + 8];
84201652:	14 e2       	r2 = MBU[r0 + Null];
84201654:	08 05       	Null = rMAC - r2;
84201656:	08 62       	if NE jump (m) Lc_strcmp_5;

84201658 <Lc_strcmp_3>:
84201658:	59 20       	rMAC = r1 + 1;
8420165a:	09 de       	M[FP + 4] = rMAC;
8420165c:	51 20       	rMAC = r0 + 1;
8420165e:	11 de       	M[FP + 8] = rMAC;

84201660 <Lc_strcmp_4>:
84201660:	0b d8       	r1 = M[FP + 4];
84201662:	19 e2       	rMAC = MBU[r1 + Null];
84201664:	f6 63       	if NE jump (m) Lc_strcmp_2;

84201666 <Lc_strcmp_5>:
84201666:	12 d8       	r0 = M[FP + 8];
84201668:	19 e2       	rMAC = MBU[r1 + Null];
8420166a:	12 e2       	r0 = MBU[r0 + Null];
8420166c:	8a 04       	r0 = rMAC - r0;

8420166e <Lc_strcmp_6>:
8420166e:	48 49       	SP = SP - 0x10, popm <FP>;
84201670:	d8 4c       	rts;

84201672 <$_frexpf>:
84201672:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201674:	17 00       	r5 = r0 + Null;
84201676:	43 de       	M[FP + 32] = r1;
84201678:	01 09       	r7 = Null + Null;
8420167a:	3b 00       	r1 = r5 + Null;
8420167c:	02 f0 3f e5 	call (m) $__FLE_addfn;
84201680:	3b 00       	r1 = r5 + Null;
84201682:	04 f0 21 e7 	call (m) $__FLE_cnef;
84201686:	10 04       	Null = r0 - Null;
84201688:	73 60       	if EQ jump (m) Lc_frexpf_20;

8420168a <Lc_frexpf_2>:
8420168a:	3b 00       	r1 = r5 + Null;
8420168c:	3a 00       	r0 = r5 + Null;
8420168e:	04 f0 35 e6 	call (m) $__FLE_cnef;
84201692:	10 04       	Null = r0 - Null;
84201694:	6d 62       	if NE jump (m) Lc_frexpf_20;

84201696 <Lc_frexpf_3>:
84201696:	30 71       	r6 = Null + 6;
84201698:	3a 00       	r0 = r5 + Null;
8420169a:	07 f0 35 e6 	call (m) $__FLE_tltf;
8420169e:	03 09       	r9 = Null + Null;
842016a0:	10 04       	Null = r0 - Null;
842016a2:	21 f0 4b ce 	if NE r9 = Null + 1;
842016a6:	0f fb 00 c2 	Null = r9 - Null;
842016aa:	05 60       	if EQ jump (m) Lc_frexpf_5;

842016ac <Lc_frexpf_4>:
842016ac:	3a 00       	r0 = r5 + Null;
842016ae:	07 f0 37 e5 	call (m) $__FLE_negf;
842016b2:	17 00       	r5 = r0 + Null;

842016b4 <Lc_frexpf_5>:
842016b4:	f8 f3 03 f0 	r1 = Null + 1065353216;
842016b8:	00 40 
842016ba:	3a 00       	r0 = r5 + Null;
842016bc:	04 f0 2d e1 	call (m) $__FLE_cltf;
842016c0:	07 f0 0a f0 	r8 = Null + 7340452;
842016c4:	a4 41 
842016c6:	10 04       	Null = r0 - Null;
842016c8:	27 60       	if EQ jump (m) Lc_frexpf_12;

842016ca <Lc_frexpf_6>:
842016ca:	56 08       	r4 = r8 + Null;
842016cc:	73 99       	r1 = M[r4 + 52];
842016ce:	3a 00       	r0 = r5 + Null;
842016d0:	04 f0 39 e0 	call (m) $__FLE_cltf;
842016d4:	10 04       	Null = r0 - Null;
842016d6:	08 60       	if EQ jump (m) Lc_frexpf_8;

842016d8 <Lc_frexpf_7>:
842016d8:	32 99       	r0 = M[r4 + 48];
842016da:	3b 00       	r1 = r5 + Null;
842016dc:	06 f0 31 e6 	call (m) $__FLE_mulfn;
842016e0:	17 00       	r5 = r0 + Null;
842016e2:	f9 f7 c0 7b 	r7 = Null + -64;

842016e6 <Lc_frexpf_8>:
842016e6:	a6 f0 30 20 	r4 = r8 + 48;

842016ea <Lc_frexpf_9>:
842016ea:	73 88       	r1 = M[r4 + 4];
842016ec:	3a 00       	r0 = r5 + Null;
842016ee:	03 f0 3b ef 	call (m) $__FLE_cltf;
842016f2:	10 04       	Null = r0 - Null;
842016f4:	0b 60       	if EQ jump (m) Lc_frexpf_11;

842016f6 <Lc_frexpf_10>:
842016f6:	32 e8       	r0 = M[r4 + Null];
842016f8:	3b 00       	r1 = r5 + Null;
842016fa:	06 f0 33 e5 	call (m) $__FLE_mulfn;
842016fe:	41 08       	rMAC = r6 + Null;
84201700:	17 00       	r5 = r0 + Null;
84201702:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201706:	00 f2 39 c2 	r7 = r7 - r0;

8420170a <Lc_frexpf_11>:
8420170a:	c6 7c       	r4 = r4 + -8;
8420170c:	88 f0 01 24 	r6 = r6 - 1;
84201710:	f5 ff db ef 	if POS jump (m) Lc_frexpf_9;

84201714 <Lc_2>:
84201714:	26 6e       	jump (m) Lc_frexpf_18;

84201716 <Lc_frexpf_12>:
84201716:	a6 f0 30 20 	r4 = r8 + 48;

8420171a <Lc_frexpf_13>:
8420171a:	33 e8       	r1 = M[r4 + Null];
8420171c:	3a 00       	r0 = r5 + Null;
8420171e:	03 f0 33 e0 	call (m) $__FLE_cgef;
84201722:	10 04       	Null = r0 - Null;
84201724:	0a 60       	if EQ jump (m) Lc_frexpf_15;

84201726 <Lc_frexpf_14>:
84201726:	72 88       	r0 = M[r4 + 4];
84201728:	3b 00       	r1 = r5 + Null;
8420172a:	06 f0 23 e4 	call (m) $__FLE_mulfn;
8420172e:	41 08       	rMAC = r6 + Null;
84201730:	17 00       	r5 = r0 + Null;
84201732:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84201736:	11 0d       	r7 = r0 + r7;

84201738 <Lc_frexpf_15>:
84201738:	c6 7c       	r4 = r4 + -8;
8420173a:	88 f0 01 24 	r6 = r6 - 1;
8420173e:	f5 ff dd ef 	if POS jump (m) Lc_frexpf_13;

84201742 <Lc_frexpf_16>:
84201742:	f8 f3 03 f0 	r1 = Null + 1065353216;
84201746:	00 40 
84201748:	3a 00       	r0 = r5 + Null;
8420174a:	02 f0 27 ef 	call (m) $__FLE_cgef;
8420174e:	10 04       	Null = r0 - Null;
84201750:	08 60       	if EQ jump (m) Lc_frexpf_18;

84201752 <Lc_frexpf_17>:
84201752:	a2 f0 01 88 	r0 = M[r8 + 4];
84201756:	3b 00       	r1 = r5 + Null;
84201758:	06 f0 35 e2 	call (m) $__FLE_mulfn;
8420175c:	17 00       	r5 = r0 + Null;
8420175e:	09 75       	r7 = r7 + 1;

84201760 <Lc_frexpf_18>:
84201760:	0f fb 00 c2 	Null = r9 - Null;
84201764:	05 60       	if EQ jump (m) Lc_frexpf_20;

84201766 <Lc_frexpf_19>:
84201766:	3a 00       	r0 = r5 + Null;
84201768:	06 f0 3d ef 	call (m) $__FLE_negf;
8420176c:	17 00       	r5 = r0 + Null;

8420176e <Lc_frexpf_20>:
8420176e:	41 d8       	rMAC = M[FP + 32];
84201770:	19 f0 00 ee 	M[rMAC + Null] = r7;
84201774:	3a 00       	r0 = r5 + Null;

84201776 <Lc_frexpf_21>:
84201776:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201778:	d8 4c       	rts;

8420177a <$_ldexpf>:
8420177a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420177c:	16 00       	r4 = r0 + Null;
8420177e:	1f 00       	r5 = r1 + Null;
84201780:	5b 60       	if EQ jump (m) Lc_ldexpf_17;

84201782 <Lc_ldexpf_2>:
84201782:	33 00       	r1 = r4 + Null;
84201784:	01 f0 37 ed 	call (m) $__FLE_addfn;
84201788:	33 00       	r1 = r4 + Null;
8420178a:	02 f0 27 ea 	call (m) $__FLE_ceqf;
8420178e:	10 04       	Null = r0 - Null;
84201790:	53 62       	if NE jump (m) Lc_ldexpf_17;

84201792 <Lc_ldexpf_3>:
84201792:	33 00       	r1 = r4 + Null;
84201794:	32 00       	r0 = r4 + Null;
84201796:	03 f0 2d ee 	call (m) $__FLE_cnef;
8420179a:	10 04       	Null = r0 - Null;
8420179c:	4d 62       	if NE jump (m) Lc_ldexpf_17;

8420179e <Lc_ldexpf_4>:
8420179e:	38 09       	r6 = r5 + Null;
842017a0:	05 f0 95 e0 	if POS jump (m) Lc_ldexpf_6;

842017a4 <Lc_ldexpf_5>:
842017a4:	7f f0 08 c2 	r6 = Null - r5;
842017a8:	f0 f3 07 f0 	r5 = Null + 1056964608;
842017ac:	00 40 
842017ae:	0a f0 7e 40 	r8 = Null + 126;
842017b2:	06 6e       	jump (m) Lc_ldexpf_7;

842017b4 <Lc_ldexpf_6>:
842017b4:	0a f0 7f 40 	r8 = Null + 127;
842017b8:	00 f4 07 f0 	r5 = Null + 1073741824;
842017bc:	00 40 

842017be <Lc_ldexpf_7>:
842017be:	09 71       	r7 = Null + 1;

842017c0 <Lc_ldexpf_8>:
842017c0:	81 f0 01 00 	rMAC = r6 AND 0x1;
842017c4:	13 60       	if EQ jump (m) Lc_ldexpf_11;

842017c6 <Lc_ldexpf_9>:
842017c6:	33 00       	r1 = r4 + Null;
842017c8:	3a 00       	r0 = r5 + Null;
842017ca:	05 f0 23 ef 	call (m) $__FLE_mulfn;
842017ce:	16 00       	r4 = r0 + Null;
842017d0:	33 00       	r1 = r4 + Null;
842017d2:	01 f0 29 eb 	call (m) $__FLE_addfn;
842017d6:	33 00       	r1 = r4 + Null;
842017d8:	02 f0 39 e7 	call (m) $__FLE_ceqf;
842017dc:	10 04       	Null = r0 - Null;
842017de:	06 60       	if EQ jump (m) Lc_ldexpf_11;

842017e0 <Lc_ldexpf_10>:
842017e0:	81 30       	rMAC = Null + 34;
842017e2:	e0 f0 01 f0 	M[Null + $_errno] = rMAC;
842017e6:	e0 8e 
842017e8:	13 6e       	jump (m) Lc_ldexpf_14;

842017ea <Lc_ldexpf_11>:
842017ea:	00 f9 d9 d8 	r7 = r7 LSHIFT 1;
842017ee:	af f9 00 c2 	Null = r7 - r8;
842017f2:	0c 6a       	if GT jump (m) Lc_ldexpf_13;

842017f4 <Lc_ldexpf_12>:
842017f4:	7f f8 18 d9 	r6 = r6 ASHIFT -1;
842017f8:	3b 00       	r1 = r5 + Null;
842017fa:	3a 00       	r0 = r5 + Null;
842017fc:	05 f0 31 ed 	call (m) $__FLE_mulfn;
84201800:	17 00       	r5 = r0 + Null;
84201802:	80 f0 00 24 	Null = r6 - 0;
84201806:	dd 6b       	if GT jump (m) Lc_ldexpf_8;

84201808 <Lc_1>:
84201808:	17 6e       	jump (m) Lc_ldexpf_17;

8420180a <Lc_ldexpf_13>:
8420180a:	88 f0 01 24 	r6 = r6 - 1;

8420180e <Lc_ldexpf_14>:
8420180e:	80 f0 00 24 	Null = r6 - 0;
84201812:	12 6c       	if LE jump (m) Lc_ldexpf_17;

84201814 <Lc_ldexpf_15>:
84201814:	33 00       	r1 = r4 + Null;
84201816:	3a 00       	r0 = r5 + Null;
84201818:	05 f0 35 ec 	call (m) $__FLE_mulfn;
8420181c:	16 00       	r4 = r0 + Null;
8420181e:	33 00       	r1 = r4 + Null;
84201820:	01 f0 3b e8 	call (m) $__FLE_addfn;
84201824:	33 00       	r1 = r4 + Null;
84201826:	02 f0 2b e5 	call (m) $__FLE_ceqf;
8420182a:	10 04       	Null = r0 - Null;
8420182c:	ef 61       	if EQ jump (m) Lc_ldexpf_13;

8420182e <Lc_ldexpf_16>:
8420182e:	81 30       	rMAC = Null + 34;
84201830:	e0 f0 01 f0 	M[Null + $_errno] = rMAC;
84201834:	e0 8e 

84201836 <Lc_ldexpf_17>:
84201836:	32 00       	r0 = r4 + Null;

84201838 <Lc_ldexpf_18>:
84201838:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420183a:	d8 4c       	rts;

8420183c <$__FLE_adddn>:
8420183c:	74 1e       	pushm <FP(=SP), r4, r5, r6, r7>, SP = SP + 0x20;
8420183e:	1f 00       	r5 = r1 + Null;
84201840:	03 00       	r1 = Null + Null;
84201842:	16 00       	r4 = r0 + Null;
84201844:	3a 00       	r0 = r5 + Null;
84201846:	13 00       	r1 = r0 + Null;
84201848:	28 09       	r6 = r3 + Null;
8420184a:	45 de       	M[FP + 32] = r3;
8420184c:	37 de       	M[FP + 24] = r5;
8420184e:	da 52       	r0 = r1 LSHIFT -20;
84201850:	76 f8 d9 c8 	r7 = r6 LSHIFT -20;
84201854:	3c de       	M[FP + 28] = r2;
84201856:	2e de       	M[FP + 20] = r4;
84201858:	12 c5       	r0 = r0 AND 0x7ff;
8420185a:	91 f0 ff 07 	rMAC = r7 AND 0x7ff;
8420185e:	20 f0 ff 2f 	Null = r0 - 2047;
84201862:	26 62       	if NE jump (m) Lc__FLE_adddn_11;

84201864 <Lc__FLE_adddn_2>:
84201864:	10 f0 ff 2f 	Null = rMAC - 2047;
84201868:	05 62       	if NE jump (m) Lc__FLE_adddn_5;

8420186a <Lc__FLE_adddn_3>:
8420186a:	19 c7       	rMAC = r1 AND 0xfffff;
8420186c:	03 62       	if NE jump (m) Lc__FLE_adddn_5;

8420186e <Lc__FLE_adddn_4>:
8420186e:	31 00       	rMAC = r4 + Null;
84201870:	05 60       	if EQ jump (m) Lc__FLE_adddn_6;

84201872 <Lc__FLE_adddn_5>:
84201872:	3b 00       	r1 = r5 + Null;
84201874:	32 00       	r0 = r4 + Null;
84201876:	0f f0 c1 e5 	jump (m) Lc__FLE_adddn_71;

8420187a <Lc__FLE_adddn_6>:
8420187a:	07 f0 81 ff 	rMAC = r6 AND 0xfffff;
8420187e:	ff 1f 
84201880:	01 f0 b3 e5 	if NE jump (m) Lc__FLE_adddn_70;

84201884 <Lc__FLE_adddn_7>:
84201884:	21 00       	rMAC = r2 + Null;
84201886:	01 f0 ad e5 	if NE jump (m) Lc__FLE_adddn_70;

8420188a <Lc__FLE_adddn_8>:
8420188a:	3f f8 81 c8 	rMAC = r6 XOR r1;
8420188e:	c9 c7       	rMAC = rMAC AND 0x80000000;
84201890:	05 60       	if EQ jump (m) Lc__FLE_adddn_10;

84201892 <Lc__FLE_adddn_9>:
84201892:	ff f7 01 f7 	rMAC = Null + 2147352576;
84201896:	00 40 
84201898:	31 de       	M[FP + 24] = rMAC;

8420189a <Lc__FLE_adddn_10>:
8420189a:	41 11       	rMAC = FP + 20;
8420189c:	0b e8       	r1 = M[rMAC + Null];
8420189e:	c2 11       	r0 = FP + 28;
842018a0:	4c 88       	r2 = M[rMAC + 4];
842018a2:	13 ee       	M[r0 + Null] = r1;
842018a4:	54 8e       	M[r0 + 4] = r2;
842018a6:	43 d8       	r1 = M[FP + 32];
842018a8:	3a d8       	r0 = M[FP + 28];
842018aa:	0f f0 8d e5 	jump (m) Lc__FLE_adddn_71;

842018ae <Lc__FLE_adddn_11>:
842018ae:	10 f0 ff 2f 	Null = rMAC - 2047;
842018b2:	00 f0 81 e5 	if EQ jump (m) Lc__FLE_adddn_70;

842018b6 <Lc__FLE_adddn_12>:
842018b6:	88 04       	Null = rMAC - r0;
842018b8:	16 6c       	if LE jump (m) Lc__FLE_adddn_14;

842018ba <Lc__FLE_adddn_13>:
842018ba:	43 11       	r1 = FP + 20;
842018bc:	44 12       	r2 = FP + 36;
842018be:	1d e8       	r3 = M[r1 + Null];
842018c0:	5e 88       	r4 = M[r1 + 4];
842018c2:	25 ee       	M[r2 + Null] = r3;
842018c4:	66 8e       	M[r2 + 4] = r4;
842018c6:	c3 11       	r1 = FP + 28;
842018c8:	44 11       	r2 = FP + 20;
842018ca:	1d e8       	r3 = M[r1 + Null];
842018cc:	5e 88       	r4 = M[r1 + 4];
842018ce:	25 ee       	M[r2 + Null] = r3;
842018d0:	66 8e       	M[r2 + 4] = r4;
842018d2:	43 12       	r1 = FP + 36;
842018d4:	c4 11       	r2 = FP + 28;
842018d6:	1d e8       	r3 = M[r1 + Null];
842018d8:	5e 88       	r4 = M[r1 + 4];
842018da:	25 ee       	M[r2 + Null] = r3;
842018dc:	13 00       	r1 = r0 + Null;
842018de:	0a 00       	r0 = rMAC + Null;
842018e0:	66 8e       	M[r2 + 4] = r4;
842018e2:	19 00       	rMAC = r1 + Null;

842018e4 <Lc__FLE_adddn_14>:
842018e4:	2c d8       	r2 = M[FP + 20];
842018e6:	4c de       	M[FP + 36] = r2;
842018e8:	36 d8       	r4 = M[FP + 24];
842018ea:	35 c7       	r3 = r4 AND 0xfffff;
842018ec:	53 04       	r1 = r0 - rMAC;
842018ee:	55 de       	M[FP + 40] = r3;
842018f0:	10 04       	Null = r0 - Null;
842018f2:	06 60       	if EQ jump (m) Lc__FLE_adddn_16;

842018f4 <Lc__FLE_adddn_15>:
842018f4:	01 f0 00 f0 	r3 = r3 OR 0x100000;
842018f8:	00 f5 55 c8 
842018fc:	55 de       	M[FP + 40] = r3;

842018fe <Lc__FLE_adddn_16>:
842018fe:	f5 c7       	r3 = r4 AND 0x80000000;
84201900:	0a 60       	if EQ jump (m) Lc__FLE_adddn_19;

84201902 <Lc__FLE_adddn_17>:
84201902:	55 d8       	r3 = M[FP + 40];
84201904:	ff f5 55 d6 	r3 = -1 - r3;
84201908:	04 05       	r2 = Null - r2;
8420190a:	55 de       	M[FP + 40] = r3;
8420190c:	4c de       	M[FP + 36] = r2;
8420190e:	03 62       	if NE jump (m) Lc__FLE_adddn_19;

84201910 <Lc__FLE_adddn_18>:
84201910:	6c 20       	r2 = r3 + 1;
84201912:	54 de       	M[FP + 40] = r2;

84201914 <Lc__FLE_adddn_19>:
84201914:	3c d8       	r2 = M[FP + 28];
84201916:	4d d8       	r3 = M[FP + 36];
84201918:	5c de       	M[FP + 44] = r2;
8420191a:	47 d8       	r5 = M[FP + 32];
8420191c:	3e c7       	r4 = r5 AND 0xfffff;
8420191e:	66 de       	M[FP + 48] = r4;
84201920:	08 04       	Null = rMAC - Null;
84201922:	07 60       	if EQ jump (m) Lc__FLE_adddn_21;

84201924 <Lc__FLE_adddn_20>:
84201924:	01 f0 00 f0 	rMAC = r4 OR 0x100000;
84201928:	00 f6 51 c8 
8420192c:	61 de       	M[FP + 48] = rMAC;
8420192e:	04 6e       	jump (m) Lc__FLE_adddn_23;

84201930 <Lc__FLE_adddn_21>:
84201930:	18 04       	Null = r1 - Null;
84201932:	02 60       	if EQ jump (m) Lc__FLE_adddn_23;

84201934 <Lc__FLE_adddn_22>:
84201934:	5b 24       	r1 = r1 - 1;

84201936 <Lc__FLE_adddn_23>:
84201936:	f9 c7       	rMAC = r5 AND 0x80000000;
84201938:	0a 60       	if EQ jump (m) Lc__FLE_adddn_26;

8420193a <Lc__FLE_adddn_24>:
8420193a:	61 d8       	rMAC = M[FP + 48];
8420193c:	ff f1 51 d6 	rMAC = -1 - rMAC;
84201940:	04 05       	r2 = Null - r2;
84201942:	61 de       	M[FP + 48] = rMAC;
84201944:	5c de       	M[FP + 44] = r2;
84201946:	03 62       	if NE jump (m) Lc__FLE_adddn_26;

84201948 <Lc__FLE_adddn_25>:
84201948:	49 20       	rMAC = rMAC + 1;
8420194a:	61 de       	M[FP + 48] = rMAC;

8420194c <Lc__FLE_adddn_26>:
8420194c:	5c d8       	r2 = M[FP + 44];
8420194e:	67 d8       	r5 = M[FP + 48];
84201950:	71 f4 d6 d8 	r4 = r2 LSHIFT -29;
84201954:	bf 54       	r5 = r5 LSHIFT 3;
84201956:	f1 13       	rMAC = r4 OR r5;
84201958:	a4 54       	r2 = r2 LSHIFT 3;
8420195a:	61 de       	M[FP + 48] = rMAC;
8420195c:	5c de       	M[FP + 44] = r2;
8420195e:	d8 3d       	Null = r1 - 55;
84201960:	5a 66       	if GE jump (m) Lc__FLE_adddn_36;

84201962 <Lc__FLE_adddn_27>:
84201962:	18 34       	Null = r1 - 32;
84201964:	0d 68       	if LT jump (m) Lc__FLE_adddn_29;

84201966 <Lc__FLE_adddn_28>:
84201966:	06 00       	r4 = Null + Null;
84201968:	20 04       	Null = r2 - Null;
8420196a:	21 f0 46 ce 	if NE r4 = Null + 1;
8420196e:	74 12       	r2 = r4 OR rMAC;
84201970:	5c de       	M[FP + 44] = r2;
84201972:	04 00       	r2 = Null + Null;
84201974:	08 04       	Null = rMAC - Null;
84201976:	34 f0 44 ce 	if NEG r2 = Null - 1;
8420197a:	64 de       	M[FP + 48] = r2;
8420197c:	03 7c       	r1 = r1 + -32;

8420197e <Lc__FLE_adddn_29>:
8420197e:	18 04       	Null = r1 - Null;
84201980:	18 60       	if EQ jump (m) Lc__FLE_adddn_31;

84201982 <Lc__FLE_adddn_30>:
84201982:	19 00       	rMAC = r1 + Null;
84201984:	00 f1 96 de 	r4 = 0x1 LSHIFT rMAC;
84201988:	71 24       	rMAC = r4 - 1;
8420198a:	5c d8       	r2 = M[FP + 44];
8420198c:	0e 11       	r4 = rMAC AND r2;
8420198e:	01 00       	rMAC = Null + Null;
84201990:	30 04       	Null = r4 - Null;
84201992:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201996:	c6 04       	r4 = Null - r1;
84201998:	a4 17       	r2 = r2 LSHIFT r4;
8420199a:	66 d8       	r4 = M[FP + 48];
8420199c:	10 f3 57 c6 	r5 = 32 - r1;
842019a0:	f6 17       	r4 = r4 LSHIFT r5;
842019a2:	a4 13       	r2 = r2 OR r4;
842019a4:	09 13       	rMAC = rMAC OR r2;
842019a6:	59 de       	M[FP + 44] = rMAC;
842019a8:	c1 04       	rMAC = Null - r1;
842019aa:	64 d8       	r2 = M[FP + 48];
842019ac:	63 18       	r1 = r2 ASHIFT rMAC;
842019ae:	63 de       	M[FP + 48] = r1;

842019b0 <Lc__FLE_adddn_31>:
842019b0:	ab 54       	r1 = r3 LSHIFT 3;
842019b2:	59 d8       	rMAC = M[FP + 44];
842019b4:	cb 00       	r1 = rMAC + r1;
842019b6:	04 00       	r2 = Null + Null;
842019b8:	4b de       	M[FP + 36] = r1;
842019ba:	58 04       	Null = r1 - rMAC;
842019bc:	23 f0 44 ce 	if NC r2 = Null + 1;
842019c0:	61 d8       	rMAC = M[FP + 48];
842019c2:	61 00       	rMAC = r2 + rMAC;
842019c4:	71 f5 d4 d8 	r2 = r3 LSHIFT -29;
842019c8:	55 d8       	r3 = M[FP + 40];
842019ca:	ad 54       	r3 = r3 LSHIFT 3;
842019cc:	64 13       	r2 = r2 OR r3;
842019ce:	0c 01       	r2 = rMAC + r2;
842019d0:	00 f8 01 f0 	rMAC = Null + -2147483648;
842019d4:	00 40 
842019d6:	54 de       	M[FP + 40] = r2;
842019d8:	05 f0 01 c0 	if POS rMAC = Null + Null;
842019dc:	08 04       	Null = rMAC - Null;
842019de:	0a 60       	if EQ jump (m) Lc__FLE_adddn_33;

842019e0 <Lc__FLE_adddn_32>:
842019e0:	c3 04       	r1 = Null - r1;
842019e2:	05 00       	r3 = Null + Null;
842019e4:	4b de       	M[FP + 36] = r1;
842019e6:	20 f0 45 ce 	if EQ r3 = Null + 1;
842019ea:	ff f4 53 d6 	r1 = -1 - r2;
842019ee:	eb 00       	r1 = r3 + r1;
842019f0:	53 de       	M[FP + 40] = r1;

842019f2 <Lc__FLE_adddn_33>:
842019f2:	54 d8       	r2 = M[FP + 40];
842019f4:	c0 ff 43 f0 	r1 = r2 AND 0xff800000;
842019f8:	00 00 
842019fa:	00 f2 30 f0 	Null = r1 - 8388608;
842019fe:	00 24 
84201a00:	09 f0 b7 e0 	if LS jump (m) Lc__FLE_adddn_38;

84201a04 <Lc__FLE_adddn_34>:
84201a04:	52 20       	r0 = r0 + 1;
84201a06:	20 f0 ff 2f 	Null = r0 - 2047;
84201a0a:	0d 62       	if NE jump (m) Lc__FLE_adddn_37;

84201a0c <Lc__FLE_adddn_35>:
84201a0c:	48 de       	M[FP + 36] = Null;
84201a0e:	49 cf       	rMAC = rMAC OR 0x7ff00000;
84201a10:	51 de       	M[FP + 40] = rMAC;
84201a12:	6f 6e       	jump (m) Lc__FLE_adddn_63;

84201a14 <Lc__FLE_adddn_36>:
84201a14:	63 12       	r1 = r2 OR rMAC;
84201a16:	01 00       	rMAC = Null + Null;
84201a18:	18 04       	Null = r1 - Null;
84201a1a:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201a1e:	59 de       	M[FP + 44] = rMAC;
84201a20:	60 de       	M[FP + 48] = Null;
84201a22:	c7 6f       	jump (m) Lc__FLE_adddn_31;

84201a24 <Lc__FLE_adddn_37>:
84201a24:	4b d8       	r1 = M[FP + 36];
84201a26:	1d c0       	r3 = r1 AND 0x1;
84201a28:	1b 50       	r1 = r1 LSHIFT -1;
84201a2a:	5b 13       	r1 = r1 OR r3;
84201a2c:	a5 57       	r3 = r2 LSHIFT 31;
84201a2e:	5b 13       	r1 = r1 OR r3;
84201a30:	4b de       	M[FP + 36] = r1;
84201a32:	23 50       	r1 = r2 LSHIFT -1;
84201a34:	53 de       	M[FP + 40] = r1;

84201a36 <Lc__FLE_adddn_38>:
84201a36:	4c d8       	r2 = M[FP + 36];
84201a38:	55 d8       	r3 = M[FP + 40];
84201a3a:	0e f5 d6 d8 	r4 = r3 LSHIFT 29;
84201a3e:	23 c1       	r1 = r2 AND 0x7;
84201a40:	a4 50       	r2 = r2 LSHIFT -3;
84201a42:	a4 13       	r2 = r2 OR r4;
84201a44:	ad 50       	r3 = r3 LSHIFT -3;
84201a46:	4c de       	M[FP + 36] = r2;
84201a48:	55 de       	M[FP + 40] = r3;
84201a4a:	10 24       	Null = r0 - 0;
84201a4c:	15 6c       	if LE jump (m) Lc__FLE_adddn_45;

84201a4e <Lc__FLE_adddn_39>:
84201a4e:	08 f0 56 f0 	r4 = r3 AND 0x100000;
84201a52:	00 00 
84201a54:	11 62       	if NE jump (m) Lc__FLE_adddn_45;

84201a56 <Lc__FLE_adddn_40>:
84201a56:	52 24       	r0 = r0 - 1;
84201a58:	10 24       	Null = r0 - 0;
84201a5a:	0c 6c       	if LE jump (m) Lc__FLE_adddn_44;

84201a5c <Lc__FLE_adddn_41>:
84201a5c:	2d 54       	r3 = r3 LSHIFT 1;
84201a5e:	55 de       	M[FP + 40] = r3;
84201a60:	20 04       	Null = r2 - Null;
84201a62:	05 f0 89 e0 	if POS jump (m) Lc__FLE_adddn_43;

84201a66 <Lc__FLE_adddn_42>:
84201a66:	2d c8       	r3 = r3 OR 0x1;
84201a68:	55 de       	M[FP + 40] = r3;

84201a6a <Lc__FLE_adddn_43>:
84201a6a:	24 54       	r2 = r2 LSHIFT 1;
84201a6c:	5d 58       	r3 = r1 ASHIFT -2;
84201a6e:	64 13       	r2 = r2 OR r3;
84201a70:	4c de       	M[FP + 36] = r2;

84201a72 <Lc__FLE_adddn_44>:
84201a72:	9b c0       	r1 = r1 AND 0x3;
84201a74:	04 6e       	jump (m) Lc__FLE_adddn_46;

84201a76 <Lc__FLE_adddn_45>:
84201a76:	1c c0       	r2 = r1 AND 0x1;
84201a78:	1b 58       	r1 = r1 ASHIFT -1;
84201a7a:	1b 13       	r1 = r1 OR r2;

84201a7c <Lc__FLE_adddn_46>:
84201a7c:	98 24       	Null = r1 - 2;
84201a7e:	06 6a       	if GT jump (m) Lc__FLE_adddn_49;

84201a80 <Lc__FLE_adddn_47>:
84201a80:	98 24       	Null = r1 - 2;
84201a82:	1f 62       	if NE jump (m) Lc__FLE_adddn_55;

84201a84 <Lc__FLE_adddn_48>:
84201a84:	4b d8       	r1 = M[FP + 36];
84201a86:	1b c0       	r1 = r1 AND 0x1;
84201a88:	1c 60       	if EQ jump (m) Lc__FLE_adddn_55;

84201a8a <Lc__FLE_adddn_49>:
84201a8a:	4b d8       	r1 = M[FP + 36];
84201a8c:	5b 20       	r1 = r1 + 1;
84201a8e:	4b de       	M[FP + 36] = r1;
84201a90:	04 62       	if NE jump (m) Lc__FLE_adddn_51;

84201a92 <Lc__FLE_adddn_50>:
84201a92:	53 d8       	r1 = M[FP + 40];
84201a94:	5b 20       	r1 = r1 + 1;
84201a96:	53 de       	M[FP + 40] = r1;

84201a98 <Lc__FLE_adddn_51>:
84201a98:	53 d8       	r1 = M[FP + 40];
84201a9a:	5c c7       	r2 = r1 AND 0x7ff00000;
84201a9c:	40 f0 40 f0 	Null = r2 - 1048576;
84201aa0:	00 24 
84201aa2:	09 f0 9f e0 	if LS jump (m) Lc__FLE_adddn_55;

84201aa6 <Lc__FLE_adddn_52>:
84201aa6:	52 20       	r0 = r0 + 1;
84201aa8:	20 f0 ff 2f 	Null = r0 - 2047;
84201aac:	08 62       	if NE jump (m) Lc__FLE_adddn_54;

84201aae <Lc__FLE_adddn_53>:
84201aae:	5b 24       	r1 = r1 - 1;
84201ab0:	53 de       	M[FP + 40] = r1;
84201ab2:	02 f0 fe 4b 	r0 = Null + 2046;
84201ab6:	43 24       	r1 = Null - 1;
84201ab8:	4b de       	M[FP + 36] = r1;
84201aba:	03 6e       	jump (m) Lc__FLE_adddn_55;

84201abc <Lc__FLE_adddn_54>:
84201abc:	1b 50       	r1 = r1 LSHIFT -1;
84201abe:	53 de       	M[FP + 40] = r1;

84201ac0 <Lc__FLE_adddn_55>:
84201ac0:	50 d8       	Null = M[FP + 40];
84201ac2:	10 62       	if NE jump (m) Lc__FLE_adddn_61;

84201ac4 <Lc__FLE_adddn_56>:
84201ac4:	48 d8       	Null = M[FP + 36];
84201ac6:	0e 62       	if NE jump (m) Lc__FLE_adddn_61;

84201ac8 <Lc__FLE_adddn_57>:
84201ac8:	02 00       	r0 = Null + Null;
84201aca:	01 00       	rMAC = Null + Null;
84201acc:	0d 6e       	jump (m) Lc__FLE_adddn_62;

84201ace <Lc__FLE_adddn_58>:
84201ace:	10 2d       	Null = r0 - 20;
84201ad0:	19 64       	if NC jump (m) Lc__FLE_adddn_64;

84201ad2 <Lc__FLE_adddn_59>:
84201ad2:	18 04       	Null = r1 - Null;
84201ad4:	17 62       	if NE jump (m) Lc__FLE_adddn_64;

84201ad6 <Lc__FLE_adddn_60>:
84201ad6:	4b d8       	r1 = M[FP + 36];
84201ad8:	1c 52       	r2 = r1 LSHIFT -12;
84201ada:	54 de       	M[FP + 40] = r2;
84201adc:	db 56       	r1 = r1 LSHIFT 20;
84201ade:	62 7c       	r0 = r0 + -20;
84201ae0:	4b de       	M[FP + 36] = r1;

84201ae2 <Lc__FLE_adddn_61>:
84201ae2:	10 24       	Null = r0 - 0;
84201ae4:	1c 6a       	if GT jump (m) Lc__FLE_adddn_68;

84201ae6 <Lc__FLE_adddn_62>:
84201ae6:	53 d8       	r1 = M[FP + 40];
84201ae8:	d2 56       	r0 = r0 LSHIFT 20;
84201aea:	d2 12       	r0 = r0 OR r1;
84201aec:	89 12       	rMAC = rMAC OR r0;
84201aee:	51 de       	M[FP + 40] = rMAC;

84201af0 <Lc__FLE_adddn_63>:
84201af0:	41 12       	rMAC = FP + 36;
84201af2:	0b e8       	r1 = M[rMAC + Null];
84201af4:	42 11       	r0 = FP + 20;
84201af6:	4c 88       	r2 = M[rMAC + 4];
84201af8:	13 ee       	M[r0 + Null] = r1;
84201afa:	54 8e       	M[r0 + 4] = r2;
84201afc:	33 d8       	r1 = M[FP + 24];
84201afe:	2a d8       	r0 = M[FP + 20];
84201b00:	1b 6e       	jump (m) Lc__FLE_adddn_71;

84201b02 <Lc__FLE_adddn_64>:
84201b02:	52 24       	r0 = r0 - 1;
84201b04:	10 24       	Null = r0 - 0;
84201b06:	f0 6d       	if LE jump (m) Lc__FLE_adddn_62;

84201b08 <Lc__FLE_adddn_65>:
84201b08:	1b 54       	r1 = r1 LSHIFT 1;
84201b0a:	53 de       	M[FP + 40] = r1;
84201b0c:	4c d8       	r2 = M[FP + 36];
84201b0e:	05 f0 89 e0 	if POS jump (m) Lc__FLE_adddn_67;

84201b12 <Lc__FLE_adddn_66>:
84201b12:	1b c8       	r1 = r1 OR 0x1;
84201b14:	53 de       	M[FP + 40] = r1;

84201b16 <Lc__FLE_adddn_67>:
84201b16:	4b d8       	r1 = M[FP + 36];
84201b18:	1b 54       	r1 = r1 LSHIFT 1;
84201b1a:	4b de       	M[FP + 36] = r1;

84201b1c <Lc__FLE_adddn_68>:
84201b1c:	53 d8       	r1 = M[FP + 40];
84201b1e:	08 f0 34 f0 	r2 = r1 AND 0x100000;
84201b22:	00 00 
84201b24:	d5 61       	if EQ jump (m) Lc__FLE_adddn_58;

84201b26 <Lc__FLE_adddn_69>:
84201b26:	04 f0 07 f0 	r1 = r1 AND 0x800fffff;
84201b2a:	33 ff ff 1f 
84201b2e:	53 de       	M[FP + 40] = r1;
84201b30:	db 6f       	jump (m) Lc__FLE_adddn_62;

84201b32 <Lc__FLE_adddn_70>:
84201b32:	2b 00       	r1 = r3 + Null;
84201b34:	22 00       	r0 = r2 + Null;

84201b36 <Lc__FLE_adddn_71>:
84201b36:	74 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7>;
84201b38:	d8 4c       	rts;

84201b3a <$__FLE_addfn>:
84201b3a:	72 1d       	pushm <FP(=SP), r4, r5>, SP = SP + 0x10;
84201b3c:	74 f2 d4 d8 	r2 = r0 LSHIFT -23;
84201b40:	74 f3 d7 d8 	r5 = r1 LSHIFT -23;
84201b44:	15 00       	r3 = r0 + Null;
84201b46:	1b de       	M[FP + 12] = r1;
84201b48:	1e 00       	r4 = r1 + Null;
84201b4a:	a4 c3       	r2 = r2 AND 0xff;
84201b4c:	b9 c3       	rMAC = r5 AND 0xff;
84201b4e:	40 f0 ff 24 	Null = r2 - 255;
84201b52:	16 62       	if NE jump (m) Lc__FLE_addfn_8;

84201b54 <Lc__FLE_addfn_2>:
84201b54:	10 f0 ff 24 	Null = rMAC - 255;
84201b58:	05 62       	if NE jump (m) Lc__FLE_addfn_4;

84201b5a <Lc__FLE_addfn_3>:
84201b5a:	3f f0 21 ff 	rMAC = r0 AND 0x7fffff;
84201b5e:	ff 1f 
84201b60:	03 60       	if EQ jump (m) Lc__FLE_addfn_5;

84201b62 <Lc__FLE_addfn_4>:
84201b62:	1a de       	M[FP + 12] = r0;
84201b64:	b3 6e       	jump (m) Lc__FLE_addfn_55;

84201b66 <Lc__FLE_addfn_5>:
84201b66:	3f f0 31 ff 	rMAC = r1 AND 0x7fffff;
84201b6a:	ff 1f 
84201b6c:	ae 62       	if NE jump (m) Lc__FLE_addfn_54;

84201b6e <Lc__FLE_addfn_6>:
84201b6e:	99 14       	rMAC = r1 XOR r0;
84201b70:	c9 c7       	rMAC = rMAC AND 0x80000000;
84201b72:	ac 60       	if EQ jump (m) Lc__FLE_addfn_55;

84201b74 <Lc__FLE_addfn_7>:
84201b74:	ff f7 01 f0 	rMAC = Null + 2146435072;
84201b78:	00 40 
84201b7a:	19 de       	M[FP + 12] = rMAC;
84201b7c:	a7 6e       	jump (m) Lc__FLE_addfn_55;

84201b7e <Lc__FLE_addfn_8>:
84201b7e:	10 f0 ff 24 	Null = rMAC - 255;
84201b82:	a3 60       	if EQ jump (m) Lc__FLE_addfn_54;

84201b84 <Lc__FLE_addfn_9>:
84201b84:	08 05       	Null = rMAC - r2;
84201b86:	06 6c       	if LE jump (m) Lc__FLE_addfn_11;

84201b88 <Lc__FLE_addfn_10>:
84201b88:	16 00       	r4 = r0 + Null;
84201b8a:	22 00       	r0 = r2 + Null;
84201b8c:	0c 00       	r2 = rMAC + Null;
84201b8e:	1d 00       	r3 = r1 + Null;
84201b90:	11 00       	rMAC = r0 + Null;

84201b92 <Lc__FLE_addfn_11>:
84201b92:	67 04       	r5 = r2 - rMAC;
84201b94:	3f f0 52 ff 	r0 = r3 AND 0x7fffff;
84201b98:	ff 1f 
84201b9a:	20 04       	Null = r2 - Null;
84201b9c:	05 60       	if EQ jump (m) Lc__FLE_addfn_13;

84201b9e <Lc__FLE_addfn_12>:
84201b9e:	08 f0 00 f0 	r0 = r0 OR 0x800000;
84201ba2:	00 f2 52 c8 

84201ba6 <Lc__FLE_addfn_13>:
84201ba6:	eb c7       	r1 = r3 AND 0x80000000;
84201ba8:	02 60       	if EQ jump (m) Lc__FLE_addfn_15;

84201baa <Lc__FLE_addfn_14>:
84201baa:	82 04       	r0 = Null - r0;

84201bac <Lc__FLE_addfn_15>:
84201bac:	3f f0 63 ff 	r1 = r4 AND 0x7fffff;
84201bb0:	ff 1f 
84201bb2:	08 04       	Null = rMAC - Null;
84201bb4:	06 60       	if EQ jump (m) Lc__FLE_addfn_17;

84201bb6 <Lc__FLE_addfn_16>:
84201bb6:	08 f0 00 f0 	r1 = r1 OR 0x800000;
84201bba:	00 f3 53 c8 
84201bbe:	04 6e       	jump (m) Lc__FLE_addfn_19;

84201bc0 <Lc__FLE_addfn_17>:
84201bc0:	38 04       	Null = r5 - Null;
84201bc2:	02 60       	if EQ jump (m) Lc__FLE_addfn_19;

84201bc4 <Lc__FLE_addfn_18>:
84201bc4:	7f 24       	r5 = r5 - 1;

84201bc6 <Lc__FLE_addfn_19>:
84201bc6:	f1 c7       	rMAC = r4 AND 0x80000000;
84201bc8:	02 60       	if EQ jump (m) Lc__FLE_addfn_21;

84201bca <Lc__FLE_addfn_20>:
84201bca:	c3 04       	r1 = Null - r1;

84201bcc <Lc__FLE_addfn_21>:
84201bcc:	9b 54       	r1 = r1 LSHIFT 3;
84201bce:	38 34       	Null = r5 - 32;
84201bd0:	07 68       	if LT jump (m) Lc__FLE_addfn_23;

84201bd2 <Lc__FLE_addfn_22>:
84201bd2:	d9 c7       	rMAC = r1 AND 0x80000000;
84201bd4:	03 00       	r1 = Null + Null;
84201bd6:	08 04       	Null = rMAC - Null;
84201bd8:	31 f0 43 ce 	if NE r1 = Null - 1;
84201bdc:	07 7c       	r5 = r5 + -32;

84201bde <Lc__FLE_addfn_23>:
84201bde:	38 04       	Null = r5 - Null;
84201be0:	0d 60       	if EQ jump (m) Lc__FLE_addfn_25;

84201be2 <Lc__FLE_addfn_24>:
84201be2:	39 00       	rMAC = r5 + Null;
84201be4:	00 f1 95 de 	r3 = 0x1 LSHIFT rMAC;
84201be8:	69 24       	rMAC = r3 - 1;
84201bea:	cd 10       	r3 = rMAC AND r1;
84201bec:	01 00       	rMAC = Null + Null;
84201bee:	28 04       	Null = r3 - Null;
84201bf0:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201bf4:	c5 05       	r3 = Null - r5;
84201bf6:	5b 19       	r1 = r1 ASHIFT r3;
84201bf8:	5b 12       	r1 = r1 OR rMAC;

84201bfa <Lc__FLE_addfn_25>:
84201bfa:	92 54       	r0 = r0 LSHIFT 3;
84201bfc:	01 00       	rMAC = Null + Null;
84201bfe:	d3 00       	r1 = r0 + r1;
84201c00:	da c7       	r0 = r1 AND 0x80000000;
84201c02:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201c06:	08 04       	Null = rMAC - Null;
84201c08:	02 60       	if EQ jump (m) Lc__FLE_addfn_27;

84201c0a <Lc__FLE_addfn_26>:
84201c0a:	c3 04       	r1 = Null - r1;

84201c0c <Lc__FLE_addfn_27>:
84201c0c:	00 fe 32 f0 	r0 = r1 AND 0xfc000000;
84201c10:	00 00 
84201c12:	01 f0 00 f0 	Null = r0 - 67108864;
84201c16:	20 f0 00 24 
84201c1a:	09 f0 a5 e0 	if LS jump (m) Lc__FLE_addfn_32;

84201c1e <Lc__FLE_addfn_28>:
84201c1e:	64 20       	r2 = r2 + 1;
84201c20:	40 f0 ff 24 	Null = r2 - 255;
84201c24:	0a 62       	if NE jump (m) Lc__FLE_addfn_31;

84201c26 <Lc__FLE_addfn_29>:
84201c26:	f8 f7 03 f0 	r1 = Null + 2139095040;
84201c2a:	00 40 
84201c2c:	08 04       	Null = rMAC - Null;
84201c2e:	4b 60       	if EQ jump (m) Lc__FLE_addfn_53;

84201c30 <Lc__FLE_addfn_30>:
84201c30:	f8 ff 03 f0 	r1 = Null + -8388608;
84201c34:	00 40 
84201c36:	47 6e       	jump (m) Lc__FLE_addfn_53;

84201c38 <Lc__FLE_addfn_31>:
84201c38:	1a c0       	r0 = r1 AND 0x1;
84201c3a:	1b 50       	r1 = r1 LSHIFT -1;
84201c3c:	9b 12       	r1 = r1 OR r0;

84201c3e <Lc__FLE_addfn_32>:
84201c3e:	1a c1       	r0 = r1 AND 0x7;
84201c40:	9b 50       	r1 = r1 LSHIFT -3;
84201c42:	20 24       	Null = r2 - 0;
84201c44:	0d 6c       	if LE jump (m) Lc__FLE_addfn_37;

84201c46 <Lc__FLE_addfn_33>:
84201c46:	40 f0 35 f0 	r3 = r1 AND 0x800000;
84201c4a:	00 00 
84201c4c:	09 62       	if NE jump (m) Lc__FLE_addfn_37;

84201c4e <Lc__FLE_addfn_34>:
84201c4e:	64 24       	r2 = r2 - 1;
84201c50:	20 24       	Null = r2 - 0;
84201c52:	04 6c       	if LE jump (m) Lc__FLE_addfn_36;

84201c54 <Lc__FLE_addfn_35>:
84201c54:	1b 54       	r1 = r1 LSHIFT 1;
84201c56:	55 58       	r3 = r0 ASHIFT -2;
84201c58:	5b 13       	r1 = r1 OR r3;

84201c5a <Lc__FLE_addfn_36>:
84201c5a:	92 c0       	r0 = r0 AND 0x3;
84201c5c:	04 6e       	jump (m) Lc__FLE_addfn_38;

84201c5e <Lc__FLE_addfn_37>:
84201c5e:	15 c0       	r3 = r0 AND 0x1;
84201c60:	12 58       	r0 = r0 ASHIFT -1;
84201c62:	52 13       	r0 = r0 OR r3;

84201c64 <Lc__FLE_addfn_38>:
84201c64:	90 24       	Null = r0 - 2;
84201c66:	05 6a       	if GT jump (m) Lc__FLE_addfn_41;

84201c68 <Lc__FLE_addfn_39>:
84201c68:	90 24       	Null = r0 - 2;
84201c6a:	16 62       	if NE jump (m) Lc__FLE_addfn_45;

84201c6c <Lc__FLE_addfn_40>:
84201c6c:	1a c0       	r0 = r1 AND 0x1;
84201c6e:	14 60       	if EQ jump (m) Lc__FLE_addfn_45;

84201c70 <Lc__FLE_addfn_41>:
84201c70:	5b 20       	r1 = r1 + 1;
84201c72:	03 f0 c0 ff 	r0 = r1 AND 0x7f800000;
84201c76:	32 f0 00 00 
84201c7a:	00 f2 20 f0 	Null = r0 - 8388608;
84201c7e:	00 24 
84201c80:	09 f0 9b e0 	if LS jump (m) Lc__FLE_addfn_46;

84201c84 <Lc__FLE_addfn_42>:
84201c84:	64 20       	r2 = r2 + 1;
84201c86:	40 f0 ff 24 	Null = r2 - 255;
84201c8a:	05 62       	if NE jump (m) Lc__FLE_addfn_44;

84201c8c <Lc__FLE_addfn_43>:
84201c8c:	04 f0 fe 40 	r2 = Null + 254;
84201c90:	5b 24       	r1 = r1 - 1;
84201c92:	02 6e       	jump (m) Lc__FLE_addfn_45;

84201c94 <Lc__FLE_addfn_44>:
84201c94:	1b 50       	r1 = r1 LSHIFT -1;

84201c96 <Lc__FLE_addfn_45>:
84201c96:	18 04       	Null = r1 - Null;
84201c98:	16 60       	if EQ jump (m) Lc__FLE_addfn_53;

84201c9a <Lc__FLE_addfn_46>:
84201c9a:	20 24       	Null = r2 - 0;
84201c9c:	06 6a       	if GT jump (m) Lc__FLE_addfn_49;

84201c9e <Lc_1>:
84201c9e:	10 6e       	jump (m) Lc__FLE_addfn_51;

84201ca0 <Lc__FLE_addfn_47>:
84201ca0:	64 24       	r2 = r2 - 1;
84201ca2:	20 24       	Null = r2 - 0;
84201ca4:	0d 6c       	if LE jump (m) Lc__FLE_addfn_51;

84201ca6 <Lc__FLE_addfn_48>:
84201ca6:	1b 54       	r1 = r1 LSHIFT 1;

84201ca8 <Lc__FLE_addfn_49>:
84201ca8:	40 f0 32 f0 	r0 = r1 AND 0x800000;
84201cac:	00 00 
84201cae:	f9 61       	if EQ jump (m) Lc__FLE_addfn_47;

84201cb0 <Lc__FLE_addfn_50>:
84201cb0:	04 f0 3f f0 	r0 = r1 AND 0x807fffff;
84201cb4:	32 ff ff 1f 
84201cb8:	0b f4 d3 d8 	r1 = r2 LSHIFT 23;
84201cbc:	9b 12       	r1 = r1 OR r0;

84201cbe <Lc__FLE_addfn_51>:
84201cbe:	08 04       	Null = rMAC - Null;
84201cc0:	02 60       	if EQ jump (m) Lc__FLE_addfn_53;

84201cc2 <Lc__FLE_addfn_52>:
84201cc2:	db cf       	r1 = r1 OR 0x80000000;

84201cc4 <Lc__FLE_addfn_53>:
84201cc4:	1b de       	M[FP + 12] = r1;
84201cc6:	02 6e       	jump (m) Lc__FLE_addfn_55;

84201cc8 <Lc__FLE_addfn_54>:
84201cc8:	1b de       	M[FP + 12] = r1;

84201cca <Lc__FLE_addfn_55>:
84201cca:	1a d8       	r0 = M[FP + 12];

84201ccc <Lc__FLE_addfn_56>:
84201ccc:	72 49       	SP = SP - 0x10, popm <FP, r4, r5>;
84201cce:	d8 4c       	rts;

84201cd0 <$__FLE_ceqf>:
84201cd0:	01 00       	rMAC = Null + Null;
84201cd2:	d4 c7       	r2 = r0 AND 0x80000000;
84201cd4:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201cd8:	94 c7       	r2 = r0 AND 0x7fffffff;
84201cda:	03 f0 c0 ff 	r0 = r2 AND 0x7f800000;
84201cde:	42 f0 00 00 
84201ce2:	1f f0 00 fe 	Null = r0 - 2139095040;
84201ce6:	20 f0 00 24 
84201cea:	06 62       	if NE jump (m) Lc__FLE_ceqf_3;

84201cec <Lc__FLE_ceqf_2>:
84201cec:	1f f0 00 fe 	Null = r2 - 2139095040;
84201cf0:	40 f0 00 24 
84201cf4:	1c 62       	if NE jump (m) Lc__FLE_ceqf_9;

84201cf6 <Lc__FLE_ceqf_3>:
84201cf6:	02 00       	r0 = Null + Null;
84201cf8:	dd c7       	r3 = r1 AND 0x80000000;
84201cfa:	21 f0 42 ce 	if NE r0 = Null + 1;
84201cfe:	9b c7       	r1 = r1 AND 0x7fffffff;
84201d00:	03 f0 c0 ff 	r3 = r1 AND 0x7f800000;
84201d04:	35 f0 00 00 
84201d08:	1f f0 00 fe 	Null = r3 - 2139095040;
84201d0c:	50 f0 00 24 
84201d10:	06 62       	if NE jump (m) Lc__FLE_ceqf_5;

84201d12 <Lc__FLE_ceqf_4>:
84201d12:	1f f0 00 fe 	Null = r1 - 2139095040;
84201d16:	30 f0 00 24 
84201d1a:	09 62       	if NE jump (m) Lc__FLE_ceqf_9;

84201d1c <Lc__FLE_ceqf_5>:
84201d1c:	e0 04       	Null = r2 - r1;
84201d1e:	07 62       	if NE jump (m) Lc__FLE_ceqf_9;

84201d20 <Lc__FLE_ceqf_6>:
84201d20:	88 04       	Null = rMAC - r0;
84201d22:	03 60       	if EQ jump (m) Lc__FLE_ceqf_8;

84201d24 <Lc__FLE_ceqf_7>:
84201d24:	20 04       	Null = r2 - Null;
84201d26:	03 62       	if NE jump (m) Lc__FLE_ceqf_9;

84201d28 <Lc__FLE_ceqf_8>:
84201d28:	42 20       	r0 = Null + 1;
84201d2a:	02 6e       	jump (m) Lc__FLE_ceqf_10;

84201d2c <Lc__FLE_ceqf_9>:
84201d2c:	02 00       	r0 = Null + Null;

84201d2e <Lc__FLE_ceqf_10>:
84201d2e:	d8 4c       	rts;

84201d30 <$__FLE_cgef>:
84201d30:	01 00       	rMAC = Null + Null;
84201d32:	d4 c7       	r2 = r0 AND 0x80000000;
84201d34:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201d38:	94 c7       	r2 = r0 AND 0x7fffffff;
84201d3a:	03 f0 c0 ff 	r0 = r2 AND 0x7f800000;
84201d3e:	42 f0 00 00 
84201d42:	1f f0 00 fe 	Null = r0 - 2139095040;
84201d46:	20 f0 00 24 
84201d4a:	06 62       	if NE jump (m) Lc__FLE_cgef_3;

84201d4c <Lc__FLE_cgef_2>:
84201d4c:	1f f0 00 fe 	Null = r2 - 2139095040;
84201d50:	40 f0 00 24 
84201d54:	14 62       	if NE jump (m) Lc__FLE_cgef_5;

84201d56 <Lc__FLE_cgef_3>:
84201d56:	02 00       	r0 = Null + Null;
84201d58:	dd c7       	r3 = r1 AND 0x80000000;
84201d5a:	21 f0 42 ce 	if NE r0 = Null + 1;
84201d5e:	9b c7       	r1 = r1 AND 0x7fffffff;
84201d60:	03 f0 c0 ff 	r3 = r1 AND 0x7f800000;
84201d64:	35 f0 00 00 
84201d68:	1f f0 00 fe 	Null = r3 - 2139095040;
84201d6c:	50 f0 00 24 
84201d70:	08 62       	if NE jump (m) Lc__FLE_cgef_6;

84201d72 <Lc__FLE_cgef_4>:
84201d72:	1f f0 00 fe 	Null = r1 - 2139095040;
84201d76:	30 f0 00 24 
84201d7a:	03 60       	if EQ jump (m) Lc__FLE_cgef_6;

84201d7c <Lc__FLE_cgef_5>:
84201d7c:	02 00       	r0 = Null + Null;
84201d7e:	17 6e       	jump (m) Lc__FLE_cgef_13;

84201d80 <Lc__FLE_cgef_6>:
84201d80:	10 04       	Null = r0 - Null;
84201d82:	0a 60       	if EQ jump (m) Lc__FLE_cgef_10;

84201d84 <Lc__FLE_cgef_7>:
84201d84:	08 04       	Null = rMAC - Null;
84201d86:	03 62       	if NE jump (m) Lc__FLE_cgef_9;

84201d88 <Lc__FLE_cgef_8>:
84201d88:	42 20       	r0 = Null + 1;
84201d8a:	11 6e       	jump (m) Lc__FLE_cgef_13;

84201d8c <Lc__FLE_cgef_9>:
84201d8c:	02 00       	r0 = Null + Null;
84201d8e:	18 05       	Null = r1 - r2;
84201d90:	22 f0 42 ce 	if C r0 = Null + 1;
84201d94:	0c 6e       	jump (m) Lc__FLE_cgef_13;

84201d96 <Lc__FLE_cgef_10>:
84201d96:	08 04       	Null = rMAC - Null;
84201d98:	06 60       	if EQ jump (m) Lc__FLE_cgef_12;

84201d9a <Lc__FLE_cgef_11>:
84201d9a:	02 00       	r0 = Null + Null;
84201d9c:	19 13       	rMAC = r1 OR r2;
84201d9e:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201da2:	05 6e       	jump (m) Lc__FLE_cgef_13;

84201da4 <Lc__FLE_cgef_12>:
84201da4:	02 00       	r0 = Null + Null;
84201da6:	e0 04       	Null = r2 - r1;
84201da8:	22 f0 42 ce 	if C r0 = Null + 1;

84201dac <Lc__FLE_cgef_13>:
84201dac:	d8 4c       	rts;

84201dae <$__FLE_clef>:
84201dae:	01 00       	rMAC = Null + Null;
84201db0:	dc c7       	r2 = r1 AND 0x80000000;
84201db2:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201db6:	9c c7       	r2 = r1 AND 0x7fffffff;
84201db8:	03 f0 c0 ff 	r1 = r2 AND 0x7f800000;
84201dbc:	43 f0 00 00 
84201dc0:	1f f0 00 fe 	Null = r1 - 2139095040;
84201dc4:	30 f0 00 24 
84201dc8:	06 62       	if NE jump (m) Lc__FLE_clef_3;

84201dca <Lc__FLE_clef_2>:
84201dca:	1f f0 00 fe 	Null = r2 - 2139095040;
84201dce:	40 f0 00 24 
84201dd2:	14 62       	if NE jump (m) Lc__FLE_clef_5;

84201dd4 <Lc__FLE_clef_3>:
84201dd4:	03 00       	r1 = Null + Null;
84201dd6:	d5 c7       	r3 = r0 AND 0x80000000;
84201dd8:	21 f0 43 ce 	if NE r1 = Null + 1;
84201ddc:	95 c7       	r3 = r0 AND 0x7fffffff;
84201dde:	03 f0 c0 ff 	r0 = r3 AND 0x7f800000;
84201de2:	52 f0 00 00 
84201de6:	1f f0 00 fe 	Null = r0 - 2139095040;
84201dea:	20 f0 00 24 
84201dee:	08 62       	if NE jump (m) Lc__FLE_clef_6;

84201df0 <Lc__FLE_clef_4>:
84201df0:	1f f0 00 fe 	Null = r3 - 2139095040;
84201df4:	50 f0 00 24 
84201df8:	03 60       	if EQ jump (m) Lc__FLE_clef_6;

84201dfa <Lc__FLE_clef_5>:
84201dfa:	02 00       	r0 = Null + Null;
84201dfc:	17 6e       	jump (m) Lc__FLE_clef_13;

84201dfe <Lc__FLE_clef_6>:
84201dfe:	18 04       	Null = r1 - Null;
84201e00:	0a 60       	if EQ jump (m) Lc__FLE_clef_10;

84201e02 <Lc__FLE_clef_7>:
84201e02:	08 04       	Null = rMAC - Null;
84201e04:	03 62       	if NE jump (m) Lc__FLE_clef_9;

84201e06 <Lc__FLE_clef_8>:
84201e06:	42 20       	r0 = Null + 1;
84201e08:	11 6e       	jump (m) Lc__FLE_clef_13;

84201e0a <Lc__FLE_clef_9>:
84201e0a:	02 00       	r0 = Null + Null;
84201e0c:	28 05       	Null = r3 - r2;
84201e0e:	22 f0 42 ce 	if C r0 = Null + 1;
84201e12:	0c 6e       	jump (m) Lc__FLE_clef_13;

84201e14 <Lc__FLE_clef_10>:
84201e14:	08 04       	Null = rMAC - Null;
84201e16:	06 60       	if EQ jump (m) Lc__FLE_clef_12;

84201e18 <Lc__FLE_clef_11>:
84201e18:	02 00       	r0 = Null + Null;
84201e1a:	29 13       	rMAC = r3 OR r2;
84201e1c:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201e20:	05 6e       	jump (m) Lc__FLE_clef_13;

84201e22 <Lc__FLE_clef_12>:
84201e22:	02 00       	r0 = Null + Null;
84201e24:	60 05       	Null = r2 - r3;
84201e26:	22 f0 42 ce 	if C r0 = Null + 1;

84201e2a <Lc__FLE_clef_13>:
84201e2a:	d8 4c       	rts;

84201e2c <$__FLE_cltd>:
84201e2c:	74 1c       	pushm <FP(=SP), r4, r5, r6, r7>;
84201e2e:	2e 00       	r4 = r3 + Null;
84201e30:	01 00       	rMAC = Null + Null;
84201e32:	f7 c7       	r5 = r4 AND 0x80000000;
84201e34:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201e38:	b7 c7       	r5 = r4 AND 0x7fffffff;
84201e3a:	7e c7       	r4 = r5 AND 0x7ff00000;
84201e3c:	1f f0 c0 ff 	Null = r4 - 2146435072;
84201e40:	60 f0 00 24 
84201e44:	08 62       	if NE jump (m) Lc__FLE_cltd_4;

84201e46 <Lc__FLE_cltd_2>:
84201e46:	1f f0 c0 ff 	Null = r5 - 2146435072;
84201e4a:	70 f0 00 24 
84201e4e:	4a 62       	if NE jump (m) Lc__FLE_cltd_23;

84201e50 <Lc__FLE_cltd_3>:
84201e50:	26 00       	r4 = r2 + Null;
84201e52:	48 62       	if NE jump (m) Lc__FLE_cltd_23;

84201e54 <Lc__FLE_cltd_4>:
84201e54:	18 09       	r6 = r1 + Null;
84201e56:	06 00       	r4 = Null + Null;
84201e58:	04 f0 00 f0 	r7 = r6 AND 0x80000000;
84201e5c:	89 f0 00 00 
84201e60:	21 f0 46 ce 	if NE r4 = Null + 1;
84201e64:	03 f0 ff ff 	r6 = r6 AND 0x7fffffff;
84201e68:	88 ff ff 1f 
84201e6c:	03 f0 f8 ff 	r7 = r6 AND 0x7ff00000;
84201e70:	89 f0 00 00 
84201e74:	1f f0 c0 ff 	Null = r7 - 2146435072;
84201e78:	90 f0 00 24 
84201e7c:	08 62       	if NE jump (m) Lc__FLE_cltd_7;

84201e7e <Lc__FLE_cltd_5>:
84201e7e:	1f f0 c0 ff 	Null = r6 - 2146435072;
84201e82:	80 f0 00 24 
84201e86:	2e 62       	if NE jump (m) Lc__FLE_cltd_23;

84201e88 <Lc__FLE_cltd_6>:
84201e88:	11 09       	r7 = r0 + Null;
84201e8a:	2c 62       	if NE jump (m) Lc__FLE_cltd_23;

84201e8c <Lc__FLE_cltd_7>:
84201e8c:	30 04       	Null = r4 - Null;
84201e8e:	1b 60       	if EQ jump (m) Lc__FLE_cltd_18;

84201e90 <Lc__FLE_cltd_8>:
84201e90:	08 04       	Null = rMAC - Null;
84201e92:	0f 60       	if EQ jump (m) Lc__FLE_cltd_14;

84201e94 <Lc__FLE_cltd_9>:
84201e94:	7f f8 00 c2 	Null = r6 - r5;
84201e98:	25 64       	if NC jump (m) Lc__FLE_cltd_23;

84201e9a <Lc__FLE_cltd_10>:
84201e9a:	7f f8 00 c2 	Null = r6 - r5;
84201e9e:	08 f0 8f e0 	if HI jump (m) Lc__FLE_cltd_12;

84201ea2 <Lc__FLE_cltd_11>:
84201ea2:	11 00       	rMAC = r0 + Null;
84201ea4:	22 00       	r0 = r2 + Null;
84201ea6:	88 04       	Null = rMAC - r0;
84201ea8:	09 f0 b7 e0 	if LS jump (m) Lc__FLE_cltd_22;

84201eac <Lc__FLE_cltd_12>:
84201eac:	42 20       	r0 = Null + 1;

84201eae <Lc__FLE_cltd_13>:
84201eae:	1b 6e       	jump (m) Lc__FLE_cltd_24;

84201eb0 <Lc__FLE_cltd_14>:
84201eb0:	21 00       	rMAC = r2 + Null;
84201eb2:	89 12       	rMAC = rMAC OR r0;
84201eb4:	00 f8 71 c8 	rMAC = rMAC OR r6;
84201eb8:	c9 13       	rMAC = rMAC OR r5;
84201eba:	03 60       	if EQ jump (m) Lc__FLE_cltd_16;

84201ebc <Lc__FLE_cltd_15>:
84201ebc:	42 20       	r0 = Null + 1;
84201ebe:	02 6e       	jump (m) Lc__FLE_cltd_17;

84201ec0 <Lc__FLE_cltd_16>:
84201ec0:	02 00       	r0 = Null + Null;

84201ec2 <Lc__FLE_cltd_17>:
84201ec2:	11 6e       	jump (m) Lc__FLE_cltd_24;

84201ec4 <Lc__FLE_cltd_18>:
84201ec4:	08 04       	Null = rMAC - Null;
84201ec6:	0e 62       	if NE jump (m) Lc__FLE_cltd_23;

84201ec8 <Lc__FLE_cltd_19>:
84201ec8:	8f f7 00 c2 	Null = r5 - r6;
84201ecc:	0b 64       	if NC jump (m) Lc__FLE_cltd_23;

84201ece <Lc__FLE_cltd_20>:
84201ece:	8f f7 00 c2 	Null = r5 - r6;
84201ed2:	f8 ff db ef 	if HI jump (m) Lc__FLE_cltd_12;

84201ed6 <Lc__FLE_cltd_21>:
84201ed6:	21 00       	rMAC = r2 + Null;
84201ed8:	88 04       	Null = rMAC - r0;
84201eda:	f8 ff d3 ef 	if HI jump (m) Lc__FLE_cltd_12;

84201ede <Lc__FLE_cltd_22>:
84201ede:	02 00       	r0 = Null + Null;
84201ee0:	e7 6f       	jump (m) Lc__FLE_cltd_13;

84201ee2 <Lc__FLE_cltd_23>:
84201ee2:	02 00       	r0 = Null + Null;

84201ee4 <Lc__FLE_cltd_24>:
84201ee4:	74 48       	popm <FP, r4, r5, r6, r7>;
84201ee6:	d8 4c       	rts;

84201ee8 <$__FLE_cltf>:
84201ee8:	01 00       	rMAC = Null + Null;
84201eea:	dc c7       	r2 = r1 AND 0x80000000;
84201eec:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201ef0:	9c c7       	r2 = r1 AND 0x7fffffff;
84201ef2:	03 f0 c0 ff 	r1 = r2 AND 0x7f800000;
84201ef6:	43 f0 00 00 
84201efa:	1f f0 00 fe 	Null = r1 - 2139095040;
84201efe:	30 f0 00 24 
84201f02:	06 62       	if NE jump (m) Lc__FLE_cltf_3;

84201f04 <Lc__FLE_cltf_2>:
84201f04:	1f f0 00 fe 	Null = r2 - 2139095040;
84201f08:	40 f0 00 24 
84201f0c:	24 62       	if NE jump (m) Lc__FLE_cltf_10;

84201f0e <Lc__FLE_cltf_3>:
84201f0e:	03 00       	r1 = Null + Null;
84201f10:	d5 c7       	r3 = r0 AND 0x80000000;
84201f12:	21 f0 43 ce 	if NE r1 = Null + 1;
84201f16:	95 c7       	r3 = r0 AND 0x7fffffff;
84201f18:	03 f0 c0 ff 	r0 = r3 AND 0x7f800000;
84201f1c:	52 f0 00 00 
84201f20:	1f f0 00 fe 	Null = r0 - 2139095040;
84201f24:	20 f0 00 24 
84201f28:	06 62       	if NE jump (m) Lc__FLE_cltf_5;

84201f2a <Lc__FLE_cltf_4>:
84201f2a:	1f f0 00 fe 	Null = r3 - 2139095040;
84201f2e:	50 f0 00 24 
84201f32:	11 62       	if NE jump (m) Lc__FLE_cltf_10;

84201f34 <Lc__FLE_cltf_5>:
84201f34:	18 04       	Null = r1 - Null;
84201f36:	0d 60       	if EQ jump (m) Lc__FLE_cltf_9;

84201f38 <Lc__FLE_cltf_6>:
84201f38:	08 04       	Null = rMAC - Null;
84201f3a:	06 62       	if NE jump (m) Lc__FLE_cltf_8;

84201f3c <Lc__FLE_cltf_7>:
84201f3c:	02 00       	r0 = Null + Null;
84201f3e:	29 13       	rMAC = r3 OR r2;
84201f40:	21 f0 42 ce 	if NE r0 = Null + 1;
84201f44:	0e 6e       	jump (m) Lc__FLE_cltf_12;

84201f46 <Lc__FLE_cltf_8>:
84201f46:	02 00       	r0 = Null + Null;
84201f48:	28 05       	Null = r3 - r2;
84201f4a:	28 f0 42 ce 	if HI r0 = Null + 1;
84201f4e:	09 6e       	jump (m) Lc__FLE_cltf_12;

84201f50 <Lc__FLE_cltf_9>:
84201f50:	08 04       	Null = rMAC - Null;
84201f52:	03 60       	if EQ jump (m) Lc__FLE_cltf_11;

84201f54 <Lc__FLE_cltf_10>:
84201f54:	02 00       	r0 = Null + Null;
84201f56:	05 6e       	jump (m) Lc__FLE_cltf_12;

84201f58 <Lc__FLE_cltf_11>:
84201f58:	02 00       	r0 = Null + Null;
84201f5a:	60 05       	Null = r2 - r3;
84201f5c:	28 f0 42 ce 	if HI r0 = Null + 1;

84201f60 <Lc__FLE_cltf_12>:
84201f60:	d8 4c       	rts;

84201f62 <$__FLE_cnef>:
84201f62:	01 00       	rMAC = Null + Null;
84201f64:	d4 c7       	r2 = r0 AND 0x80000000;
84201f66:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201f6a:	94 c7       	r2 = r0 AND 0x7fffffff;
84201f6c:	03 f0 c0 ff 	r0 = r2 AND 0x7f800000;
84201f70:	42 f0 00 00 
84201f74:	1f f0 00 fe 	Null = r0 - 2139095040;
84201f78:	20 f0 00 24 
84201f7c:	06 62       	if NE jump (m) Lc__FLE_cnef_3;

84201f7e <Lc__FLE_cnef_2>:
84201f7e:	1f f0 00 fe 	Null = r2 - 2139095040;
84201f82:	40 f0 00 24 
84201f86:	1c 62       	if NE jump (m) Lc__FLE_cnef_9;

84201f88 <Lc__FLE_cnef_3>:
84201f88:	02 00       	r0 = Null + Null;
84201f8a:	dd c7       	r3 = r1 AND 0x80000000;
84201f8c:	21 f0 42 ce 	if NE r0 = Null + 1;
84201f90:	9b c7       	r1 = r1 AND 0x7fffffff;
84201f92:	03 f0 c0 ff 	r3 = r1 AND 0x7f800000;
84201f96:	35 f0 00 00 
84201f9a:	1f f0 00 fe 	Null = r3 - 2139095040;
84201f9e:	50 f0 00 24 
84201fa2:	06 62       	if NE jump (m) Lc__FLE_cnef_5;

84201fa4 <Lc__FLE_cnef_4>:
84201fa4:	1f f0 00 fe 	Null = r1 - 2139095040;
84201fa8:	30 f0 00 24 
84201fac:	09 62       	if NE jump (m) Lc__FLE_cnef_9;

84201fae <Lc__FLE_cnef_5>:
84201fae:	e0 04       	Null = r2 - r1;
84201fb0:	07 62       	if NE jump (m) Lc__FLE_cnef_9;

84201fb2 <Lc__FLE_cnef_6>:
84201fb2:	88 04       	Null = rMAC - r0;
84201fb4:	03 60       	if EQ jump (m) Lc__FLE_cnef_8;

84201fb6 <Lc__FLE_cnef_7>:
84201fb6:	20 04       	Null = r2 - Null;
84201fb8:	03 62       	if NE jump (m) Lc__FLE_cnef_9;

84201fba <Lc__FLE_cnef_8>:
84201fba:	02 00       	r0 = Null + Null;
84201fbc:	02 6e       	jump (m) Lc__FLE_cnef_10;

84201fbe <Lc__FLE_cnef_9>:
84201fbe:	42 20       	r0 = Null + 1;

84201fc0 <Lc__FLE_cnef_10>:
84201fc0:	d8 4c       	rts;

84201fc2 <$__FLE_d2fn>:
84201fc2:	71 1d       	pushm <FP(=SP), r4>, SP = SP + 0x10;
84201fc4:	1c 00       	r2 = r1 + Null;
84201fc6:	05 00       	r3 = Null + Null;
84201fc8:	00 f8 01 f0 	rMAC = Null + -2147483648;
84201fcc:	00 40 
84201fce:	26 00       	r4 = r2 + Null;
84201fd0:	f4 c7       	r2 = r4 AND 0x80000000;
84201fd2:	00 f0 01 c0 	if EQ rMAC = Null + Null;
84201fd6:	f4 52       	r2 = r4 LSHIFT -20;
84201fd8:	24 c5       	r2 = r2 AND 0x7ff;
84201fda:	25 00       	r3 = r2 + Null;
84201fdc:	15 de       	M[FP + 8] = r3;
84201fde:	80 60       	if EQ jump (m) Lc__FLE_d2fn_27;

84201fe0 <Lc__FLE_d2fn_2>:
84201fe0:	35 c7       	r3 = r4 AND 0xfffff;
84201fe2:	40 f0 ff 2f 	Null = r2 - 2047;
84201fe6:	11 62       	if NE jump (m) Lc__FLE_d2fn_6;

84201fe8 <Lc__FLE_d2fn_3>:
84201fe8:	13 00       	r1 = r0 + Null;
84201fea:	ad 54       	r3 = r3 LSHIFT 3;
84201fec:	71 f3 d2 d8 	r0 = r1 LSHIFT -29;
84201ff0:	04 f0 ff 40 	r2 = Null + 255;
84201ff4:	52 13       	r0 = r0 OR r3;
84201ff6:	12 de       	M[FP + 8] = r0;
84201ff8:	71 62       	if NE jump (m) Lc__FLE_d2fn_26;

84201ffa <Lc__FLE_d2fn_4>:
84201ffa:	18 04       	Null = r1 - Null;
84201ffc:	6f 60       	if EQ jump (m) Lc__FLE_d2fn_26;

84201ffe <Lc__FLE_d2fn_5>:
84201ffe:	07 f0 02 f0 	r0 = Null + 7340032;
84202002:	00 40 
84202004:	12 de       	M[FP + 8] = r0;
84202006:	6a 6e       	jump (m) Lc__FLE_d2fn_26;

84202008 <Lc__FLE_d2fn_6>:
84202008:	f4 f7 80 7c 	r2 = r2 + -896;
8420200c:	40 f0 ff 24 	Null = r2 - 255;
84202010:	05 68       	if LT jump (m) Lc__FLE_d2fn_8;

84202012 <Lc__FLE_d2fn_7>:
84202012:	04 f0 ff 40 	r2 = Null + 255;
84202016:	10 de       	M[FP + 8] = Null;
84202018:	61 6e       	jump (m) Lc__FLE_d2fn_26;

8420201a <Lc__FLE_d2fn_8>:
8420201a:	20 24       	Null = r2 - 0;
8420201c:	2e 6c       	if LE jump (m) Lc__FLE_d2fn_16;

8420201e <Lc__FLE_d2fn_9>:
8420201e:	71 f2 d3 d8 	r1 = r0 LSHIFT -29;
84202022:	ad 54       	r3 = r3 LSHIFT 3;
84202024:	5b 13       	r1 = r1 OR r3;
84202026:	92 54       	r0 = r0 LSHIFT 3;
84202028:	13 de       	M[FP + 8] = r1;
8420202a:	05 00       	r3 = Null + Null;
8420202c:	96 54       	r4 = r0 LSHIFT 3;
8420202e:	21 f0 45 ce 	if NE r3 = Null + 1;
84202032:	71 f2 d2 d8 	r0 = r0 LSHIFT -29;
84202036:	52 13       	r0 = r0 OR r3;
84202038:	10 25       	Null = r0 - 4;
8420203a:	08 f0 93 e0 	if HI jump (m) Lc__FLE_d2fn_11;

8420203e <Lc__FLE_d2fn_10>:
8420203e:	05 00       	r3 = Null + Null;
84202040:	10 25       	Null = r0 - 4;
84202042:	20 f0 45 ce 	if EQ r3 = Null + 1;
84202046:	ed 10       	r3 = r3 AND r1;
84202048:	2d c0       	r3 = r3 AND 0x1;
8420204a:	48 60       	if EQ jump (m) Lc__FLE_d2fn_26;

8420204c <Lc__FLE_d2fn_11>:
8420204c:	5b 20       	r1 = r1 + 1;
8420204e:	13 de       	M[FP + 8] = r1;
84202050:	40 f0 35 f0 	r3 = r1 AND 0x800000;
84202054:	00 00 
84202056:	42 60       	if EQ jump (m) Lc__FLE_d2fn_26;

84202058 <Lc__FLE_d2fn_12>:
84202058:	64 20       	r2 = r2 + 1;
8420205a:	40 f0 ff 24 	Null = r2 - 255;
8420205e:	07 62       	if NE jump (m) Lc__FLE_d2fn_15;

84202060 <Lc__FLE_d2fn_13>:
84202060:	10 25       	Null = r0 - 4;
84202062:	05 62       	if NE jump (m) Lc__FLE_d2fn_15;

84202064 <Lc__FLE_d2fn_14>:
84202064:	5a 24       	r0 = r1 - 1;
84202066:	04 f0 fe 40 	r2 = Null + 254;
8420206a:	12 de       	M[FP + 8] = r0;

8420206c <Lc__FLE_d2fn_15>:
8420206c:	12 d8       	r0 = M[FP + 8];
8420206e:	3f f0 22 ff 	r0 = r0 AND 0x7fffff;
84202072:	ff 1f 
84202074:	12 de       	M[FP + 8] = r0;
84202076:	32 6e       	jump (m) Lc__FLE_d2fn_26;

84202078 <Lc__FLE_d2fn_16>:
84202078:	01 f0 00 f0 	r3 = r3 OR 0x100000;
8420207c:	00 f5 55 c8 
84202080:	71 f2 d3 c8 	r1 = r0 LSHIFT -30;
84202084:	6d 54       	r3 = r3 LSHIFT 2;
84202086:	5b 13       	r1 = r1 OR r3;
84202088:	52 54       	r0 = r0 LSHIFT 2;
8420208a:	13 de       	M[FP + 8] = r1;
8420208c:	05 00       	r3 = Null + Null;
8420208e:	56 54       	r4 = r0 LSHIFT 2;
84202090:	21 f0 45 ce 	if NE r3 = Null + 1;
84202094:	71 f2 d2 c8 	r0 = r0 LSHIFT -30;
84202098:	52 13       	r0 = r0 OR r3;
8420209a:	20 04       	Null = r2 - Null;
8420209c:	05 f0 a7 e0 	if POS jump (m) Lc__FLE_d2fn_22;

842020a0 <Lc__FLE_d2fn_17>:
842020a0:	64 20       	r2 = r2 + 1;
842020a2:	05 00       	r3 = Null + Null;
842020a4:	10 04       	Null = r0 - Null;
842020a6:	21 f0 45 ce 	if NE r3 = Null + 1;
842020aa:	1a c0       	r0 = r1 AND 0x1;
842020ac:	12 54       	r0 = r0 LSHIFT 1;
842020ae:	52 13       	r0 = r0 OR r3;
842020b0:	1b 50       	r1 = r1 LSHIFT -1;
842020b2:	04 62       	if NE jump (m) Lc__FLE_d2fn_20;

842020b4 <Lc__FLE_d2fn_19>:
842020b4:	90 24       	Null = r0 - 2;
842020b6:	09 f0 8b e0 	if LS jump (m) Lc__FLE_d2fn_21;

842020ba <Lc__FLE_d2fn_20>:
842020ba:	20 04       	Null = r2 - Null;
842020bc:	f4 ff e5 ef 	if NEG jump (m) Lc__FLE_d2fn_17;

842020c0 <Lc__FLE_d2fn_21>:
842020c0:	13 de       	M[FP + 8] = r1;

842020c2 <Lc__FLE_d2fn_22>:
842020c2:	04 00       	r2 = Null + Null;
842020c4:	90 24       	Null = r0 - 2;
842020c6:	08 f0 8f e0 	if HI jump (m) Lc__FLE_d2fn_25;

842020ca <Lc__FLE_d2fn_23>:
842020ca:	90 24       	Null = r0 - 2;
842020cc:	07 62       	if NE jump (m) Lc__FLE_d2fn_26;

842020ce <Lc__FLE_d2fn_24>:
842020ce:	12 d8       	r0 = M[FP + 8];
842020d0:	12 c0       	r0 = r0 AND 0x1;
842020d2:	04 60       	if EQ jump (m) Lc__FLE_d2fn_26;

842020d4 <Lc__FLE_d2fn_25>:
842020d4:	12 d8       	r0 = M[FP + 8];
842020d6:	52 20       	r0 = r0 + 1;
842020d8:	12 de       	M[FP + 8] = r0;

842020da <Lc__FLE_d2fn_26>:
842020da:	0b f4 d4 d8 	r2 = r2 LSHIFT 23;

842020de <Lc__FLE_d2fn_27>:
842020de:	12 d8       	r0 = M[FP + 8];
842020e0:	12 13       	r0 = r0 OR r2;
842020e2:	52 12       	r0 = r0 OR rMAC;

842020e4 <Lc__FLE_d2fn_28>:
842020e4:	71 49       	SP = SP - 0x10, popm <FP, r4>;
842020e6:	d8 4c       	rts;

842020e8 <$__FLE_divfn>:
842020e8:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
842020ea:	9c 14       	r2 = r1 XOR r0;
842020ec:	74 f3 d5 d8 	r3 = r1 LSHIFT -23;
842020f0:	04 f0 00 f0 	r8 = r2 AND 0x80000000;
842020f4:	4a f0 00 00 
842020f8:	74 f2 d4 d8 	r2 = r0 LSHIFT -23;
842020fc:	19 00       	rMAC = r1 + Null;
842020fe:	ad c3       	r3 = r3 AND 0xff;
84202100:	a4 c3       	r2 = r2 AND 0xff;
84202102:	40 f0 ff 24 	Null = r2 - 255;
84202106:	17 62       	if NE jump (m) Lc__FLE_divfn_7;

84202108 <Lc__FLE_divfn_2>:
84202108:	3f f0 24 ff 	r2 = r0 AND 0x7fffff;
8420210c:	ff 1f 
8420210e:	03 60       	if EQ jump (m) Lc__FLE_divfn_4;

84202110 <Lc__FLE_divfn_3>:
84202110:	0f f0 ab e4 	jump (m) Lc__FLE_divfn_71;

84202114 <Lc__FLE_divfn_4>:
84202114:	50 f0 ff 24 	Null = r3 - 255;
84202118:	08 62       	if NE jump (m) Lc__FLE_divfn_6;

8420211a <Lc__FLE_divfn_5>:
8420211a:	3f f0 32 ff 	r0 = r1 AND 0x7fffff;
8420211e:	ff 1f 
84202120:	01 f0 97 e4 	if NE jump (m) Lc__FLE_divfn_69;

84202124 <Lc_1>:
84202124:	0f f0 8d e4 	jump (m) Lc__FLE_divfn_68;

84202128 <Lc__FLE_divfn_6>:
84202128:	91 c7       	rMAC = r0 AND 0x7fffffff;
8420212a:	00 fa b1 c8 	rMAC = rMAC XOR r8;
8420212e:	41 de       	M[FP + 32] = rMAC;
84202130:	0f f0 89 e4 	jump (m) Lc__FLE_divfn_70;

84202134 <Lc__FLE_divfn_7>:
84202134:	50 f0 ff 24 	Null = r3 - 255;
84202138:	07 62       	if NE jump (m) Lc__FLE_divfn_10;

8420213a <Lc__FLE_divfn_8>:
8420213a:	3f f0 31 ff 	rMAC = r1 AND 0x7fffff;
8420213e:	ff 1f 
84202140:	14 60       	if EQ jump (m) Lc__FLE_divfn_14;

84202142 <Lc__FLE_divfn_9>:
84202142:	1a 00       	r0 = r1 + Null;
84202144:	fb 6e       	jump (m) Lc__FLE_divfn_71;

84202146 <Lc__FLE_divfn_10>:
84202146:	99 c7       	rMAC = r1 AND 0x7fffffff;
84202148:	ee 60       	if EQ jump (m) Lc__FLE_divfn_67;

8420214a <Lc__FLE_divfn_11>:
8420214a:	61 05       	rMAC = r2 - r3;
8420214c:	3f f0 22 ff 	r0 = r0 AND 0x7fffff;
84202150:	ff 1f 
84202152:	17 f0 7f 20 	r5 = rMAC + 127;
84202156:	20 04       	Null = r2 - Null;
84202158:	06 60       	if EQ jump (m) Lc__FLE_divfn_13;

8420215a <Lc__FLE_divfn_12>:
8420215a:	08 f0 00 f0 	r0 = r0 OR 0x800000;
8420215e:	00 f2 52 c8 
84202162:	0c 6e       	jump (m) Lc__FLE_divfn_16;

84202164 <Lc__FLE_divfn_13>:
84202164:	10 04       	Null = r0 - Null;
84202166:	04 62       	if NE jump (m) Lc__FLE_divfn_15;

84202168 <Lc__FLE_divfn_14>:
84202168:	ea f0 08 8e 	M[FP + 32] = r8;
8420216c:	e6 6e       	jump (m) Lc__FLE_divfn_70;

8420216e <Lc__FLE_divfn_15>:
8420216e:	12 54       	r0 = r0 LSHIFT 1;
84202170:	7f 24       	r5 = r5 - 1;
84202172:	40 f0 21 f0 	rMAC = r0 AND 0x800000;
84202176:	00 00 
84202178:	fb 61       	if EQ jump (m) Lc__FLE_divfn_15;

8420217a <Lc__FLE_divfn_16>:
8420217a:	3f f0 33 ff 	r1 = r1 AND 0x7fffff;
8420217e:	ff 1f 
84202180:	28 04       	Null = r3 - Null;
84202182:	06 60       	if EQ jump (m) Lc__FLE_divfn_18;

84202184 <Lc__FLE_divfn_17>:
84202184:	08 f0 00 f0 	r1 = r1 OR 0x800000;
84202188:	00 f3 53 c8 
8420218c:	07 6e       	jump (m) Lc__FLE_divfn_19;

8420218e <Lc__FLE_divfn_18>:
8420218e:	1b 54       	r1 = r1 LSHIFT 1;
84202190:	7f 20       	r5 = r5 + 1;
84202192:	40 f0 31 f0 	rMAC = r1 AND 0x800000;
84202196:	00 00 
84202198:	fb 61       	if EQ jump (m) Lc__FLE_divfn_18;

8420219a <Lc__FLE_divfn_19>:
8420219a:	92 55       	r0 = r0 LSHIFT 7;
8420219c:	94 52       	r2 = r0 LSHIFT -16;
8420219e:	94 dc       	MH[FP + 36] = r2;
842021a0:	9a dc       	MH[FP + 38] = r0;
842021a2:	db 55       	r1 = r1 LSHIFT 8;
842021a4:	d0 dc       	MH[FP + 52] = Null;
842021a6:	78 f3 d9 c8 	r7 = r1 LSHIFT -16;
842021aa:	e9 f0 1b 8c 	MH[FP + 54] = r7;
842021ae:	00 09       	r6 = Null + Null;
842021b0:	86 12       	r4 = FP + 40;
842021b2:	e3 dc       	MH[FP + 56] = r1;

842021b4 <Lc__FLE_divfn_20>:
842021b4:	30 ec       	MH[r4 + Null] = Null;
842021b6:	31 25       	rMAC = r4 - 4;
842021b8:	0a e6       	r0 = MHU[rMAC + Null];
842021ba:	9f f2 00 c2 	Null = r0 - r7;
842021be:	49 64       	if NC jump (m) Lc__FLE_divfn_40;

842021c0 <Lc__FLE_divfn_21>:
842021c0:	71 f0 ff 7b 	rMAC = Null + 65535;

842021c4 <Lc__FLE_divfn_22>:
842021c4:	1c 71       	r10 = Null + 3;
842021c6:	02 00       	r0 = Null + Null;
842021c8:	83 13       	r1 = FP + 56;
842021ca:	04 13       	r2 = FP + 48;
842021cc:	09 4c       	do (m) Lc__FLE_divfn_26;

842021ce <Lc__FLE_divfn_23>:
842021ce:	1d e6       	r3 = MHU[r1 + Null];
842021d0:	03 60       	if EQ jump (m) Lc__FLE_divfn_25;

842021d2 <Lc__FLE_divfn_24>:
842021d2:	6d 1a       	r3 = r3 * rMAC (int);
842021d4:	aa 00       	r0 = r3 + r0;

842021d6 <Lc__FLE_divfn_25>:
842021d6:	22 8c       	MH[r2 + 0] = r0;
842021d8:	9b 24       	r1 = r1 - 2;
842021da:	92 52       	r0 = r0 LSHIFT -16;
842021dc:	a4 24       	r2 = r2 - 2;

842021de <Lc__FLE_divfn_26>:
842021de:	1c 71       	r10 = Null + 3;
842021e0:	02 00       	r0 = Null + Null;
842021e2:	33 00       	r1 = r4 + Null;
842021e4:	04 13       	r2 = FP + 48;
842021e6:	09 4c       	do (m) Lc__FLE_divfn_28;

842021e8 <Lc__FLE_divfn_27>:
842021e8:	1d e6       	r3 = MHU[r1 + Null];
842021ea:	aa 00       	r0 = r3 + r0;
842021ec:	25 e6       	r3 = MHU[r2 + Null];
842021ee:	52 05       	r0 = r0 - r3;
842021f0:	1a 8c       	MH[r1 + 0] = r0;
842021f2:	a4 24       	r2 = r2 - 2;
842021f4:	92 5a       	r0 = r0 ASHIFT -16;
842021f6:	9b 24       	r1 = r1 - 2;

842021f8 <Lc__FLE_divfn_28>:
842021f8:	10 04       	Null = r0 - Null;
842021fa:	14 60       	if EQ jump (m) Lc__FLE_divfn_32;

842021fc <Lc__FLE_divfn_29>:
842021fc:	1c 71       	r10 = Null + 3;
842021fe:	02 00       	r0 = Null + Null;
84202200:	83 13       	r1 = FP + 56;
84202202:	34 00       	r2 = r4 + Null;
84202204:	0a 4c       	do (m) Lc__FLE_divfn_31;

84202206 <Lc__FLE_divfn_30>:
84202206:	25 e6       	r3 = MHU[r2 + Null];
84202208:	3b f0 00 e6 	r9 = MHU[r1 + Null];
8420220c:	5d 0c       	r3 = r9 + r3;
8420220e:	aa 00       	r0 = r3 + r0;
84202210:	22 8c       	MH[r2 + 0] = r0;
84202212:	9b 24       	r1 = r1 - 2;
84202214:	92 52       	r0 = r0 LSHIFT -16;
84202216:	a4 24       	r2 = r2 - 2;

84202218 <Lc__FLE_divfn_31>:
84202218:	71 f0 ff 7f 	rMAC = rMAC + 65535;
8420221c:	89 c6       	rMAC = rMAC AND 0xffff;
8420221e:	10 04       	Null = r0 - Null;
84202220:	ee 61       	if EQ jump (m) Lc__FLE_divfn_29;

84202222 <Lc__FLE_divfn_32>:
84202222:	61 f3 fe bd 	MH[r4 + -4] = rMAC;

84202226 <Lc__FLE_divfn_33>:
84202226:	08 75       	r6 = r6 + 1;
84202228:	b6 20       	r4 = r4 + 2;
8420222a:	80 f0 02 24 	Null = r6 - 2;
8420222e:	c3 69       	if LT jump (m) Lc__FLE_divfn_20;

84202230 <Lc__FLE_divfn_34>:
84202230:	92 d6       	r0 = MHU[FP + 36];
84202232:	99 d6       	rMAC = MHU[FP + 38];
84202234:	92 56       	r0 = r0 LSHIFT 16;
84202236:	52 12       	r0 = r0 OR rMAC;
84202238:	d1 c7       	rMAC = r0 AND 0x80000000;
8420223a:	03 62       	if NE jump (m) Lc__FLE_divfn_36;

8420223c <Lc__FLE_divfn_35>:
8420223c:	7f 24       	r5 = r5 - 1;
8420223e:	12 54       	r0 = r0 LSHIFT 1;

84202240 <Lc__FLE_divfn_36>:
84202240:	13 c0       	r1 = r0 AND 0x1;
84202242:	18 62       	if NE jump (m) Lc__FLE_divfn_45;

84202244 <Lc__FLE_divfn_37>:
84202244:	81 20       	rMAC = Null + 2;
84202246:	84 12       	r2 = FP + 40;

84202248 <Lc__FLE_divfn_38>:
84202248:	25 e6       	r3 = MHU[r2 + Null];
8420224a:	10 60       	if EQ jump (m) Lc__FLE_divfn_44;

8420224c <Lc__FLE_divfn_39>:
8420224c:	43 20       	r1 = Null + 1;
8420224e:	12 6e       	jump (m) Lc__FLE_divfn_45;

84202250 <Lc__FLE_divfn_40>:
84202250:	92 56       	r0 = r0 LSHIFT 16;
84202252:	49 86       	rMAC = MHU[rMAC + 2];
84202254:	52 12       	r0 = r0 OR rMAC;
84202256:	05 60       	if EQ jump (m) Lc__FLE_divfn_42;

84202258 <Lc__FLE_divfn_41>:
84202258:	4b 08       	r1 = r7 + Null;
8420225a:	ff fd a7 f0 	call (m) 0x171b8;
8420225e:	3f ea 

84202260 <Lc__FLE_divfn_42>:
84202260:	91 c6       	rMAC = r0 AND 0xffff;
84202262:	b1 63       	if NE jump (m) Lc__FLE_divfn_22;

84202264 <Lc__FLE_divfn_43>:
84202264:	60 f3 fe bd 	MH[r4 + -4] = Null;
84202268:	df 6f       	jump (m) Lc__FLE_divfn_33;

8420226a <Lc__FLE_divfn_44>:
8420226a:	49 20       	rMAC = rMAC + 1;
8420226c:	a4 20       	r2 = r2 + 2;
8420226e:	08 25       	Null = rMAC - 4;
84202270:	ec 69       	if LT jump (m) Lc__FLE_divfn_38;

84202272 <Lc__FLE_divfn_45>:
84202272:	01 00       	rMAC = Null + Null;
84202274:	14 c2       	r2 = r0 AND 0x1f;
84202276:	21 f0 41 ce 	if NE rMAC = Null + 1;
8420227a:	5b 12       	r1 = r1 OR rMAC;
8420227c:	12 51       	r0 = r0 LSHIFT -5;
8420227e:	38 24       	Null = r5 - 0;
84202280:	0a 6a       	if GT jump (m) Lc__FLE_divfn_50;

84202282 <Lc__FLE_divfn_46>:
84202282:	7f 24       	r5 = r5 - 1;

84202284 <Lc__FLE_divfn_47>:
84202284:	11 c0       	rMAC = r0 AND 0x1;
84202286:	5b 12       	r1 = r1 OR rMAC;
84202288:	12 50       	r0 = r0 LSHIFT -1;
8420228a:	03 62       	if NE jump (m) Lc__FLE_divfn_49;

8420228c <Lc__FLE_divfn_48>:
8420228c:	07 00       	r5 = Null + Null;
8420228e:	03 6e       	jump (m) Lc__FLE_divfn_50;

84202290 <Lc__FLE_divfn_49>:
84202290:	7f 20       	r5 = r5 + 1;
84202292:	f9 63       	if NE jump (m) Lc__FLE_divfn_47;

84202294 <Lc__FLE_divfn_50>:
84202294:	11 c1       	rMAC = r0 AND 0x7;
84202296:	5b 12       	r1 = r1 OR rMAC;
84202298:	92 50       	r0 = r0 LSHIFT -3;
8420229a:	38 04       	Null = r5 - Null;
8420229c:	0b 60       	if EQ jump (m) Lc__FLE_divfn_53;

8420229e <Lc__FLE_divfn_51>:
8420229e:	40 f0 21 f0 	rMAC = r0 AND 0x800000;
842022a2:	00 00 
842022a4:	07 62       	if NE jump (m) Lc__FLE_divfn_53;

842022a6 <Lc__FLE_divfn_52>:
842022a6:	12 54       	r0 = r0 LSHIFT 1;
842022a8:	5c 58       	r2 = r1 ASHIFT -2;
842022aa:	7f 24       	r5 = r5 - 1;
842022ac:	12 13       	r0 = r0 OR r2;
842022ae:	9b c0       	r1 = r1 AND 0x3;
842022b0:	04 6e       	jump (m) Lc__FLE_divfn_54;

842022b2 <Lc__FLE_divfn_53>:
842022b2:	19 c0       	rMAC = r1 AND 0x1;
842022b4:	1b 58       	r1 = r1 ASHIFT -1;
842022b6:	5b 12       	r1 = r1 OR rMAC;

842022b8 <Lc__FLE_divfn_54>:
842022b8:	98 24       	Null = r1 - 2;
842022ba:	05 6a       	if GT jump (m) Lc__FLE_divfn_57;

842022bc <Lc__FLE_divfn_55>:
842022bc:	98 24       	Null = r1 - 2;
842022be:	2c 62       	if NE jump (m) Lc__FLE_divfn_65;

842022c0 <Lc__FLE_divfn_56>:
842022c0:	11 c0       	rMAC = r0 AND 0x1;
842022c2:	2a 60       	if EQ jump (m) Lc__FLE_divfn_65;

842022c4 <Lc__FLE_divfn_57>:
842022c4:	52 20       	r0 = r0 + 1;
842022c6:	03 f0 c0 ff 	rMAC = r0 AND 0x7f800000;
842022ca:	21 f0 00 00 
842022ce:	00 f2 10 f0 	Null = rMAC - 8388608;
842022d2:	00 24 
842022d4:	09 f0 c3 e0 	if LS jump (m) Lc__FLE_divfn_65;

842022d8 <Lc__FLE_divfn_58>:
842022d8:	7f 20       	r5 = r5 + 1;
842022da:	70 f0 ff 24 	Null = r5 - 255;
842022de:	09 62       	if NE jump (m) Lc__FLE_divfn_60;

842022e0 <Lc__FLE_divfn_59>:
842022e0:	07 f0 fe 40 	r5 = Null + 254;
842022e4:	51 24       	rMAC = r0 - 1;
842022e6:	04 f0 3f f0 	r0 = rMAC AND 0x807fffff;
842022ea:	12 ff ff 1f 
842022ee:	0d 6e       	jump (m) Lc__FLE_divfn_64;

842022f0 <Lc__FLE_divfn_60>:
842022f0:	12 50       	r0 = r0 LSHIFT -1;

842022f2 <Lc__FLE_divfn_61>:
842022f2:	04 f0 3f f0 	r0 = r0 AND 0x807fffff;
842022f6:	22 ff ff 1f 
842022fa:	70 f0 ff 24 	Null = r5 - 255;
842022fe:	09 f0 9f e0 	if LS jump (m) Lc__FLE_divfn_66;

84202302 <Lc__FLE_divfn_62>:
84202302:	07 f0 ff 40 	r5 = Null + 255;

84202306 <Lc__FLE_divfn_63>:
84202306:	02 00       	r0 = Null + Null;

84202308 <Lc__FLE_divfn_64>:
84202308:	0b f7 d3 d8 	r1 = r5 LSHIFT 23;
8420230c:	af f3 41 c8 	rMAC = r1 OR r8;
84202310:	89 12       	rMAC = rMAC OR r0;
84202312:	41 de       	M[FP + 32] = rMAC;
84202314:	12 6e       	jump (m) Lc__FLE_divfn_70;

84202316 <Lc__FLE_divfn_65>:
84202316:	38 04       	Null = r5 - Null;
84202318:	ed 63       	if NE jump (m) Lc__FLE_divfn_61;

8420231a <Lc_2>:
8420231a:	f7 6f       	jump (m) Lc__FLE_divfn_64;

8420231c <Lc__FLE_divfn_66>:
8420231c:	70 f0 ff 24 	Null = r5 - 255;
84202320:	f3 61       	if EQ jump (m) Lc__FLE_divfn_63;

84202322 <Lc_3>:
84202322:	f3 6f       	jump (m) Lc__FLE_divfn_64;

84202324 <Lc__FLE_divfn_67>:
84202324:	f8 f7 00 f0 	rMAC = r8 OR 0x7f800000;
84202328:	00 fa 51 c8 
8420232c:	92 c7       	r0 = r0 AND 0x7fffffff;
8420232e:	04 62       	if NE jump (m) Lc__FLE_divfn_69;

84202330 <Lc__FLE_divfn_68>:
84202330:	ff f7 01 f0 	rMAC = Null + 2146435072;
84202334:	00 40 

84202336 <Lc__FLE_divfn_69>:
84202336:	41 de       	M[FP + 32] = rMAC;

84202338 <Lc__FLE_divfn_70>:
84202338:	42 d8       	r0 = M[FP + 32];

8420233a <Lc__FLE_divfn_71>:
8420233a:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420233c:	d8 4c       	rts;

8420233e <$__FLE_f2dn>:
8420233e:	48 1d       	pushm <FP(=SP)>, SP = SP + 0x10;
84202340:	00 f8 03 f0 	r1 = Null + -2147483648;
84202344:	00 40 
84202346:	d1 c7       	rMAC = r0 AND 0x80000000;
84202348:	00 f0 03 c0 	if EQ r1 = Null + Null;
8420234c:	74 f2 d4 d8 	r2 = r0 LSHIFT -23;
84202350:	13 de       	M[FP + 8] = r1;
84202352:	3f f0 22 ff 	r0 = r0 AND 0x7fffff;
84202356:	ff 1f 
84202358:	a1 c3       	rMAC = r2 AND 0xff;
8420235a:	0d 62       	if NE jump (m) Lc__FLE_f2dn_6;

8420235c <Lc__FLE_f2dn_2>:
8420235c:	10 04       	Null = r0 - Null;
8420235e:	03 62       	if NE jump (m) Lc__FLE_f2dn_4;

84202360 <Lc_1>:
84202360:	0a 6e       	jump (m) Lc__FLE_f2dn_6;

84202362 <Lc__FLE_f2dn_3>:
84202362:	49 24       	rMAC = rMAC - 1;

84202364 <Lc__FLE_f2dn_4>:
84202364:	12 54       	r0 = r0 LSHIFT 1;
84202366:	40 f0 24 f0 	r2 = r0 AND 0x800000;
8420236a:	00 00 
8420236c:	fb 61       	if EQ jump (m) Lc__FLE_f2dn_3;

8420236e <Lc__FLE_f2dn_5>:
8420236e:	3f f0 22 ff 	r0 = r0 AND 0x7fffff;
84202372:	ff 1f 

84202374 <Lc__FLE_f2dn_6>:
84202374:	0a de       	M[FP + 4] = r0;
84202376:	07 60       	if EQ jump (m) Lc__FLE_f2dn_8;

84202378 <Lc__FLE_f2dn_7>:
84202378:	0e f2 d4 d8 	r2 = r0 LSHIFT 29;
8420237c:	92 50       	r0 = r0 LSHIFT -3;
8420237e:	0c de       	M[FP + 4] = r2;
84202380:	d2 12       	r0 = r0 OR r1;
84202382:	12 de       	M[FP + 8] = r0;

84202384 <Lc__FLE_f2dn_8>:
84202384:	08 04       	Null = rMAC - Null;
84202386:	0a 60       	if EQ jump (m) Lc__FLE_f2dn_12;

84202388 <Lc__FLE_f2dn_9>:
84202388:	10 f0 ff 24 	Null = rMAC - 255;
8420238c:	04 60       	if EQ jump (m) Lc__FLE_f2dn_11;

8420238e <Lc__FLE_f2dn_10>:
8420238e:	12 f0 80 23 	r0 = rMAC + 896;
84202392:	05 6e       	jump (m) Lc__FLE_f2dn_13;

84202394 <Lc__FLE_f2dn_11>:
84202394:	02 f0 ff 4b 	r0 = Null + 2047;
84202398:	02 6e       	jump (m) Lc__FLE_f2dn_13;

8420239a <Lc__FLE_f2dn_12>:
8420239a:	02 00       	r0 = Null + Null;

8420239c <Lc__FLE_f2dn_13>:
8420239c:	11 d8       	rMAC = M[FP + 8];
8420239e:	d2 56       	r0 = r0 LSHIFT 20;
842023a0:	89 12       	rMAC = rMAC OR r0;
842023a2:	11 de       	M[FP + 8] = rMAC;
842023a4:	13 d8       	r1 = M[FP + 8];
842023a6:	0a d8       	r0 = M[FP + 4];

842023a8 <Lc__FLE_f2dn_14>:
842023a8:	48 49       	SP = SP - 0x10, popm <FP>;
842023aa:	d8 4c       	rts;

842023ac <$__FLE_mulfn>:
842023ac:	73 1d       	pushm <FP(=SP), r4, r5, r6>, SP = SP + 0x10;
842023ae:	14 00       	r2 = r0 + Null;
842023b0:	74 f4 d2 d8 	r0 = r2 LSHIFT -23;
842023b4:	19 15       	rMAC = r1 XOR r2;
842023b6:	95 c3       	r3 = r0 AND 0xff;
842023b8:	74 f3 d2 d8 	r0 = r1 LSHIFT -23;
842023bc:	c9 c7       	rMAC = rMAC AND 0x80000000;
842023be:	96 c3       	r4 = r0 AND 0xff;
842023c0:	50 f0 ff 24 	Null = r3 - 255;
842023c4:	17 62       	if NE jump (m) Lc__FLE_mulfn_9;

842023c6 <Lc__FLE_mulfn_2>:
842023c6:	3f f0 42 ff 	r0 = r2 AND 0x7fffff;
842023ca:	ff 1f 
842023cc:	03 60       	if EQ jump (m) Lc__FLE_mulfn_4;

842023ce <Lc__FLE_mulfn_3>:
842023ce:	22 00       	r0 = r2 + Null;
842023d0:	c8 6e       	jump (m) Lc__FLE_mulfn_54;

842023d2 <Lc__FLE_mulfn_4>:
842023d2:	60 f0 ff 24 	Null = r4 - 255;
842023d6:	05 62       	if NE jump (m) Lc__FLE_mulfn_6;

842023d8 <Lc__FLE_mulfn_5>:
842023d8:	3f f0 32 ff 	r0 = r1 AND 0x7fffff;
842023dc:	ff 1f 
842023de:	1a 62       	if NE jump (m) Lc__FLE_mulfn_14;

842023e0 <Lc__FLE_mulfn_6>:
842023e0:	a2 c7       	r0 = r2 AND 0x7fffffff;
842023e2:	89 14       	rMAC = rMAC XOR r0;
842023e4:	9a c7       	r0 = r1 AND 0x7fffffff;
842023e6:	04 62       	if NE jump (m) Lc__FLE_mulfn_8;

842023e8 <Lc__FLE_mulfn_7>:
842023e8:	ff f7 01 f0 	rMAC = Null + 2146435072;
842023ec:	00 40 

842023ee <Lc__FLE_mulfn_8>:
842023ee:	21 de       	M[FP + 16] = rMAC;
842023f0:	af 6e       	jump (m) Lc__FLE_mulfn_51;

842023f2 <Lc__FLE_mulfn_9>:
842023f2:	60 f0 ff 24 	Null = r4 - 255;
842023f6:	10 62       	if NE jump (m) Lc__FLE_mulfn_15;

842023f8 <Lc__FLE_mulfn_10>:
842023f8:	3f f0 32 ff 	r0 = r1 AND 0x7fffff;
842023fc:	ff 1f 
842023fe:	0a 62       	if NE jump (m) Lc__FLE_mulfn_14;

84202400 <Lc__FLE_mulfn_11>:
84202400:	9a c7       	r0 = r1 AND 0x7fffffff;
84202402:	89 14       	rMAC = rMAC XOR r0;
84202404:	a2 c7       	r0 = r2 AND 0x7fffffff;
84202406:	04 62       	if NE jump (m) Lc__FLE_mulfn_13;

84202408 <Lc__FLE_mulfn_12>:
84202408:	ff f7 01 f0 	rMAC = Null + 2146435072;
8420240c:	00 40 

8420240e <Lc__FLE_mulfn_13>:
8420240e:	21 de       	M[FP + 16] = rMAC;
84202410:	9f 6e       	jump (m) Lc__FLE_mulfn_51;

84202412 <Lc__FLE_mulfn_14>:
84202412:	1a 00       	r0 = r1 + Null;
84202414:	a6 6e       	jump (m) Lc__FLE_mulfn_54;

84202416 <Lc__FLE_mulfn_15>:
84202416:	72 01       	r0 = r4 + r3;
84202418:	3f f0 44 ff 	r2 = r2 AND 0x7fffff;
8420241c:	ff 1f 
8420241e:	f2 f7 82 7f 	r0 = r0 + -126;
84202422:	28 04       	Null = r3 - Null;
84202424:	06 60       	if EQ jump (m) Lc__FLE_mulfn_17;

84202426 <Lc__FLE_mulfn_16>:
84202426:	08 f0 00 f0 	r2 = r2 OR 0x800000;
8420242a:	00 f4 54 c8 
8420242e:	0c 6e       	jump (m) Lc__FLE_mulfn_21;

84202430 <Lc__FLE_mulfn_17>:
84202430:	20 04       	Null = r2 - Null;
84202432:	05 62       	if NE jump (m) Lc__FLE_mulfn_20;

84202434 <Lc_1>:
84202434:	09 6e       	jump (m) Lc__FLE_mulfn_21;

84202436 <Lc__FLE_mulfn_18>:
84202436:	10 24       	Null = r0 - 0;
84202438:	07 6c       	if LE jump (m) Lc__FLE_mulfn_21;

8420243a <Lc__FLE_mulfn_19>:
8420243a:	52 24       	r0 = r0 - 1;

8420243c <Lc__FLE_mulfn_20>:
8420243c:	24 54       	r2 = r2 LSHIFT 1;
8420243e:	40 f0 45 f0 	r3 = r2 AND 0x800000;
84202442:	00 00 
84202444:	f9 61       	if EQ jump (m) Lc__FLE_mulfn_18;

84202446 <Lc__FLE_mulfn_21>:
84202446:	3f f0 33 ff 	r1 = r1 AND 0x7fffff;
8420244a:	ff 1f 
8420244c:	30 04       	Null = r4 - Null;
8420244e:	06 60       	if EQ jump (m) Lc__FLE_mulfn_23;

84202450 <Lc__FLE_mulfn_22>:
84202450:	08 f0 00 f0 	r1 = r1 OR 0x800000;
84202454:	00 f3 53 c8 
84202458:	0c 6e       	jump (m) Lc__FLE_mulfn_27;

8420245a <Lc__FLE_mulfn_23>:
8420245a:	18 04       	Null = r1 - Null;
8420245c:	05 62       	if NE jump (m) Lc__FLE_mulfn_26;

8420245e <Lc_2>:
8420245e:	09 6e       	jump (m) Lc__FLE_mulfn_27;

84202460 <Lc__FLE_mulfn_24>:
84202460:	10 24       	Null = r0 - 0;
84202462:	07 6c       	if LE jump (m) Lc__FLE_mulfn_27;

84202464 <Lc__FLE_mulfn_25>:
84202464:	52 24       	r0 = r0 - 1;

84202466 <Lc__FLE_mulfn_26>:
84202466:	1b 54       	r1 = r1 LSHIFT 1;
84202468:	40 f0 35 f0 	r3 = r1 AND 0x800000;
8420246c:	00 00 
8420246e:	f9 61       	if EQ jump (m) Lc__FLE_mulfn_24;

84202470 <Lc__FLE_mulfn_27>:
84202470:	db 54       	r1 = r1 LSHIFT 4;
84202472:	a4 55       	r2 = r2 LSHIFT 7;
84202474:	a5 c6       	r3 = r2 AND 0xffff;
84202476:	9f c6       	r5 = r1 AND 0xffff;
84202478:	78 f3 d8 c8 	r6 = r1 LSHIFT -16;
8420247c:	7b 1b       	r1 = r5 * r3 (int);
8420247e:	00 f8 b5 c9 	r3 = r3 * r6 (int);
84202482:	a6 52       	r4 = r2 LSHIFT -16;
84202484:	9c c6       	r2 = r1 AND 0xffff;
84202486:	9b 52       	r1 = r1 LSHIFT -16;
84202488:	eb 00       	r1 = r3 + r1;
8420248a:	bf 1b       	r5 = r5 * r4 (int);
8420248c:	fb 00       	r1 = r5 + r1;
8420248e:	9d c6       	r3 = r1 AND 0xffff;
84202490:	9b 52       	r1 = r1 LSHIFT -16;
84202492:	64 13       	r2 = r2 OR r3;
84202494:	6f f8 85 c9 	r3 = r6 * r4 (int);
84202498:	eb 00       	r1 = r3 + r1;
8420249a:	05 00       	r3 = Null + Null;
8420249c:	20 04       	Null = r2 - Null;
8420249e:	21 f0 45 ce 	if NE r3 = Null + 1;
842024a2:	2c 00       	r2 = r3 + Null;
842024a4:	00 f2 35 f0 	r3 = r1 AND 0x4000000;
842024a8:	00 00 
842024aa:	04 62       	if NE jump (m) Lc__FLE_mulfn_29;

842024ac <Lc__FLE_mulfn_28>:
842024ac:	1b 54       	r1 = r1 LSHIFT 1;
842024ae:	52 24       	r0 = r0 - 1;
842024b0:	e3 00       	r1 = r2 + r1;

842024b2 <Lc__FLE_mulfn_29>:
842024b2:	18 04       	Null = r1 - Null;
842024b4:	04 60       	if EQ jump (m) Lc__FLE_mulfn_31;

842024b6 <Lc__FLE_mulfn_30>:
842024b6:	10 24       	Null = r0 - 0;
842024b8:	03 6c       	if LE jump (m) Lc__FLE_mulfn_32;

842024ba <Lc_3>:
842024ba:	0b 6e       	jump (m) Lc__FLE_mulfn_36;

842024bc <Lc__FLE_mulfn_31>:
842024bc:	02 00       	r0 = Null + Null;

842024be <Lc__FLE_mulfn_32>:
842024be:	52 24       	r0 = r0 - 1;

842024c0 <Lc__FLE_mulfn_33>:
842024c0:	1d c0       	r3 = r1 AND 0x1;
842024c2:	64 13       	r2 = r2 OR r3;
842024c4:	1b 50       	r1 = r1 LSHIFT -1;
842024c6:	03 62       	if NE jump (m) Lc__FLE_mulfn_35;

842024c8 <Lc__FLE_mulfn_34>:
842024c8:	02 00       	r0 = Null + Null;
842024ca:	03 6e       	jump (m) Lc__FLE_mulfn_36;

842024cc <Lc__FLE_mulfn_35>:
842024cc:	52 20       	r0 = r0 + 1;
842024ce:	f9 63       	if NE jump (m) Lc__FLE_mulfn_33;

842024d0 <Lc__FLE_mulfn_36>:
842024d0:	1d c1       	r3 = r1 AND 0x7;
842024d2:	64 13       	r2 = r2 OR r3;
842024d4:	9b 50       	r1 = r1 LSHIFT -3;
842024d6:	10 04       	Null = r0 - Null;
842024d8:	0b 60       	if EQ jump (m) Lc__FLE_mulfn_39;

842024da <Lc__FLE_mulfn_37>:
842024da:	40 f0 35 f0 	r3 = r1 AND 0x800000;
842024de:	00 00 
842024e0:	07 62       	if NE jump (m) Lc__FLE_mulfn_39;

842024e2 <Lc__FLE_mulfn_38>:
842024e2:	1b 54       	r1 = r1 LSHIFT 1;
842024e4:	65 58       	r3 = r2 ASHIFT -2;
842024e6:	52 24       	r0 = r0 - 1;
842024e8:	5b 13       	r1 = r1 OR r3;
842024ea:	a4 c0       	r2 = r2 AND 0x3;
842024ec:	04 6e       	jump (m) Lc__FLE_mulfn_40;

842024ee <Lc__FLE_mulfn_39>:
842024ee:	25 c0       	r3 = r2 AND 0x1;
842024f0:	24 58       	r2 = r2 ASHIFT -1;
842024f2:	64 13       	r2 = r2 OR r3;

842024f4 <Lc__FLE_mulfn_40>:
842024f4:	a0 24       	Null = r2 - 2;
842024f6:	05 6a       	if GT jump (m) Lc__FLE_mulfn_43;

842024f8 <Lc__FLE_mulfn_41>:
842024f8:	a0 24       	Null = r2 - 2;
842024fa:	2c 62       	if NE jump (m) Lc__FLE_mulfn_52;

842024fc <Lc__FLE_mulfn_42>:
842024fc:	1c c0       	r2 = r1 AND 0x1;
842024fe:	2a 60       	if EQ jump (m) Lc__FLE_mulfn_52;

84202500 <Lc__FLE_mulfn_43>:
84202500:	5b 20       	r1 = r1 + 1;
84202502:	03 f0 c0 ff 	r2 = r1 AND 0x7f800000;
84202506:	34 f0 00 00 
8420250a:	00 f2 40 f0 	Null = r2 - 8388608;
8420250e:	00 24 
84202510:	09 f0 c3 e0 	if LS jump (m) Lc__FLE_mulfn_52;

84202514 <Lc__FLE_mulfn_44>:
84202514:	52 20       	r0 = r0 + 1;
84202516:	20 f0 ff 24 	Null = r0 - 255;
8420251a:	09 62       	if NE jump (m) Lc__FLE_mulfn_46;

8420251c <Lc__FLE_mulfn_45>:
8420251c:	02 f0 fe 40 	r0 = Null + 254;
84202520:	5b 24       	r1 = r1 - 1;
84202522:	04 f0 3f f0 	r1 = r1 AND 0x807fffff;
84202526:	33 ff ff 1f 
8420252a:	0d 6e       	jump (m) Lc__FLE_mulfn_50;

8420252c <Lc__FLE_mulfn_46>:
8420252c:	1b 50       	r1 = r1 LSHIFT -1;

8420252e <Lc__FLE_mulfn_47>:
8420252e:	04 f0 3f f0 	r1 = r1 AND 0x807fffff;
84202532:	33 ff ff 1f 
84202536:	20 f0 ff 24 	Null = r0 - 255;
8420253a:	09 f0 9f e0 	if LS jump (m) Lc__FLE_mulfn_53;

8420253e <Lc__FLE_mulfn_48>:
8420253e:	02 f0 ff 40 	r0 = Null + 255;

84202542 <Lc__FLE_mulfn_49>:
84202542:	03 00       	r1 = Null + Null;

84202544 <Lc__FLE_mulfn_50>:
84202544:	0b f2 d2 d8 	r0 = r0 LSHIFT 23;
84202548:	89 12       	rMAC = rMAC OR r0;
8420254a:	c9 12       	rMAC = rMAC OR r1;
8420254c:	21 de       	M[FP + 16] = rMAC;

8420254e <Lc__FLE_mulfn_51>:
8420254e:	22 d8       	r0 = M[FP + 16];
84202550:	08 6e       	jump (m) Lc__FLE_mulfn_54;

84202552 <Lc__FLE_mulfn_52>:
84202552:	10 04       	Null = r0 - Null;
84202554:	ed 63       	if NE jump (m) Lc__FLE_mulfn_47;

84202556 <Lc_4>:
84202556:	f7 6f       	jump (m) Lc__FLE_mulfn_50;

84202558 <Lc__FLE_mulfn_53>:
84202558:	20 f0 ff 24 	Null = r0 - 255;
8420255c:	f3 61       	if EQ jump (m) Lc__FLE_mulfn_49;

8420255e <Lc_5>:
8420255e:	f3 6f       	jump (m) Lc__FLE_mulfn_50;

84202560 <Lc__FLE_mulfn_54>:
84202560:	73 49       	SP = SP - 0x10, popm <FP, r4, r5, r6>;
84202562:	d8 4c       	rts;

84202564 <$__FLE_negf>:
84202564:	00 f8 00 f0 	r0 = r0 XOR 0x80000000;
84202568:	00 f2 92 c8 

8420256c <Lc__FLE_negf_2>:
8420256c:	d8 4c       	rts;

8420256e <$__FLE_tltf>:
8420256e:	01 00       	rMAC = Null + Null;
84202570:	d3 c7       	r1 = r0 AND 0x80000000;
84202572:	21 f0 41 ce 	if NE rMAC = Null + 1;
84202576:	93 c7       	r1 = r0 AND 0x7fffffff;
84202578:	03 f0 c0 ff 	r0 = r1 AND 0x7f800000;
8420257c:	32 f0 00 00 
84202580:	1f f0 00 fe 	Null = r0 - 2139095040;
84202584:	20 f0 00 24 
84202588:	08 62       	if NE jump (m) Lc__FLE_tltf_4;

8420258a <Lc__FLE_tltf_2>:
8420258a:	1f f0 00 fe 	Null = r1 - 2139095040;
8420258e:	30 f0 00 24 
84202592:	03 60       	if EQ jump (m) Lc__FLE_tltf_4;

84202594 <Lc__FLE_tltf_3>:
84202594:	02 00       	r0 = Null + Null;
84202596:	09 6e       	jump (m) Lc__FLE_tltf_7;

84202598 <Lc__FLE_tltf_4>:
84202598:	08 04       	Null = rMAC - Null;
8420259a:	03 62       	if NE jump (m) Lc__FLE_tltf_6;

8420259c <Lc__FLE_tltf_5>:
8420259c:	02 00       	r0 = Null + Null;
8420259e:	05 6e       	jump (m) Lc__FLE_tltf_7;

842025a0 <Lc__FLE_tltf_6>:
842025a0:	02 00       	r0 = Null + Null;
842025a2:	18 04       	Null = r1 - Null;
842025a4:	21 f0 42 ce 	if NE r0 = Null + 1;

842025a8 <Lc__FLE_tltf_7>:
842025a8:	d8 4c       	rts;

842025aa <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_download_self_test_cap_data;
842025aa:	07 f0 02 f0 	r0 = Null + 7340328;
842025ae:	28 41 
r0 = $_basic_passthrough_cap_data;
842025b0:	07 f0 02 f0 	r0 = Null + 7340056;
842025b4:	18 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842025b6:	20 f0 b0 41 	Null = Null + 16816;

842025ba <$_basic_passthrough_processing>:
// *****************************************************************************

$_basic_passthrough_processing:

   // for now, we assume we get to the buffer parameters directly with some offset constants
   push rLink;
842025ba:	00 f0 3d cf 	push rLink;
   pushm <I0, I4, L0, L4>;
842025be:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;
   pushm <B0, B4>;
842025c2:	40 f1 40 e8 	pushm <B0, B4>;
   pushm <r5, r6>;
842025c6:	3a 1c       	pushm <r5, r6>;

   push r1; // samples to process is needed for each channel so push it on the stack
842025c8:	00 f0 33 cf 	push r1;
    * r4 - input gain parameter
    * rMAC - copy loop address
    * M[SP-ADDR_PER_WORD] - samples to process
    * several registers are also used by the copy loops
    */
   r2 = r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.PARAMS_FIELD;
842025cc:	24 f0 50 20 	r2 = r0 + 80;
   r4 = M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.GAIN_LINEAR_FIELD];
842025d0:	d6 b8       	r4 = M[r0 + 108];
   Null = M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.REINITFLAG_FIELD];
842025d2:	90 a9       	Null = M[r0 + 88];
   if Z jump basic_pass_thru_init_bypass;
842025d4:	07 60       	if EQ jump (m) $M.basic_passthrough_proc.basic_pass_thru_init_bypass;
   r4 = M[r2 + $M.BASIC_PASSTHROUGH.PARAMETERS.OFFSET_GAIN];   // in q6.26
842025d6:	66 88       	r4 = M[r2 + 4];
   r4 = r4 ASHIFT -2;                 // q8.24
842025d8:	76 58       	r4 = r4 ASHIFT -2;
   call $log2_to_pow2_pos_input;
842025da:	68 4e       	call (m) $log2_to_pow2_pos_input;
   M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.REINITFLAG_FIELD] = Null;
842025dc:	90 af       	M[r0 + 88] = Null;
   r4 = r3;
842025de:	2e 00       	r4 = r3 + Null;
   M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.GAIN_LINEAR_FIELD] = r4;
842025e0:	d6 be       	M[r0 + 108] = r4;

842025e2 <$M.basic_passthrough_proc.basic_pass_thru_init_bypass>:
basic_pass_thru_init_bypass:

   rMAC = M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.COPY_FUNCTION_FIELD];
842025e2:	11 88       	rMAC = M[r0 + 0];

   I7 = r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.CHANNEL_FIELD;
842025e4:	27 f8 24 20 	I7 = r0 + 36;
   I6 = r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.PEAK_LEVEL_1_FIELD;
842025e8:	26 f8 70 20 	I6 = r0 + 112;
   r5 = M[r0 + $basic_passthrough_struct.BASIC_PASSTHROUGH_OP_DATA_struct.NUM_ACTIVE_CHANS_FIELD];
842025ec:	d7 89       	r5 = M[r0 + 28];

842025ee <$M.basic_passthrough_proc.channel_loop>:

   // There must be at least 1 active channel otherwise this function wouldn't have been called

channel_loop:
   // Initialise r3 to the next channel
   r3 = M[I7, ADDR_PER_WORD];
842025ee:	5d f0 30 d0 	Null = Null + Null, r3 = M[I7,4];
   // get read pointer, size and start addresses of input buffer if the buffer
   // doesn't exist this and any more channels in the list are inactive
   r0 = M[r3 + $basic_passthrough_struct.PASSTHROUGH_CHANNEL_struct.IP_BUFFER_FIELD];
842025f2:	2a 88       	r0 = M[r3 + 0];
   call $cbuffer.get_read_address_and_size_and_start_address;
842025f4:	ff fd 50 f1 	call (m) 0x2c6a4;
842025f8:	31 e5 
   push r2;
842025fa:	00 f0 34 cf 	push r2;
   pop B0;
842025fe:	00 f6 3a cf 	pop B0;
   I0 = r0;
84202602:	10 0a       	I0 = r0 + Null;
   L0 = r1;
84202604:	1c 0b       	L0 = r1 + Null;

   // now get the output buffer info if its null then its inactive
   r0 = M[r3 + $basic_passthrough_struct.PASSTHROUGH_CHANNEL_struct.OP_BUFFER_FIELD];
84202606:	6a 88       	r0 = M[r3 + 4];
   call $cbuffer.get_write_address_and_size_and_start_address;
84202608:	ff fd 50 f1 	call (m) 0x2c6d6;
8420260c:	2f e6 
   push r2;
8420260e:	00 f0 34 cf 	push r2;
   pop B4;
84202612:	00 f6 3c cf 	pop B4;
   I4 = r0;
84202616:	14 0a       	I4 = r0 + Null;
   L4 = r1;
84202618:	1e 0b       	L4 = r1 + Null;

   r10 = M[SP - ADDR_PER_WORD]; // load number of samples to process into r10;
8420261a:	fe f8 1c cf 	r10 = M[SP + -0x4];
   r1 = M[I6,0];                // load peak value
8420261e:	38 f0 30 d0 	Null = Null + Null, r1 = M[I6,0];
   // jump to the appropriate copy routine
   jump rMAC;
84202622:	d9 4c       	jump rMAC;

84202624 <$M.basic_passthrough_proc.done_copying>:

   done_copying:
   M[I6, ADDR_PER_WORD] = r1;  // store peak value for the current channel
84202624:	b9 f0 30 d0 	Null = Null + Null, M[I6,4] = r1;
   // The copy loop reads an extra sample from the input buffer, this needs to
   // be read back 1 sample, we can do this in parallel with the next operation so we do.

   // update read address in input buffer
   r0 = M[r3 + $basic_passthrough_struct.PASSTHROUGH_CHANNEL_struct.IP_BUFFER_FIELD], r2 = M[I0, M2];
84202628:	42 f0 0f f5 	r0 = M[r3 + Null], r2 = M[I0,M2];
8420262c:	02 cd 
   r1 = I0;
8420262e:	83 08       	r1 = I0 + Null;
   call $cbuffer.set_read_address;
84202630:	ff fd 50 f1 	call (m) 0x2c708;
84202634:	39 e6 

   // update write address in output buffer
   r0 = M[r3 + $basic_passthrough_struct.PASSTHROUGH_CHANNEL_struct.OP_BUFFER_FIELD];
84202636:	6a 88       	r0 = M[r3 + 4];
   r1 = I4;
84202638:	a3 08       	r1 = I4 + Null;
   call $cbuffer.set_write_address;
8420263a:	ff fd 50 f1 	call (m) 0x2c73e;
8420263e:	25 e8 

   // Decrement the channel counter
   r5 = r5 - 1;
84202640:	7f 24       	r5 = r5 - 1;
   if NZ jump channel_loop;
84202642:	d6 63       	if NE jump (m) $M.basic_passthrough_proc.channel_loop;

84202644 <$M.basic_passthrough_proc.all_channels_processed>:

all_channels_processed:
   pop r1;  // take samples to process back off the stack;
84202644:	00 f4 33 cf 	pop r1;

   popm <r5, r6>;
84202648:	3a 48       	popm <r5, r6>;
   popm <B0, B4>;
8420264a:	40 f1 60 e8 	popm <B0, B4>;
   popm <I0, I4, L0, L4>;
8420264e:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   pop rLink;
84202652:	00 f4 3d cf 	pop rLink;

   rts;
84202656:	d8 4c       	rts;

84202658 <$M.basic_passthrough_proc.mono_gain_copy_loop>:
//        It relies for now on imagined $cbuffer and $common modules' constants
//
// *****************************************************************************
mono_gain_copy_loop:
   // copy audio across with gain in r4
   r2 = M[I0, ADDR_PER_WORD];
84202658:	41 f0 30 c0 	Null = Null + Null, r2 = M[I0,4];
   do pass_copy_loop;
8420265c:	0a 4c       	do (m) $M.basic_passthrough_proc.pass_copy_loop;
      r2 = r2 * r4 (frac);
8420265e:	00 f6 74 c9 	r2 = r2 * r4 (frac);
      r2 = r2 ASHIFT 4;
84202662:	e4 5c       	r2 = r2 ASHIFT 4;
      r0 = ABS r2;                   // abs(input_value)
84202664:	4f f4 42 ce 	r0 = ABS r2;
      r1 = MAX r0;                   // current peak
84202668:	6f f2 43 ce 	r1 = MAX r0;
      M[I4, ADDR_PER_WORD] = r2, r2 = M[I0, ADDR_PER_WORD];
8420266c:	c1 f1 34 d0 	Null = Null + Null, r2 = M[I0,4], M[I4,4] = r2;

84202670 <$M.basic_passthrough_proc.pass_copy_loop>:
   pass_copy_loop:
   // This reads one extra sample from I0. This is stepped back in the main
   // loop as this opeation is common and saves a stall this way.
   jump done_copying;
84202670:	da 6f       	jump (m) $M.basic_passthrough_proc.done_copying;

84202672 <$M.basic_passthrough_proc.mono_data_copy_loop>:


mono_data_copy_loop:
   Null = I0 - I4;
84202672:	4f f0 c0 c6 	Null = I0 - I4;
   if Z jump no_copy;
84202676:	0c 60       	if EQ jump (m) $M.basic_passthrough_proc.no_copy;

   // copy unprocessed data across
   r2 = M[I0, ADDR_PER_WORD];
84202678:	41 f0 30 c0 	Null = Null + Null, r2 = M[I0,4];
   do pass_copy_loop_data;
8420267c:	08 4c       	do (m) $M.basic_passthrough_proc.pass_copy_loop_data;
      Null = Null + Null;
8420267e:	00 00       	Null = Null + Null;
      r0 = ABS r2;                   // abs(input_value)
84202680:	4f f4 42 ce 	r0 = ABS r2;
      r1 = MAX r0;                   // current peak
84202684:	6f f2 43 ce 	r1 = MAX r0;
      M[I4, ADDR_PER_WORD] = r2, r2 = M[I0, ADDR_PER_WORD];
84202688:	c1 f1 34 d0 	Null = Null + Null, r2 = M[I0,4], M[I4,4] = r2;

8420268c <$M.basic_passthrough_proc.pass_copy_loop_data>:
   pass_copy_loop_data:
   // This reads one extra sample from I0. This is stepped back in the main
   // loop as this opeation is common and saves a stall this way.
   jump done_copying;
8420268c:	cc 6f       	jump (m) $M.basic_passthrough_proc.done_copying;

8420268e <$M.basic_passthrough_proc.no_copy>:

no_copy:
   // In-place data copy doesn't actually do anything,
   // so just update the pointers
   push M3;
8420268e:	00 f1 3b cf 	push M3;
   r2 = r10 ASHIFT LOG2_ADDR_PER_WORD;
84202692:	01 fc 14 c9 	r2 = r10 ASHIFT 2;
   M3 = r2;
84202696:	23 0b       	M3 = r2 + Null;
   r2 = M[I0, M3];
84202698:	43 f0 20 c0 	Null = Null + Null, r2 = M[I0,M3];
   r2 = M[I4, M3];
8420269c:	43 f0 20 d0 	Null = Null + Null, r2 = M[I4,M3];
   pop M3;
842026a0:	00 f5 3b cf 	pop M3;

   // Extra read as above, to simplify code in the main loop
   r2 = M[I0, ADDR_PER_WORD];
842026a4:	41 f0 30 c0 	Null = Null + Null, r2 = M[I0,4];

   jump done_copying;
842026a8:	be 6f       	jump (m) $M.basic_passthrough_proc.done_copying;

842026aa <$log2_to_pow2_pos_input>:
//    - None
//
// *****************************************************************************
$log2_to_pow2_pos_input:

   push rLink;
842026aa:	00 f0 3d cf 	push rLink;
   pushm <r0,r1,r2,r7>;
842026ae:	21 f0 4c e0 	pushm <r0, r1, r2, r7>;

   r0 = r4;
842026b2:	32 00       	r0 = r4 + Null;
   r3 = Qfmt_(1.0,5);          // 1.0 in q.27
842026b4:	80 f0 05 f0 	r3 = Null + 134217728;
842026b8:	00 40 
   Null = r4;
842026ba:	30 00       	Null = r4 + Null;
   if Z jump bpt_pow2_calc_done;
842026bc:	11 60       	if EQ jump (m) $M.basic_passthrough_proc.bpt_pow2_calc_done;
   if NEG jump bpt_pow2_call;
842026be:	04 f0 97 e0 	if NEG jump (m) $M.basic_passthrough_proc.bpt_pow2_call;

842026c2 <$M.basic_passthrough_proc.gain_smooth_pos>:

gain_smooth_pos:
   r2 = r4 ASHIFT (8-DAWTH);   // integer
842026c2:	74 5b       	r2 = r4 ASHIFT -24;
   r1 = r2 ASHIFT (DAWTH - 8); // integer in q.24(arch4)
842026c4:	63 5f       	r1 = r2 ASHIFT 24;
   r4 = r4 - r1;               // fractional value in q.24(arch4)
842026c6:	f6 04       	r4 = r4 - r1;
   r1 = r2 + (DAWTH-4);        // integer+1 q.27(arch4)
842026c8:	23 2b       	r1 = r2 + 28;
   r0 = r4 - Qfmt_(1.0,8);     // negative fractional part
842026ca:	00 f4 62 f0 	r0 = r4 - 16777216;
842026ce:	00 24 
   r3 = 1 ASHIFT r1;           // pow2(integer_part) in q.27(arch4)
842026d0:	00 f3 d5 de 	r3 = 0x1 ASHIFT r1;

842026d4 <$M.basic_passthrough_proc.bpt_pow2_call>:

bpt_pow2_call:
   call $math.pow2_taylor;
842026d4:	ff fd d1 f2 	call 0x5ca48;
842026d8:	34 eb 
   r3 = r3 * r0;
842026da:	2f f5 c5 cc 	r3 = r3 * r0 (SS);

842026de <$M.basic_passthrough_proc.bpt_pow2_calc_done>:

bpt_pow2_calc_done:
   popm <r0,r1,r2,r7>;
842026de:	21 f0 6c e0 	popm <r0, r1, r2, r7>;
   pop rLink;
842026e2:	00 f4 3d cf 	pop rLink;
   rts;
842026e6:	d8 4c       	rts;

842026e8 <$_download_self_test_branch_test>:
.MINIM;

.CONST $MEM_TO_ALLOC 200;

$_download_self_test_branch_test:
    push rLink;
842026e8:	00 f0 3d cf 	push rLink;
    /* Tests call_k9 instruction patching in MiniM */
    r0 = $MEM_TO_ALLOC;
842026ec:	02 f0 c8 40 	r0 = Null + 200;
    /* Don't care which bank */
    r1 = 3;
842026f0:	c3 20       	r1 = Null + 3;
	.VAR8 $fileName[] = string(__FILE__);
	r2 = &$fileName;
	r3 = __LINE__;
    call $_xzppmalloc_debug;
#else
	call $_xzppmalloc;
842026f2:	ff fd 14 f0 	call (m) 0x4f2a;
842026f6:	39 e1 
#endif
    Null = r0 - Null;
842026f8:	10 04       	Null = r0 - Null;
    if Z jump error;
842026fa:	17 60       	if EQ jump (m) $M.download_self_test_branch_test.error;
    call $_pfree;
842026fc:	ff fd 14 f0 	call (m) 0x4f62;
84202700:	27 e3 
    r0 = $MEM_TO_ALLOC;
84202702:	02 f0 c8 40 	r0 = Null + 200;
    r1 = 3;
84202706:	c3 20       	r1 = Null + 3;
    /* Tests jumpB instruction patching in MiniM */
    rLink = return_jumpB;
84202708:	42 f0 1d f0 	rLink = Null + 69216021;
8420270c:	15 4b 
#ifdef PMALLOC_DEBUG
	r2 = &$fileName;
	r3 = __LINE__;
    jump $_xzppmalloc_debug;
#else
	jump $_xzppmalloc;
8420270e:	7c ff 5f f0 	jump (m) 0x4f2a;
84202712:	9d e0 

84202714 <$M.download_self_test_branch_test.return_jumpB>:
#endif
    return_jumpB:
    Null = r0 - Null;
84202714:	10 04       	Null = r0 - Null;
    if Z jump error;
84202716:	09 60       	if EQ jump (m) $M.download_self_test_branch_test.error;
    call $_pfree;
84202718:	ff fd 14 f0 	call (m) 0x4f62;
8420271c:	2b e2 
    r0 = 0x600D;
8420271e:	32 f0 0d 40 	r0 = Null + 24589;
    /* Return 0x600D */
    pop rLink;
84202722:	00 f4 3d cf 	pop rLink;
    rts;
84202726:	d8 4c       	rts;

84202728 <$M.download_self_test_branch_test.error>:
    error:
    /* Return ERROR */
    r0 = 0xBAD;
84202728:	02 f0 ad 53 	r0 = Null + 2989;
    pop rLink;
8420272c:	00 f4 3d cf 	pop rLink;
    rts;
84202730:	d8 4c       	rts;

84202732 <$_download_self_test_var_ref_test_minim>:
.MODULE $M.download_self_test_var_ref_test_minim;
.CODESEGMENT PM;
.MINIM;

$_download_self_test_var_ref_test_minim:
    push r10;
84202732:	00 f0 3c cf 	push r10;
    r10 = 10;
84202736:	54 71       	r10 = Null + 10;
    r0 = &$dm2_v5;
84202738:	f8 ff 02 f0 	r0 = Null + -8388552;
8420273c:	38 40 
    do get_value_loop;
8420273e:	02 4c       	do (m) $M.download_self_test_var_ref_test_minim.get_value_loop;
        r0 = M[r0];
84202740:	12 e8       	r0 = M[r0 + Null];

84202742 <$M.download_self_test_var_ref_test_minim.get_value_loop>:
    get_value_loop:
    pop r10;
84202742:	00 f4 3c cf 	pop r10;
    /* Return GOOD */
    Null = r0 - 0x600D;
84202746:	01 f0 20 f2 	Null = r0 - 24589;
8420274a:	0d 24 
    if Z rts;
8420274c:	00 fd c0 cd 	if EQ rts;
    /* Return error */
    r0 = 0xBAD;
84202750:	02 f0 ad 53 	r0 = Null + 2989;
    rts;
84202754:	d8 4c       	rts;

84202756 <$_func_increase_one_with_param_asm>:
.MODULE $M.func_increase_one_with_param_asm;
.CODESEGMENT PM;
.MINIM;

$_func_increase_one_with_param_asm:
    r0 = r0 + 1;
84202756:	52 20       	r0 = r0 + 1;
    rts;
84202758:	d8 4c       	rts;

8420275a <$_download_self_test_call_from_minim_to_insert32_instr_test_minim>:
.CODESEGMENT PM;
.DATASEGMENT DM;
.MINIM;

$_download_self_test_call_from_minim_to_insert32_instr_test_minim:
    push rLink;
8420275a:	00 f0 3d cf 	push rLink;
    call $_func_insert32_instr_c;
8420275e:	f5 ff 3d e4 	call (m) $_func_insert32_instr_c;
    Null = r0 - 5;
84202762:	50 25       	Null = r0 - 5;
    if NZ jump ret_BAD;
84202764:	04 62       	if NE jump (m) $M.download_self_test_call_from_minim_to_insert32_instr_test_minim.ret_BAD;

84202766 <$M.download_self_test_call_from_minim_to_insert32_instr_test_minim.ret_GOOD>:

    ret_GOOD:
        r0 = 0x600D;
84202766:	32 f0 0d 40 	r0 = Null + 24589;
        jump return;
8420276a:	03 6e       	jump (m) $M.download_self_test_call_from_minim_to_insert32_instr_test_minim.return;

8420276c <$M.download_self_test_call_from_minim_to_insert32_instr_test_minim.ret_BAD>:
    ret_BAD:
        r0 = 0xBAD;
8420276c:	02 f0 ad 53 	r0 = Null + 2989;

84202770 <$M.download_self_test_call_from_minim_to_insert32_instr_test_minim.return>:
    return:
        pop rLink;
84202770:	00 f4 3d cf 	pop rLink;
        rts;
84202774:	d8 4c       	rts;

84202776 <$_download_self_test_variable_size_vars_test_minim_asm>:
    .VAR8 ByteArray[3] = 0x2E, 0x2F, 0x30;
    .VAR secondWord = 0x63;
    .VAR8 sixthByte = 0x31;
    .VAR secondHalf[3] = 0xBEEF,0xDEAD, 0xABCD;
    .VAR16 secondHalf1 = 0xBEEF;
    push rLink;
84202776:	00 f0 3d cf 	push rLink;
    r0 = MBU[firstByte];
8420277a:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.firstByte];
8420277e:	4e 93 
    Null = r0 - 0xC;
84202780:	10 27       	Null = r0 - 12;
    if NZ jump ret_BAD;
84202782:	45 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = M[firstWord];
84202784:	e0 f0 02 f0 	r0 = M[Null + $M.download_self_test_variable_size_vars_test_minim_asm.firstWord];
84202788:	d4 88 
    Null = r0 - 0x87654321;
8420278a:	21 f0 95 fd 	Null = r0 - -2023406815;
8420278e:	20 f0 21 27 
    if NZ jump ret_BAD;
84202792:	3d 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MHU[firstHalf];
84202794:	c0 f1 02 f0 	r0 = MHU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.firstHalf];
84202798:	aa 87 
    Null = r0 - 0xABCD;
8420279a:	02 f0 20 f2 	Null = r0 - 43981;
8420279e:	cd 37 
    if NZ jump ret_BAD;
842027a0:	36 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[secondByte];
842027a2:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.secondByte];
842027a6:	56 93 
    Null = r0 - 0x2A;
842027a8:	90 36       	Null = r0 - 42;
    if NZ jump ret_BAD;
842027aa:	31 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[thirdByte];
842027ac:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.thirdByte];
842027b0:	57 93 
    Null = r0 - 0x2B;
842027b2:	d0 36       	Null = r0 - 43;
    if NZ jump ret_BAD;
842027b4:	2c 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[fourthByte];
842027b6:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.fourthByte];
842027ba:	58 93 
    Null = r0 - 0x2C;
842027bc:	10 37       	Null = r0 - 44;
    if NZ jump ret_BAD;
842027be:	27 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[fifthByte];
842027c0:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.fifthByte];
842027c4:	59 93 
    Null = r0 - 0x2D;
842027c6:	50 37       	Null = r0 - 45;
    if NZ jump ret_BAD;
842027c8:	22 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[ByteArray+1];
842027ca:	80 f3 02 f0 	r0 = MBU[Null + 0x70035b];
842027ce:	5b 93 
    Null = r0 - 0x2F;
842027d0:	d0 37       	Null = r0 - 47;
    if NZ jump ret_BAD;
842027d2:	1d 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = M[secondWord];
842027d4:	e0 f0 02 f0 	r0 = M[Null + $M.download_self_test_variable_size_vars_test_minim_asm.secondWord];
842027d8:	d8 88 
    Null = r0 - 0x63;
842027da:	20 f0 63 24 	Null = r0 - 99;
    if NZ jump ret_BAD;
842027de:	17 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MBU[sixthByte];
842027e0:	80 f3 02 f0 	r0 = MBU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.sixthByte];
842027e4:	64 93 
    Null = r0 - 0x31;
842027e6:	50 3c       	Null = r0 - 49;
    if NZ jump ret_BAD;
842027e8:	12 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = M[secondHalf + 2*ADDR_PER_WORD];
842027ea:	e0 f0 02 f0 	r0 = M[Null + 0x700370];
842027ee:	dc 88 
    Null = r0 - 0xABCD;
842027f0:	02 f0 20 f2 	Null = r0 - 43981;
842027f4:	cd 37 
    if NZ jump ret_BAD;
842027f6:	0b 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;
    r0 = MHU[secondHalf1];
842027f8:	c0 f1 02 f0 	r0 = MHU[Null + $M.download_self_test_variable_size_vars_test_minim_asm.secondHalf1];
842027fc:	ba 87 
    Null = r0 - 0xBEEF;
842027fe:	02 f0 20 f3 	Null = r0 - 48879;
84202802:	ef 3e 
    if NZ jump ret_BAD;
84202804:	04 62       	if NE jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD;

84202806 <$M.download_self_test_variable_size_vars_test_minim_asm.ret_GOOD>:
    ret_GOOD:
        r0 = 0x600D;
84202806:	32 f0 0d 40 	r0 = Null + 24589;
        jump return;
8420280a:	03 6e       	jump (m) $M.download_self_test_variable_size_vars_test_minim_asm.return;

8420280c <$M.download_self_test_variable_size_vars_test_minim_asm.ret_BAD>:
    ret_BAD:
        r0 = 0xBAD;
8420280c:	02 f0 ad 53 	r0 = Null + 2989;

84202810 <$M.download_self_test_variable_size_vars_test_minim_asm.return>:
    return:
        pop rLink;
84202810:	00 f4 3d cf 	pop rLink;
        rts;
84202814:	d8 4c       	rts;
