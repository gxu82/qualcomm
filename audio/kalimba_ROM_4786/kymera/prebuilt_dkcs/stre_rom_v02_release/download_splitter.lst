
/home/svc-audio-dspsw/kymera_builds/builds/2019/kymera_1903271828/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_splitter.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_splitter_process_data>:
 * \brief The main data processing function only selects the
 *  right data processing based on the working mode.
 *
 */
void splitter_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200000:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200002:	42 de       	M[FP + 32] = r0;
84200004:	4b de       	M[FP + 36] = r1;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84200006:	10 f0 21 ef 	call (m) $_base_op_get_instance_data;
8420000a:	16 00       	r4 = r0 + Null;
     * for old implementations where the data type is not save in the elf. */
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data); /* old way = (SPLITTER_OP_DATA *)(op_data->extra_op_data);*/

    SPLITTER_MSG1("#### SPLITTER 0x%08x ####",base_op_get_ext_op_id(op_data));

    switch (splitter->working_mode)
8420000c:	33 81       	r1 = MBS[r4 + 4];
8420000e:	19 00       	rMAC = r1 + Null;
84200010:	2c 60       	if EQ jump (m) Lc_splitter_process_data_10;

84200012 <Lc_splitter_process_data_2>:
84200012:	48 24       	Null = rMAC - 1;
84200014:	43 62       	if NE jump (m) Lc_splitter_process_data_13;

84200016 <Lc_splitter_process_data_3>:
84200016:	42 d8       	r0 = M[FP + 32];
84200018:	10 f0 2f ee 	call (m) $_base_op_get_instance_data;
8420001c:	16 00       	r4 = r0 + Null;
static inline void splitter_process_data_buffering(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    /* Data to pack/copy. and the actual copies/packed data.*/
    unsigned data_to_pack;
    bool in_transition = splitter->in_transition;
8420001e:	68 f0 07 88 	r6 = M[r4 + 28];
    INTERVAL kick_period;
    patch_fn(splitter_process_data);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
84200022:	37 31       	r5 = r4 + 36;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200024:	ff fd 66 f1 	call (m) 0x2cc9c;
84200028:	39 e3 
    if (*timer_id != TIMER_ID_INVALID)
8420002a:	3a e8       	r0 = M[r5 + Null];
8420002c:	07 60       	if EQ jump (m) Lc_splitter_process_data_5;

8420002e <Lc_splitter_process_data_4>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
8420002e:	04 00       	r2 = Null + Null;
84200030:	03 00       	r1 = Null + Null;
84200032:	ff fd a0 f0 	call (m) 0x141bc;
84200036:	2b ec 
        *timer_id = TIMER_ID_INVALID;
84200038:	38 ee       	M[r5 + Null] = Null;

8420003a <Lc_splitter_process_data_5>:
    }
    interrupt_unblock();
8420003a:	ff fd 66 f1 	call (m) 0x2ccb8;
8420003e:	3f e3 


    /*Calculate the min available data at the input */
    data_to_pack = amount_to_pack(splitter);
84200040:	32 00       	r0 = r4 + Null;
84200042:	01 f0 25 e6 	call (m) Lc_amount_to_pack_1;
84200046:	13 00       	r1 = r0 + Null;

    SPLITTER_MSG1("Splitter data_to_pack 0x%08x!", data_to_pack);

    /* Try to finish the transition.*/
    if (in_transition)
84200048:	0f f8 00 c2 	Null = r6 - Null;
8420004c:	e1 60       	if EQ jump (m) Lc_splitter_process_data_52;

8420004e <Lc_splitter_process_data_6>:
    {

        SPLITTER_MSG("Splitter in transition!");
        /* Transition based on timestamp can wait for a specific timestamp.
         * Pack the input without offload to avoid dead lock. */
        if (data_to_pack != 0)
8420004e:	18 04       	Null = r1 - Null;
84200050:	05 60       	if EQ jump (m) Lc_splitter_process_data_8;

84200052 <Lc_splitter_process_data_7>:
        {
            SPLITTER_MSG1("Splitter in transition! First pack data %d", data_to_pack);
            pack_to_internal(splitter, data_to_pack, FALSE);
84200052:	04 00       	r2 = Null + Null;
84200054:	32 00       	r0 = r4 + Null;
84200056:	01 f0 39 eb 	call (m) Lc_pack_to_internal_1;

8420005a <Lc_splitter_process_data_8>:
            /* No more data to pack. */
            data_to_pack = 0;
        }
        if (splitter_transition(splitter))
8420005a:	32 00       	r0 = r4 + Null;
8420005c:	01 f0 23 e1 	call (m) $_splitter_transition;
84200060:	10 04       	Null = r0 - Null;
84200062:	dd 60       	if EQ jump (m) Lc_splitter_process_data_55;

84200064 <Lc_splitter_process_data_9>:
        {
            /* This time we managed to finish transitioning .*/
            in_transition = FALSE;
            /* Save the new state. */
            splitter->in_transition = in_transition;
84200064:	f0 8f       	M[r4 + 28] = Null;
84200066:	d9 6e       	jump (m) Lc_splitter_process_data_54;

84200068 <Lc_splitter_process_data_10>:
84200068:	42 d8       	r0 = M[FP + 32];
8420006a:	10 f0 3d eb 	call (m) $_base_op_get_instance_data;
8420006e:	11 09       	r7 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned i, min_new_data, min_new_space;
    int *new_output_write_addr;
    int *new_input_read_addr;

    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
84200070:	96 f0 00 e8 	r4 = M[r7 + Null];
    patch_fn(splitter_process_data);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
84200074:	97 f0 24 20 	r5 = r7 + 36;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200078:	ff fd 66 f1 	call (m) 0x2cc9c;
8420007c:	25 e1 
    if (*timer_id != TIMER_ID_INVALID)
8420007e:	3a e8       	r0 = M[r5 + Null];
84200080:	07 60       	if EQ jump (m) Lc_splitter_process_data_12;

84200082 <Lc_splitter_process_data_11>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200082:	04 00       	r2 = Null + Null;
84200084:	03 00       	r1 = Null + Null;
84200086:	ff fd a0 f0 	call (m) 0x141bc;
8420008a:	37 e9 
        *timer_id = TIMER_ID_INVALID;
8420008c:	38 ee       	M[r5 + Null] = Null;

8420008e <Lc_splitter_process_data_12>:
    }
    interrupt_unblock();
8420008e:	ff fd 66 f1 	call (m) 0x2ccb8;
84200092:	2b e1 

    /* This code is very naughty and reaches into the cbuffer structures. It can
     * be done safely because they have to be local, and it's lightning fast as
     * a result. Cbuffer API is subverted because it isn't designed for this.
     */
    min_new_data = min_new_space = UINT_MAX;
84200094:	41 24       	rMAC = Null - 1;
84200096:	0a 09       	r8 = rMAC + Null;
84200098:	12 6e       	jump (m) Lc_splitter_process_data_15;

8420009a <Lc_splitter_process_data_13>:
        case BUFFER_DATA:
            splitter_process_data_buffering(op_data, touched);
            break;
#endif
        default:
            SPLITTER_ERRORMSG1("SPLITTER Error, unsupported mode: %d.",splitter->working_mode);
8420009a:	55 f1 02 f0 	r0 = Null + 357565486;
8420009e:	2e 48 
842000a0:	ff fd 04 f0 	call (m) 0x9b4;
842000a4:	35 e8 
            /* Check if the mode is valid one or is just unsupported.*/
            PL_ASSERT(splitter->working_mode < NR_OF_MODES);
842000a6:	31 81       	rMAC = MBS[r4 + 4];
842000a8:	88 24       	Null = rMAC - 2;
842000aa:	e8 68       	if LT jump (m) Lc_splitter_process_data_61;

842000ac <Lc_splitter_process_data_14>:
842000ac:	03 f0 1f 4a 	r1 = Null + 1567;
842000b0:	02 f0 13 60 	r0 = Null + 4115;
842000b4:	ff fd 9f f0 	call (m) 0x13f12;
842000b8:	3f e2 
842000ba:	e0 6e       	jump (m) Lc_splitter_process_data_61;

842000bc <Lc_splitter_process_data_15>:
     * be done safely because they have to be local, and it's lightning fast as
     * a result. Cbuffer API is subverted because it isn't designed for this.
     */
    min_new_data = min_new_space = UINT_MAX;
    /* Iterate through the list of all active channels. */
    while (NULL != channel)
842000bc:	30 04       	Null = r4 - Null;
842000be:	2d 60       	if EQ jump (m) Lc_splitter_process_data_28;

842000c0 <Lc_splitter_process_data_16>:
    {
        int new_data, new_space;
        tCbuffer *out = NULL; /* Initialise to keep the compiler happy. */
842000c0:	04 00       	r2 = Null + Null;
        tCbuffer *in = channel->input_buffer;
842000c2:	b5 88       	r3 = M[r4 + 8];

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842000c4:	02 00       	r0 = Null + Null;
842000c6:	37 23       	r5 = r4 + 12;
842000c8:	14 71       	r10 = Null + 2;
842000ca:	18 4c       	do (m) Lc__loop0;

842000cc <Lc_splitter_process_data_17>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842000cc:	93 f0 18 20 	r1 = r7 + 24;
842000d0:	9b e0       	r1 = MBS[r1 + r0];
        {
            if (get_current_output_state(splitter, i) == ACTIVE)
842000d2:	58 24       	Null = r1 - 1;
842000d4:	11 62       	if NE jump (m) Lc_splitter_process_data_22;

842000d6 <Lc_splitter_process_data_18>:
            {
                out = channel->output_buffer[i];
842000d6:	3c e8       	r2 = M[r5 + Null];

                /* Find out minimum available space. */
                new_space = (char *)out->read_ptr - (char *)in->read_ptr;
842000d8:	63 88       	r1 = M[r2 + 4];
842000da:	58 f0 01 88 	r6 = M[r3 + 4];
842000de:	00 f8 33 c2 	r1 = r1 - r6;
                if (new_space < 0)
842000e2:	18 04       	Null = r1 - Null;
842000e4:	05 f0 8b e0 	if POS jump (m) Lc_splitter_process_data_20;

842000e8 <Lc_splitter_process_data_19>:
                {
                    new_space += in->size;
842000e8:	58 f0 00 e8 	r6 = M[r3 + Null];
842000ec:	43 0c       	r1 = r6 + r1;

842000ee <Lc_splitter_process_data_20>:
                }

                if (new_space < min_new_space)
842000ee:	58 04       	Null = r1 - rMAC;
842000f0:	02 f0 87 e0 	if C jump (m) Lc_splitter_process_data_22;

842000f4 <Lc_splitter_process_data_21>:
                {
                    min_new_space = new_space;
842000f4:	19 00       	rMAC = r1 + Null;

842000f6 <Lc_splitter_process_data_22>:
    {
        int new_data, new_space;
        tCbuffer *out = NULL; /* Initialise to keep the compiler happy. */
        tCbuffer *in = channel->input_buffer;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842000f6:	52 20       	r0 = r0 + 1;
842000f8:	3f 21       	r5 = r5 + 4;

842000fa <Lc__loop0>:
842000fa:	aa 88       	r0 = M[r3 + 8];
842000fc:	a3 88       	r1 = M[r2 + 8];
842000fe:	d2 04       	r0 = r0 - r1;
            }
        }

        /* Find out minimum available data. */
        new_data =  (char *)in->write_ptr -  (char *)out->write_ptr;
        if (new_data < 0)
84200100:	10 04       	Null = r0 - Null;
84200102:	05 f0 89 e0 	if POS jump (m) Lc_splitter_process_data_25;

84200106 <Lc_splitter_process_data_24>:
        {
            new_data += out->size;
84200106:	23 e8       	r1 = M[r2 + Null];
84200108:	9a 00       	r0 = r1 + r0;

8420010a <Lc_splitter_process_data_25>:
        }

        if (new_data < min_new_data)
8420010a:	af f2 00 c2 	Null = r0 - r8;
8420010e:	02 f0 87 e0 	if C jump (m) Lc_splitter_process_data_27;

84200112 <Lc_splitter_process_data_26>:
        {
            min_new_data = new_data;
84200112:	12 09       	r8 = r0 + Null;

84200114 <Lc_splitter_process_data_27>:
        }

        channel = channel->next;
84200114:	36 e8       	r4 = M[r4 + Null];
     * be done safely because they have to be local, and it's lightning fast as
     * a result. Cbuffer API is subverted because it isn't designed for this.
     */
    min_new_data = min_new_space = UINT_MAX;
    /* Iterate through the list of all active channels. */
    while (NULL != channel)
84200116:	d3 6f       	jump (m) Lc_splitter_process_data_15;

84200118 <Lc_splitter_process_data_28>:
    }

    /* Typically only one of  min_new_space OR min_new_data are non zero on a
     * given kick so we separate the looping out to reduce the amount of work done.
     */
    if (min_new_space > 0)
84200118:	08 04       	Null = rMAC - Null;
8420011a:	16 60       	if EQ jump (m) Lc_splitter_process_data_35;

8420011c <Lc_splitter_process_data_29>:
    {
        channel = splitter->channel_list;
8420011c:	94 f0 00 e8 	r2 = M[r7 + Null];

84200120 <Lc_splitter_process_data_30>:
        while (NULL != channel)
84200120:	20 04       	Null = r2 - Null;
84200122:	0e 60       	if EQ jump (m) Lc_splitter_process_data_34;

84200124 <Lc_splitter_process_data_31>:
        {
            tCbuffer *in = channel->input_buffer;
84200124:	a3 88       	r1 = M[r2 + 8];
            new_input_read_addr = (int *)((char *)in->read_ptr + min_new_space);
84200126:	5a 88       	r0 = M[r1 + 4];
84200128:	8a 00       	r0 = rMAC + r0;
            if (new_input_read_addr >= (int *)((char *)in->base_addr + in->size))
8420012a:	1d e8       	r3 = M[r1 + Null];
8420012c:	de 88       	r4 = M[r1 + 12];
8420012e:	ae 01       	r4 = r3 + r4;
84200130:	90 05       	Null = r0 - r4;
84200132:	03 64       	if NC jump (m) Lc_splitter_process_data_33;

84200134 <Lc_splitter_process_data_32>:
            {
                new_input_read_addr = (int *)((char *)new_input_read_addr - in->size);
84200134:	45 05       	r3 = Null - r3;
84200136:	aa 00       	r0 = r3 + r0;

84200138 <Lc_splitter_process_data_33>:
            }
            in->read_ptr = new_input_read_addr;
84200138:	5a 8e       	M[r1 + 4] = r0;
            channel = channel->next;
8420013a:	24 e8       	r2 = M[r2 + Null];
     * given kick so we separate the looping out to reduce the amount of work done.
     */
    if (min_new_space > 0)
    {
        channel = splitter->channel_list;
        while (NULL != channel)
8420013c:	f2 6f       	jump (m) Lc_splitter_process_data_30;

8420013e <Lc_splitter_process_data_34>:
        }
        /* N.B. Because the splitter runs in place and is designed to be
         * cascaded, it is necessary to kick back whenever data is consumed so
         * that the input buffer pointers of a splitter that proceeds this one
         * are updated. */
        touched->sinks = splitter->touched_sinks;
8420013e:	91 f0 04 88 	rMAC = M[r7 + 16];
84200142:	4a d8       	r0 = M[FP + 36];
84200144:	51 8e       	M[r0 + 4] = rMAC;

84200146 <Lc_splitter_process_data_35>:
    }

    if (min_new_data > 0)
84200146:	0f fa 00 c2 	Null = r8 - Null;
8420014a:	4a 60       	if EQ jump (m) Lc_splitter_process_data_50;

8420014c <Lc_splitter_process_data_36>:
#ifdef INSTALL_METADATA
        unsigned octets_moved;
        tCbuffer *metadata_ip_buffer;
        tCbuffer *metadata_op_buffer;

        metadata_ip_buffer = get_metadata_buffer(splitter, TRUE, 0);
8420014c:	43 20       	r1 = Null + 1;
8420014e:	04 00       	r2 = Null + Null;
84200150:	4a 08       	r0 = r7 + Null;
84200152:	0c f0 2b e0 	call (m) $_get_metadata_buffer;
84200156:	16 00       	r4 = r0 + Null;
        metadata_op_buffer = get_metadata_buffer(splitter, FALSE, 0);
84200158:	04 00       	r2 = Null + Null;
8420015a:	03 00       	r1 = Null + Null;
8420015c:	4a 08       	r0 = r7 + Null;
8420015e:	0b f0 3f ef 	call (m) $_get_metadata_buffer;
84200162:	17 00       	r5 = r0 + Null;
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
84200164:	71 89       	rMAC = M[r4 + 20];
84200166:	49 c6       	rMAC = rMAC AND 0x8000;
84200168:	51 60       	if EQ jump (m) Lc_splitter_process_data_51;

8420016a <Lc_splitter_process_data_37>:
        if (buff_has_metadata(metadata_ip_buffer))
        {
            /* Transport all the available metadata. The available tags will be limited by
             * the cbuffer available data. This will eliminate difference between
             * octet and _ex buffers. */
            octets_moved =  buff_metadata_available_octets(metadata_ip_buffer);
8420016a:	32 00       	r0 = r4 + Null;
8420016c:	ff fd 8d f0 	call (m) 0x11d04;
84200170:	39 ec 
84200172:	10 09       	r6 = r0 + Null;

84200174 <Lc_splitter_process_data_38>:
        }

        /* Transport any metadata to the output. */
        metadata_strict_transport(metadata_ip_buffer,
                                    metadata_op_buffer,
                                    octets_moved);
84200174:	44 08       	r2 = r6 + Null;
84200176:	3b 00       	r1 = r5 + Null;
84200178:	32 00       	r0 = r4 + Null;
8420017a:	ff fd 8f f0 	call (m) 0x12076;
8420017e:	3d e7 
#endif /* INSTALL_METADATA */
        channel = splitter->channel_list;
84200180:	9b f0 00 e8 	r9 = M[r7 + Null];
84200184:	12 6e       	jump (m) Lc_splitter_process_data_43;

84200186 <Lc_splitter_process_data_39>:
                    /* If the output is disabled and connected metadata is created
                     * for the output and not consumed by anyone. Delete those metadata.
                     * NOTE: It would be better not to create it in the first place, but
                     * that involves the splitter to take care of the metadata transport. */
                    tCbuffer *out = channel->output_buffer[i];
                    if (out)
84200186:	32 e8       	r0 = M[r4 + Null];
84200188:	0a 60       	if EQ jump (m) Lc_splitter_process_data_41;

8420018a <Lc_splitter_process_data_40>:
                    {
                        metadata_tag *ret_mtag;
                        unsigned b4idx, afteridx;
                        ret_mtag = buff_metadata_remove(out, octets_moved, &b4idx, &afteridx);
8420018a:	c5 12       	r3 = FP + 44;
8420018c:	84 12       	r2 = FP + 40;
8420018e:	43 08       	r1 = r6 + Null;
84200190:	ff fd 8d f0 	call (m) 0x11d7a;
84200194:	2b ef 
                        buff_metadata_tag_list_delete(ret_mtag);
84200196:	ff fd 8b f0 	call (m) 0x11906;
8420019a:	31 eb 

8420019c <Lc_splitter_process_data_41>:
                                    octets_moved);
#endif /* INSTALL_METADATA */
        channel = splitter->channel_list;
        while (NULL != channel)
        {
            for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420019c:	7f 20       	r5 = r5 + 1;
8420019e:	36 21       	r4 = r4 + 4;
842001a0:	b8 24       	Null = r5 - 2;
842001a2:	09 64       	if NC jump (m) Lc_splitter_process_data_45;

842001a4 <Lc_splitter_process_data_42>:
                        buff_metadata_tag_list_delete(ret_mtag);
                    }
                }
#endif /* INSTALL_METADATA */
            }
            channel = channel->next;
842001a4:	bb f0 00 e8 	r9 = M[r9 + Null];

842001a8 <Lc_splitter_process_data_43>:
        metadata_strict_transport(metadata_ip_buffer,
                                    metadata_op_buffer,
                                    octets_moved);
#endif /* INSTALL_METADATA */
        channel = splitter->channel_list;
        while (NULL != channel)
842001a8:	0f fb 00 c2 	Null = r9 - Null;
842001ac:	15 60       	if EQ jump (m) Lc_splitter_process_data_49;

842001ae <Lc_splitter_process_data_44>:
        {
            for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842001ae:	07 00       	r5 = Null + Null;
842001b0:	b6 f0 0c 20 	r4 = r9 + 12;

842001b4 <Lc_splitter_process_data_45>:
842001b4:	91 f0 18 20 	rMAC = r7 + 24;
842001b8:	c9 e1       	rMAC = MBS[rMAC + r5];
            {
                if (get_current_output_state(splitter, i) == ACTIVE)
842001ba:	48 24       	Null = rMAC - 1;
842001bc:	e5 63       	if NE jump (m) Lc_splitter_process_data_39;

842001be <Lc_splitter_process_data_46>:
                {
                    tCbuffer *out = channel->output_buffer[i];
842001be:	32 e8       	r0 = M[r4 + Null];
                    new_output_write_addr = (int *)((char *)out->write_ptr + min_new_data);
842001c0:	91 88       	rMAC = M[r0 + 8];
842001c2:	51 0c       	rMAC = r8 + rMAC;
                    if (new_output_write_addr >= (int *)((char *)out->base_addr + out->size))
842001c4:	13 e8       	r1 = M[r0 + Null];
842001c6:	d4 88       	r2 = M[r0 + 12];
842001c8:	1c 01       	r2 = r1 + r2;
842001ca:	08 05       	Null = rMAC - r2;
842001cc:	03 64       	if NC jump (m) Lc_splitter_process_data_48;

842001ce <Lc_splitter_process_data_47>:
                    {
                        new_output_write_addr = (int *)((char *)new_output_write_addr - out->size);
842001ce:	c3 04       	r1 = Null - r1;
842001d0:	59 00       	rMAC = r1 + rMAC;

842001d2 <Lc_splitter_process_data_48>:
                    }
                    out->write_ptr = new_output_write_addr;
842001d2:	91 8e       	M[r0 + 8] = rMAC;
842001d4:	e4 6f       	jump (m) Lc_splitter_process_data_41;

842001d6 <Lc_splitter_process_data_49>:
                }
#endif /* INSTALL_METADATA */
            }
            channel = channel->next;
        }
        touched->sources = splitter->touched_sources;
842001d6:	91 f0 05 88 	rMAC = M[r7 + 20];
842001da:	4a d8       	r0 = M[FP + 36];
842001dc:	11 ee       	M[r0 + Null] = rMAC;

842001de <Lc_splitter_process_data_50>:
    }

    timer_schedule_event_in_atomic(SPLITTER_SELF_KICK_RATIO * stream_if_get_system_kick_period(),
        splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
842001de:	ff fd 65 f1 	call (m) 0x2cc9c;
842001e2:	3f e5 
842001e4:	ff fd 35 f0 	call (m) 0x6dc0;
842001e8:	3d ee 
842001ea:	42 f0 06 f0 	r4 = Null + 69213539;
842001ee:	63 79 
842001f0:	17 54       	r5 = r0 LSHIFT 1;
        INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(hal_get_time(), time_in), TimerEventFunction, data_pointer);
842001f2:	ff fd 8a f1 	call (m) 0x317e8;
842001f6:	37 ef 
842001f8:	ba 00       	r0 = r5 + r0;
842001fa:	33 00       	r1 = r4 + Null;
842001fc:	44 d8       	r2 = M[FP + 32];
842001fe:	ff fd 9f f0 	call (m) 0x1402a;
84200202:	2d e1 
}
84200204:	92 f0 09 8e 	M[r7 + 36] = r0;
84200208:	36 6e       	jump (m) Lc_splitter_process_data_60;

8420020a <Lc_splitter_process_data_51>:
        else
        {
            /* There is no metadata for the input buffer, but still update the output
             * buffer metadata write index. Due to the lack of the metadata (so no info on
             * the usable octets) min_new_data is a fair approximation.  */
            octets_moved = min_new_data;
8420020a:	50 09       	r6 = r8 + Null;
8420020c:	b4 6f       	jump (m) Lc_splitter_process_data_38;

8420020e <Lc_splitter_process_data_52>:
        }
        else
#endif
        {
            /* Pack data to the internal buffer only if packing is not in progress. */
            if (data_to_pack != 0)
8420020e:	18 04       	Null = r1 - Null;
84200210:	04 60       	if EQ jump (m) Lc_splitter_process_data_54;

84200212 <Lc_splitter_process_data_53>:
            {
                /* Pack/Copy to internal buffer. */
                pack_to_internal(splitter, data_to_pack, FALSE);
84200212:	04 00       	r2 = Null + Null;
84200214:	32 00       	r0 = r4 + Null;
84200216:	dc 4e       	call (m) Lc_pack_to_internal_1;

84200218 <Lc_splitter_process_data_54>:
            }
            /* Unpack/Copy from internal to the output as much as possible*/
            move_data_from_internal_to_output(splitter);
84200218:	32 00       	r0 = r4 + Null;
8420021a:	f3 4e       	call (m) Lc_move_data_from_internal_to_output_1;

8420021c <Lc_splitter_process_data_55>:
        /* If this is a debug build check if the buffers are still aligned. */
        SPLITTER_DEBUG_INSTR(check_buffers_validity(splitter));
    }

    /* Kick backwards and forwards */
    if (splitter->kick_backward)
8420021c:	62 f0 68 82 	r0 = MBU[r4 + 104];
84200220:	d3 50       	r1 = r0 LSHIFT -4;
84200222:	19 c0       	rMAC = r1 AND 0x1;
84200224:	08 60       	if EQ jump (m) Lc_splitter_process_data_57;

84200226 <Lc_splitter_process_data_56>:
    {
        splitter->kick_backward = FALSE;
84200226:	21 ff ef 1f 	rMAC = r0 AND 0xffffffef;
8420022a:	61 f0 68 8a 	MB[r4 + 104] = rMAC;
        touched->sinks = splitter->touched_sinks;
8420022e:	31 89       	rMAC = M[r4 + 16];
84200230:	4a d8       	r0 = M[FP + 36];
84200232:	51 8e       	M[r0 + 4] = rMAC;

84200234 <Lc_splitter_process_data_57>:
    }
    if (splitter->kick_forward)
84200234:	62 f0 68 82 	r0 = MBU[r4 + 104];
84200238:	93 50       	r1 = r0 LSHIFT -3;
8420023a:	19 c0       	rMAC = r1 AND 0x1;
8420023c:	08 60       	if EQ jump (m) Lc_splitter_process_data_59;

8420023e <Lc_splitter_process_data_58>:
    {
        splitter->kick_forward = FALSE;
8420023e:	21 ff f7 1f 	rMAC = r0 AND 0xfffffff7;
84200242:	61 f0 68 8a 	MB[r4 + 104] = rMAC;
        touched->sources = splitter->touched_sources;
84200246:	71 89       	rMAC = M[r4 + 20];
84200248:	4a d8       	r0 = M[FP + 36];
8420024a:	11 ee       	M[r0 + Null] = rMAC;

8420024c <Lc_splitter_process_data_59>:
    }
    kick_period = stream_if_get_system_kick_period();
8420024c:	ff fd 35 f0 	call (m) 0x6dc0;
84200250:	35 eb 
84200252:	17 00       	r5 = r0 + Null;
         * offloading is not enabled. */
        kick_period = kick_period * 2;
    }
#endif
    timer_schedule_event_in_atomic(kick_period,
        splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
84200254:	ff fd 65 f1 	call (m) 0x2cc9c;
84200258:	29 e2 
8420025a:	42 f0 08 f0 	r6 = Null + 69213539;
8420025e:	63 79 
        INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(hal_get_time(), time_in), TimerEventFunction, data_pointer);
84200260:	ff fd 8a f1 	call (m) 0x317e8;
84200264:	29 ec 
84200266:	ba 00       	r0 = r5 + r0;
84200268:	43 08       	r1 = r6 + Null;
8420026a:	44 d8       	r2 = M[FP + 32];
8420026c:	ff fd 9e f0 	call (m) 0x1402a;
84200270:	3f ed 
}
84200272:	72 9e       	M[r4 + 36] = r0;

84200274 <Lc_splitter_process_data_60>:
        }
        touched->sources = splitter->touched_sources;
    }

    timer_schedule_event_in_atomic(SPLITTER_SELF_KICK_RATIO * stream_if_get_system_kick_period(),
        splitter_timer_task, (void*)op_data, &splitter->self_kick_timer);
84200274:	ff fd 65 f1 	call (m) 0x2ccb8;
84200278:	25 e2 

8420027a <Lc_splitter_process_data_61>:

    switch (splitter->working_mode)
    {
        case CLONE_BUFFER:
            splitter_process_data_clone(op_data, touched);
            break;
8420027a:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420027c:	d8 4c       	rts;

8420027e <$_splitter_transition>:

/**
 * Function which handles the transitions for the splitter capability.
 */
bool splitter_transition(SPLITTER_OP_DATA *splitter)
{
8420027e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200280:	17 00       	r5 = r0 + Null;
    SPLITTER_CHANNEL_STRUC *channel;
    unsigned i;
    SPLITTER_OUTPUT_STATE next_state;
    SPLITTER_OUTPUT_STATE current_state;
    bool retval = TRUE;
84200282:	08 71       	r6 = Null + 1;

    channel = splitter->channel_list;
    if (channel == NULL)
84200284:	39 e8       	rMAC = M[r5 + Null];
84200286:	03 62       	if NE jump (m) Lc_splitter_transition_3;

84200288 <Lc_splitter_transition_2>:
    {
        /* There are no connections, the transition will
         * be handled by connect or channel creation.
         */
        return TRUE;
84200288:	42 08       	r0 = r6 + Null;
8420028a:	3c 6e       	jump (m) Lc_splitter_transition_21;

8420028c <Lc_splitter_transition_3>:
    }

    SPLITTER_MSG("splitter_transition method called!");

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420028c:	06 00       	r4 = Null + Null;

8420028e <Lc_splitter_transition_4>:
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
8420028e:	31 00       	rMAC = r4 + Null;
84200290:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
    if (splitter->active_streams & channel_mask)
84200294:	bb b2       	r1 = MBU[r5 + 26];
84200296:	99 10       	rMAC = r1 AND r0;
84200298:	89 c0       	rMAC = rMAC AND 0x3;
8420029a:	2e 60       	if EQ jump (m) Lc_splitter_transition_19;

8420029c <Lc_splitter_transition_5>:
    {
        return ACTIVE;
8420029c:	41 20       	rMAC = Null + 1;
8420029e:	08 6e       	jump (m) Lc_splitter_transition_7;

842002a0 <Lc_splitter_transition_6>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
    {
        return HOLD;
842002a0:	db 50       	r1 = r1 LSHIFT -4;
842002a2:	99 10       	rMAC = r1 AND r0;
842002a4:	8a c0       	r0 = rMAC AND 0x3;
842002a6:	01 00       	rMAC = Null + Null;
842002a8:	10 04       	Null = r0 - Null;
842002aa:	a1 f0 41 ce 	if NE rMAC = Null + 2;

842002ae <Lc_splitter_transition_7>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842002ae:	3a 2a       	r0 = r5 + 24;
842002b0:	92 e1       	r0 = MBS[r0 + r4];
        SPLITTER_MSG3("splitter_transition: Output stream %d transition from %d to %d "
                "(where 0 INACTIVE, 1 ACTIVE, 2 HOLD)",
                i, current_state, next_state);

        /* First metadata should be solved.*/
        if (current_state != next_state)
842002b2:	50 04       	Null = r0 - rMAC;
842002b4:	1c 60       	if EQ jump (m) Lc_splitter_transition_16;

842002b6 <Lc_splitter_transition_8>:
        {
            bool transition;

            switch (next_state)
842002b6:	08 04       	Null = rMAC - Null;
842002b8:	08 60       	if EQ jump (m) Lc_splitter_transition_11;

842002ba <Lc_splitter_transition_9>:
842002ba:	48 24       	Null = rMAC - 1;
842002bc:	0b 60       	if EQ jump (m) Lc_splitter_transition_12;

842002be <Lc_splitter_transition_10>:
                    transition = splitter_transition_to_active(splitter, i);
                    break;
                }
                case HOLD:
                {
                    transition = splitter_transition_to_hold(splitter, i);
842002be:	33 00       	r1 = r4 + Null;
842002c0:	3a 00       	r0 = r5 + Null;
842002c2:	04 f0 31 e8 	call (m) Lc_splitter_transition_to_hold_1;
                    break;
842002c6:	0a 6e       	jump (m) Lc_splitter_transition_13;

842002c8 <Lc_splitter_transition_11>:

            switch (next_state)
            {
                case INACTIVE:
                {
                    transition = splitter_transition_to_inactive(splitter, i);
842002c8:	33 00       	r1 = r4 + Null;
842002ca:	3a 00       	r0 = r5 + Null;
842002cc:	04 f0 3b e3 	call (m) Lc_splitter_transition_to_inactive_1;
                    break;
842002d0:	05 6e       	jump (m) Lc_splitter_transition_13;

842002d2 <Lc_splitter_transition_12>:
                }
                case ACTIVE:
                {
                    transition = splitter_transition_to_active(splitter, i);
842002d2:	33 00       	r1 = r4 + Null;
842002d4:	3a 00       	r0 = r5 + Null;
842002d6:	02 f0 23 e8 	call (m) Lc_splitter_transition_to_active_1;

842002da <Lc_splitter_transition_13>:
                    PL_ASSERT(next_state < NR_OF_STATE);
                }
            }
            /* All channel transition must be terminated to
             * finish the overall transition. */
            retval = transition && retval;
842002da:	10 04       	Null = r0 - Null;
842002dc:	07 60       	if EQ jump (m) Lc_splitter_transition_15;

842002de <Lc_splitter_transition_14>:
842002de:	41 08       	rMAC = r6 + Null;
842002e0:	00 09       	r6 = Null + Null;
842002e2:	08 04       	Null = rMAC - Null;
842002e4:	21 f0 48 ce 	if NE r6 = Null + 1;
842002e8:	02 6e       	jump (m) Lc_splitter_transition_16;

842002ea <Lc_splitter_transition_15>:
842002ea:	00 09       	r6 = Null + Null;

842002ec <Lc_splitter_transition_16>:
        return TRUE;
    }

    SPLITTER_MSG("splitter_transition method called!");

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842002ec:	76 20       	r4 = r4 + 1;
842002ee:	b0 24       	Null = r4 - 2;
842002f0:	cf 65       	if NC jump (m) Lc_splitter_transition_4;

842002f2 <Lc_splitter_transition_18>:
        }/* end of state transition. */
    }
    SPLITTER_MSG1("splitter_transition: returns %d", retval);
    /* If this is a debug build check if the buffers are still aligned. */
    SPLITTER_DEBUG_INSTR(check_buffers_validity(splitter));
    return retval;
842002f2:	42 08       	r0 = r6 + Null;
842002f4:	07 6e       	jump (m) Lc_splitter_transition_21;

842002f6 <Lc_splitter_transition_19>:
    channel_mask = 1<<index;
    if (splitter->active_streams & channel_mask)
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
842002f6:	5c 50       	r2 = r1 LSHIFT -2;
842002f8:	a1 10       	rMAC = r2 AND r0;
842002fa:	89 c0       	rMAC = rMAC AND 0x3;
842002fc:	d2 61       	if EQ jump (m) Lc_splitter_transition_6;

842002fe <Lc_splitter_transition_20>:
    {
        return INACTIVE;
842002fe:	01 00       	rMAC = Null + Null;
84200300:	d7 6f       	jump (m) Lc_splitter_transition_7;

84200302 <Lc_splitter_transition_21>:
}
84200302:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200304:	d8 4c       	rts;

84200306 <Lc_amount_to_pack_1>:

/**
 * Helper function to calculate the amount to pack/copy to the internal buffer.
 */
static unsigned amount_to_pack(SPLITTER_OP_DATA *splitter)
{
84200306:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200308:	10 09       	r6 = r0 + Null;
    tCbuffer *in;

    /* When reframing make sure that the we are not consuming less than
     * the minimum frame size. If in transition do not limit to
     * frame size to make the transition faster.  */
    if (splitter->reframe_enabled && !splitter->in_transition)
8420030a:	82 f0 68 82 	r0 = MBU[r6 + 104];
8420030e:	12 50       	r0 = r0 LSHIFT -1;
84200310:	11 c0       	rMAC = r0 AND 0x1;
84200312:	0e 60       	if EQ jump (m) Lc_amount_to_pack_6;

84200314 <Lc_amount_to_pack_2>:
84200314:	80 f0 07 88 	Null = M[r6 + 28];
84200318:	0b 62       	if NE jump (m) Lc_amount_to_pack_6;

8420031a <Lc_amount_to_pack_3>:
    {
        min_data = splitter->frame_size;
8420031a:	89 f0 0b 88 	r7 = M[r6 + 44];
        /* covert the minimum data to octets if needed.*/
        if (splitter->cbuffer.data_size == 1)
8420031e:	81 f0 25 88 	rMAC = M[r6 + 148];
84200322:	48 24       	Null = rMAC - 1;
84200324:	03 62       	if NE jump (m) Lc_amount_to_pack_5;

84200326 <Lc_amount_to_pack_4>:

/** Converts words to octets */
static inline unsigned words_to_octets(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val * ADDR_PER_WORD;
84200326:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;

8420032a <Lc_amount_to_pack_5>:
        {
            min_data = words_to_octets(min_data);
        }
        data_to_pack = min_data;
8420032a:	4e 08       	r4 = r7 + Null;
8420032c:	03 6e       	jump (m) Lc_amount_to_pack_7;

8420032e <Lc_amount_to_pack_6>:
    }
    else
    {
        /* If we have less than 1 word or octets just exit. */
        min_data = 1;
8420032e:	09 71       	r7 = Null + 1;
        data_to_pack = UINT_MAX;
84200330:	46 24       	r4 = Null - 1;

84200332 <Lc_amount_to_pack_7>:
    }

    /* Get the minimum available data for all inputs. */
    channel = splitter->channel_list;
84200332:	87 f0 00 e8 	r5 = M[r6 + Null];
84200336:	17 6e       	jump (m) Lc_amount_to_pack_16;

84200338 <Lc_amount_to_pack_8>:
            {
                /* Exit early if there is not enough data. */
                return 0;
            }
            /* Limit data. */
            data_to_pack = new_data;
84200338:	16 00       	r4 = r0 + Null;

8420033a <Lc_amount_to_pack_9>:
8420033a:	a1 f0 05 88 	rMAC = M[r8 + 20];
8420033e:	49 c6       	rMAC = rMAC AND 0x8000;
84200340:	11 60       	if EQ jump (m) Lc_amount_to_pack_15;

84200342 <Lc_amount_to_pack_10>:
        }
        /* Calculate the minimum available metadata.*/
        if (buff_has_metadata(in))
        {
            new_data = buff_metadata_available_octets(in);
84200342:	52 08       	r0 = r8 + Null;
84200344:	ff fd 8c f0 	call (m) 0x11d04;
84200348:	21 ee 
            if (splitter->cbuffer.data_size == 4)
8420034a:	81 f0 25 88 	rMAC = M[r6 + 148];
8420034e:	08 25       	Null = rMAC - 4;
84200350:	02 62       	if NE jump (m) Lc_amount_to_pack_12;

84200352 <Lc_amount_to_pack_11>:

/** Converts octets to samples. The operation rounds down. */
static inline unsigned octets_to_samples(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val / OCTETS_PER_SAMPLE;
84200352:	52 50       	r0 = r0 LSHIFT -2;

84200354 <Lc_amount_to_pack_12>:
            {
                new_data = octets_to_samples(new_data);
            }
            if (new_data < data_to_pack)
84200354:	90 05       	Null = r0 - r4;
84200356:	02 f0 8d e0 	if C jump (m) Lc_amount_to_pack_15;

8420035a <Lc_amount_to_pack_13>:
            {
                SPLITTER_MSG2("Splitter: Input limited by the available metadata!"
                        "\n limiting %d to %d", data_to_pack, new_data);
                if (new_data < min_data)
8420035a:	9f f2 00 c2 	Null = r0 - r7;
8420035e:	14 64       	if NC jump (m) Lc_amount_to_pack_20;

84200360 <Lc_amount_to_pack_14>:
                {
                    /* Exit early if there is not enough data. */
                    return 0;
                }
                data_to_pack = new_data;
84200360:	16 00       	r4 = r0 + Null;

84200362 <Lc_amount_to_pack_15>:
            }
        }
        channel = channel->next;
84200362:	3f e8       	r5 = M[r5 + Null];

84200364 <Lc_amount_to_pack_16>:
    /* Get the minimum available data for all inputs. */
    channel = splitter->channel_list;
    /* We must have at least one channel. */
    SPLITTER_DEBUG_INSTR(PL_ASSERT(channel != NULL));

    while ((channel != NULL) && (data_to_pack != 0))
84200364:	38 04       	Null = r5 - Null;
84200366:	12 60       	if EQ jump (m) Lc_amount_to_pack_21;

84200368 <Lc_amount_to_pack_17>:
84200368:	30 04       	Null = r4 - Null;
8420036a:	10 60       	if EQ jump (m) Lc_amount_to_pack_21;

8420036c <Lc_amount_to_pack_18>:
    {
        in = channel->input_buffer;
8420036c:	7a f0 02 88 	r8 = M[r5 + 8];

        /* Calculate the minimum available data.*/
        new_data = splitter->cbuffer.data(in);
84200370:	81 f0 1c 88 	rMAC = M[r6 + 112];
84200374:	52 08       	r0 = r8 + Null;
84200376:	d1 4c       	call rMAC;
        if (new_data < data_to_pack)
84200378:	90 05       	Null = r0 - r4;
8420037a:	f2 ff c1 ef 	if C jump (m) Lc_amount_to_pack_9;

8420037e <Lc_amount_to_pack_19>:
        {
            if (new_data < min_data)
8420037e:	9f f2 00 c2 	Null = r0 - r7;
84200382:	f2 ff b7 ef 	if C jump (m) Lc_amount_to_pack_8;

84200386 <Lc_amount_to_pack_20>:
            {
                /* Exit early if there is not enough data. */
                return 0;
84200386:	02 00       	r0 = Null + Null;
84200388:	21 6e       	jump (m) Lc_amount_to_pack_29;

8420038a <Lc_amount_to_pack_21>:
/**
 * Returns the space in the metadat buffer.
 */
static inline unsigned get_interal_metadata_space(SPLITTER_OP_DATA *splitter)
{
    unsigned metadata_space_correction = 0;
8420038a:	07 00       	r5 = Null + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
8420038c:	82 f0 15 88 	r0 = M[r6 + 84];
    tCbuffer *metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Cbuffer leaves a word free to avoid overlaping read and write
     * pointers while the metadata works with offset. To avoid
     * differences the meadata space needs correction.*/
    if (splitter->tag_size_to_samples)
84200390:	83 f0 68 82 	r1 = MBU[r6 + 104];
84200394:	5b 50       	r1 = r1 LSHIFT -2;
84200396:	19 c0       	rMAC = r1 AND 0x1;
84200398:	08 60       	if EQ jump (m) Lc_amount_to_pack_23;

8420039a <Lc_amount_to_pack_22>:
    {
        if (splitter->packing == PACKED)
        {
            metadata_space_correction = 1;
8420039a:	81 f0 06 80 	rMAC = MBS[r6 + 6];
8420039e:	07 00       	r5 = Null + Null;
842003a0:	48 24       	Null = rMAC - 1;
842003a2:	20 f0 47 ce 	if EQ r5 = Null + 1;
842003a6:	06 6e       	jump (m) Lc_amount_to_pack_25;

842003a8 <Lc_amount_to_pack_23>:
        else
        {
            metadata_space_correction = 0;
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
842003a8:	81 f0 25 88 	rMAC = M[r6 + 148];
842003ac:	48 24       	Null = rMAC - 1;
842003ae:	02 62       	if NE jump (m) Lc_amount_to_pack_25;

842003b0 <Lc_amount_to_pack_24>:
    {
        metadata_space_correction = 3;
842003b0:	c7 20       	r5 = Null + 3;

842003b2 <Lc_amount_to_pack_25>:
    }

    return (buff_metadata_available_space(metadata_buffer) - metadata_space_correction);
842003b2:	ff fd 8c f0 	call (m) 0x11d42;
842003b6:	31 ec 
842003b8:	d1 05       	rMAC = r0 - r5;

    /* Calculate the internal space. It is enough to do it for one channel
     * because the internal buffer is synced. Also there is no need to check
     * for the data as we keep this buffer synced with the metadata.*/
    new_data = get_interal_metadata_space(splitter);
    if (new_data < data_to_pack)
842003ba:	88 05       	Null = rMAC - r4;
842003bc:	02 f0 8d e0 	if C jump (m) Lc_amount_to_pack_28;

842003c0 <Lc_amount_to_pack_26>:
    {
        if (new_data < min_data)
842003c0:	9f f1 00 c2 	Null = rMAC - r7;
842003c4:	e1 65       	if NC jump (m) Lc_amount_to_pack_20;

842003c6 <Lc_amount_to_pack_27>:
        {
            /* Exit early if there is not enough data. */
            return 0;
        }
        /* Limit data. */
        data_to_pack = new_data;
842003c6:	0e 00       	r4 = rMAC + Null;

842003c8 <Lc_amount_to_pack_28>:
    {
        splitter->internal_buffer_full = FALSE;
#endif
    }

    return data_to_pack;
842003c8:	32 00       	r0 = r4 + Null;

842003ca <Lc_amount_to_pack_29>:
}
842003ca:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842003cc:	d8 4c       	rts;

842003ce <Lc_pack_to_internal_1>:

/**
 * Helper function which packs or copies data to the internal buffer.
 */
static void pack_to_internal(SPLITTER_OP_DATA *splitter, unsigned data_to_pack, bool offload_enabled)
{
842003ce:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842003d0:	16 00       	r4 = r0 + Null;
842003d2:	1f 00       	r5 = r1 + Null;
    /* Transport metadata to the internal buffer. */
    splitter_metadata_transport_to_internal(
            splitter,
            data_to_pack
    );
842003d4:	0a f0 3d ed 	call (m) $_splitter_metadata_transport_to_internal;
    }
    else
#endif
    {
        /* Just call the function directly. */
        pack_to_internal_data_buffer(splitter, data_to_pack);
842003d8:	3b 00       	r1 = r5 + Null;
842003da:	32 00       	r0 = r4 + Null;
842003dc:	61 4e       	call (m) Lc_pack_to_internal_data_buffer_1;
     * Remove all the data from the internal buffer if both outputs
     * are disabled.
     * TODO make this more efficient by not copying at all, just
     * updating the appropriate pointer.
     */
    if (!splitter->in_transition)
842003de:	f0 89       	Null = M[r4 + 28];
842003e0:	0e 62       	if NE jump (m) Lc_pack_to_internal_5;

842003e2 <Lc_pack_to_internal_2>:
    {
        if ((get_current_output_state(splitter, 0) == INACTIVE)&&
            (get_current_output_state(splitter, 1) == INACTIVE))
842003e2:	31 b0       	rMAC = MBS[r4 + 24];
842003e4:	0c 62       	if NE jump (m) Lc_pack_to_internal_5;

842003e6 <Lc_pack_to_internal_3>:
842003e6:	71 b0       	rMAC = MBS[r4 + 25];
842003e8:	0a 62       	if NE jump (m) Lc_pack_to_internal_5;

842003ea <Lc_pack_to_internal_4>:
        {
            /* remove the metadata */
            remove_metadata_from_internal(splitter, data_to_pack);
842003ea:	3b 00       	r1 = r5 + Null;
842003ec:	32 00       	r0 = r4 + Null;
842003ee:	0c f0 37 e0 	call (m) $_remove_metadata_from_internal;
            /* remove the data by copying 0 0 but  removing data */
            unpack_data_from_internal_to_output(splitter, 0, 0, data_to_pack);
842003f2:	04 00       	r2 = Null + Null;
842003f4:	03 00       	r1 = Null + Null;
842003f6:	3d 00       	r3 = r5 + Null;
842003f8:	32 00       	r0 = r4 + Null;
842003fa:	94 4e       	call (m) Lc_unpack_data_from_internal_to_output_1;

842003fc <Lc_pack_to_internal_5>:
        }
    }


    return;
}
842003fc:	f2 48       	popm <FP, r4, r5, rLink>;
842003fe:	d8 4c       	rts;

84200400 <Lc_move_data_from_internal_to_output_1>:

/**
 * Helper function which moves data from the internal buffer to the output buffers
 */
static bool move_data_from_internal_to_output(SPLITTER_OP_DATA *splitter)
{
84200400:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200402:	16 00       	r4 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200404:	72 a9       	r0 = M[r4 + 84];
    unsigned internal_data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];
    unsigned data_to_remove;


    /* bail out early if the internal buffer is empty. */
    if (buff_metadata_available_octets(get_internal_metadata_buffer(splitter)) == 0)
84200406:	ff fd 8c f0 	call (m) 0x11d04;
8420040a:	3f e7 
8420040c:	10 04       	Null = r0 - Null;
8420040e:	03 62       	if NE jump (m) Lc_move_data_from_internal_to_output_3;

84200410 <Lc_move_data_from_internal_to_output_2>:
        {
            splitter->internal_buffer_empty = TRUE;
            SPLITTER_MSG("Splitter: Internal buffer is empty, cannot copy to output!");
        }
#endif
        return FALSE;
84200410:	02 00       	r0 = Null + Null;
84200412:	44 6e       	jump (m) Lc_move_data_from_internal_to_output_22;

84200414 <Lc_move_data_from_internal_to_output_3>:
    }
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);
84200414:	83 11       	r1 = FP + 24;
84200416:	32 00       	r0 = r4 + Null;
84200418:	01 f0 39 e4 	call (m) Lc_internal_buffer_data_1;

    if (MAX(internal_data_before[0], internal_data_before[1]) == 0 )
8420041c:	37 d8       	r5 = M[FP + 24];
8420041e:	39 d8       	rMAC = M[FP + 28];
84200420:	78 04       	Null = r5 - rMAC;
84200422:	02 f0 9d e0 	if C jump (m) Lc_move_data_from_internal_to_output_9;

84200426 <Lc_move_data_from_internal_to_output_4>:
84200426:	0a 00       	r0 = rMAC + Null;

84200428 <Lc_move_data_from_internal_to_output_5>:
        return FALSE;
    }
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    if((splitter->output_state[0] == INACTIVE)&&
       (splitter->output_state[1] == INACTIVE))
84200428:	32 b0       	r0 = MBS[r4 + 24];
8420042a:	0e 62       	if NE jump (m) Lc_move_data_from_internal_to_output_11;

8420042c <Lc_move_data_from_internal_to_output_6>:
8420042c:	72 b0       	r0 = MBS[r4 + 25];
8420042e:	0c 62       	if NE jump (m) Lc_move_data_from_internal_to_output_11;

84200430 <Lc_move_data_from_internal_to_output_7>:
    {
        /* Both of the output streams are inactive. No need to copy to output */
        data_to_move[0] = 0;
84200430:	20 de       	M[FP + 16] = Null;
        data_to_move[1] = 0;
84200432:	28 de       	M[FP + 20] = Null;
        /* Remove the maximum amount possible. */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
84200434:	78 04       	Null = r5 - rMAC;
84200436:	02 f0 8f e0 	if C jump (m) Lc_move_data_from_internal_to_output_10;

8420043a <Lc_move_data_from_internal_to_output_8>:
8420043a:	0f 00       	r5 = rMAC + Null;
8420043c:	24 6e       	jump (m) Lc_move_data_from_internal_to_output_21;

8420043e <Lc_move_data_from_internal_to_output_9>:
    SPLITTER_DEBUG_INSTR(splitter->internal_buffer_empty = FALSE);

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);

    if (MAX(internal_data_before[0], internal_data_before[1]) == 0 )
8420043e:	3a 00       	r0 = r5 + Null;
84200440:	e8 61       	if EQ jump (m) Lc_move_data_from_internal_to_output_2;

84200442 <Lc_17>:
84200442:	f3 6f       	jump (m) Lc_move_data_from_internal_to_output_5;

84200444 <Lc_move_data_from_internal_to_output_10>:
    {
        /* Both of the output streams are inactive. No need to copy to output */
        data_to_move[0] = 0;
        data_to_move[1] = 0;
        /* Remove the maximum amount possible. */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
84200444:	20 6e       	jump (m) Lc_move_data_from_internal_to_output_21;

84200446 <Lc_move_data_from_internal_to_output_11>:
                data_to_remove);
    }
    else
    {
        /* Limit the amount to copy to the available data */
        data_to_move[0] = internal_data_before[0];
84200446:	27 de       	M[FP + 16] = r5;
        data_to_move[1] = internal_data_before[1];
84200448:	29 de       	M[FP + 20] = rMAC;

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);
8420044a:	03 11       	r1 = FP + 16;
8420044c:	32 00       	r0 = r4 + Null;
8420044e:	01 f0 3b e5 	call (m) Lc_limit_data_to_move_1;

        /* Exit early if there is no place to copy. */
        if (MAX(data_to_move[0], data_to_move[1]) == 0 )
84200452:	22 d8       	r0 = M[FP + 16];
84200454:	2b d8       	r1 = M[FP + 20];
84200456:	d0 04       	Null = r0 - r1;
84200458:	02 f0 95 e0 	if C jump (m) Lc_move_data_from_internal_to_output_15;

8420045c <Lc_move_data_from_internal_to_output_12>:
8420045c:	19 00       	rMAC = r1 + Null;

8420045e <Lc_move_data_from_internal_to_output_13>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
8420045e:	31 d8       	rMAC = M[FP + 24];
84200460:	3c d8       	r2 = M[FP + 28];
84200462:	08 05       	Null = rMAC - r2;
84200464:	02 f0 8f e0 	if C jump (m) Lc_move_data_from_internal_to_output_16;

84200468 <Lc_move_data_from_internal_to_output_14>:
84200468:	27 00       	r5 = r2 + Null;
8420046a:	05 6e       	jump (m) Lc_move_data_from_internal_to_output_17;

8420046c <Lc_move_data_from_internal_to_output_15>:

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);

        /* Exit early if there is no place to copy. */
        if (MAX(data_to_move[0], data_to_move[1]) == 0 )
8420046c:	11 00       	rMAC = r0 + Null;
8420046e:	d1 61       	if EQ jump (m) Lc_move_data_from_internal_to_output_2;

84200470 <Lc_18>:
84200470:	f7 6f       	jump (m) Lc_move_data_from_internal_to_output_13;

84200472 <Lc_move_data_from_internal_to_output_16>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
84200472:	0f 00       	r5 = rMAC + Null;

84200474 <Lc_move_data_from_internal_to_output_17>:
        data_to_remove = data_to_remove -  (
                MAX(internal_data_before[0] - data_to_move[0], internal_data_before[1] - data_to_move[1])
            );
84200474:	8a 04       	r0 = rMAC - r0;
84200476:	e1 04       	rMAC = r2 - r1;
84200478:	50 04       	Null = r0 - rMAC;
8420047a:	02 f0 87 e0 	if C jump (m) Lc_move_data_from_internal_to_output_19;

8420047e <Lc_move_data_from_internal_to_output_18>:
8420047e:	02 6e       	jump (m) Lc_move_data_from_internal_to_output_20;

84200480 <Lc_move_data_from_internal_to_output_19>:
84200480:	11 00       	rMAC = r0 + Null;

84200482 <Lc_move_data_from_internal_to_output_20>:
84200482:	7f 04       	r5 = r5 - rMAC;

84200484 <Lc_move_data_from_internal_to_output_21>:
                data_to_remove);
    }


    /* copy the metadata to the active output streams */
    splitter_metadata_copy(splitter, data_to_move, data_to_remove);
84200484:	03 11       	r1 = FP + 16;
84200486:	3c 00       	r2 = r5 + Null;
84200488:	32 00       	r0 = r4 + Null;
8420048a:	0b f0 27 e6 	call (m) $_splitter_metadata_copy;
    }
    else
#endif
    {
        /* Time to unpack/copy the data from the internal to the output */
        unpack_data_from_internal_to_output(splitter, data_to_move[0], data_to_move[1], data_to_remove);
8420048e:	2c d8       	r2 = M[FP + 20];
84200490:	23 d8       	r1 = M[FP + 16];
84200492:	3d 00       	r3 = r5 + Null;
84200494:	32 00       	r0 = r4 + Null;
84200496:	46 4e       	call (m) Lc_unpack_data_from_internal_to_output_1;
    }

    return TRUE;
84200498:	42 20       	r0 = Null + 1;

8420049a <Lc_move_data_from_internal_to_output_22>:

}
8420049a:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420049c:	d8 4c       	rts;

8420049e <Lc_pack_to_internal_data_buffer_1>:

/**
 * Helper function which packs for all channels to the internal buffer.
 */
static void pack_to_internal_data_buffer(SPLITTER_OP_DATA *splitter, unsigned data_to_pack)
{
8420049e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842004a0:	10 09       	r6 = r0 + Null;
842004a2:	1f 00       	r5 = r1 + Null;
            "data_pack = %d ",
            data_to_pack);
#endif

#ifdef SPLITTER_EXT_BUFFER
    if (splitter->location == SRAM)
842004a4:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842004a8:	48 24       	Null = rMAC - 1;
842004aa:	05 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_3;

842004ac <Lc_pack_to_internal_data_buffer_2>:
    {
        /* Get access to the SRAM.*/
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
842004ac:	03 00       	r1 = Null + Null;
842004ae:	02 00       	r0 = Null + Null;
842004b0:	0f f0 2d e5 	call (m) $_extmem_lock;

842004b4 <Lc_pack_to_internal_data_buffer_3>:
    }
#endif

    channel = splitter->channel_list;
842004b4:	86 f0 00 e8 	r4 = M[r6 + Null];
842004b8:	02 6e       	jump (m) Lc_pack_to_internal_data_buffer_5;

842004ba <Lc_pack_to_internal_data_buffer_4>:
    {
        /* Pack to the internal data buffer which can be located
         * in the sram or internally in the dsp. */
        pack_to_data_buffer(splitter, channel, data_to_pack);

        channel = channel->next;
842004ba:	36 e8       	r4 = M[r4 + Null];

842004bc <Lc_pack_to_internal_data_buffer_5>:
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
    }
#endif

    channel = splitter->channel_list;
    while (channel != NULL)
842004bc:	30 04       	Null = r4 - Null;
842004be:	0c 60       	if EQ jump (m) Lc_pack_to_internal_data_buffer_8;

842004c0 <Lc_pack_to_internal_data_buffer_6>:
 * Helper function which packs to the internal data buffer.
 */
static inline void pack_to_data_buffer(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned data_to_pack)
{
    unsigned packed;
    tCbuffer *in = channel->input_buffer;
842004c0:	b3 88       	r1 = M[r4 + 8];

    /* Select the correct interface */
    if (splitter->location == INTERNAL)
842004c2:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842004c6:	17 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_11;

842004c8 <Lc_pack_to_internal_data_buffer_7>:
    {
        tCbuffer *internal = channel->internal.buffer.dsp;
842004c8:	72 89       	r0 = M[r4 + 20];
        packed = splitter->cbuffer.pack(internal, in, data_to_pack);
842004ca:	81 f0 1e 88 	rMAC = M[r6 + 120];
842004ce:	3c 00       	r2 = r5 + Null;
842004d0:	d1 4c       	call rMAC;
842004d2:	13 00       	r1 = r0 + Null;
842004d4:	16 6e       	jump (m) Lc_pack_to_internal_data_buffer_12;

842004d6 <Lc_pack_to_internal_data_buffer_8>:

        channel = channel->next;
    }

#ifdef SPLITTER_EXT_BUFFER
    if (splitter->location == SRAM)
842004d6:	81 f0 05 80 	rMAC = MBS[r6 + 5];
842004da:	48 24       	Null = rMAC - 1;
842004dc:	04 62       	if NE jump (m) Lc_pack_to_internal_data_buffer_10;

842004de <Lc_pack_to_internal_data_buffer_9>:
    {
        /* Release the SRAM */
        extmem_unlock(EXTMEM_SPI_RAM);
842004de:	02 00       	r0 = Null + Null;
842004e0:	0f f0 2f e4 	call (m) $_extmem_unlock;

842004e4 <Lc_pack_to_internal_data_buffer_10>:
    }
#endif

    /* It is necessary to kick back whenever data is consumed so
     * so we can make full use of the internal buffer. */
    splitter->kick_backward = TRUE;
842004e4:	81 f0 68 82 	rMAC = MBU[r6 + 104];
842004e8:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
842004ec:	c9 c9       	rMAC = rMAC OR 0x10;
842004ee:	81 f0 68 8a 	MB[r6 + 104] = rMAC;
842004f2:	16 6e       	jump (m) Lc_pack_to_internal_data_buffer_14;

842004f4 <Lc_pack_to_internal_data_buffer_11>:
        packed = splitter->cbuffer.pack(internal, in, data_to_pack);
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        EXT_BUFFER * internal = channel->internal.buffer.sram;
842004f4:	72 89       	r0 = M[r4 + 20];
        packed = splitter->cbuffer.sram_pack(internal, in, data_to_pack);
842004f6:	81 f0 22 88 	rMAC = M[r6 + 136];
842004fa:	3c 00       	r2 = r5 + Null;
842004fc:	d1 4c       	call rMAC;
842004fe:	13 00       	r1 = r0 + Null;

84200500 <Lc_pack_to_internal_data_buffer_12>:
    }
    /* If the amount of data pack is different to then
     * amount_to_pack is incorrect or another error occurred.
     * There is no reason handling this case because it will
     * cause metadata problems further down the chain. */
    if (packed != data_to_pack)
84200500:	d8 05       	Null = r1 - r5;
84200502:	dc 61       	if EQ jump (m) Lc_pack_to_internal_data_buffer_4;

84200504 <Lc_pack_to_internal_data_buffer_13>:
    {
        SPLITTER_ERRORMSG1("Splitter Only packed = %d!",
                packed);
84200504:	55 f1 02 f0 	r0 = Null + 357564416;
84200508:	00 40 
8420050a:	ff fd 02 f0 	call (m) 0x9b4;
8420050e:	2b e5 
    }
    PL_ASSERT(packed == data_to_pack);
84200510:	03 f0 8d 41 	r1 = Null + 397;
84200514:	02 f0 13 60 	r0 = Null + 4115;
84200518:	ff fd 9c f0 	call (m) 0x13f12;
8420051c:	3b ef 

8420051e <Lc_pack_to_internal_data_buffer_14>:
#ifdef SPLITTER_OFFLOAD
    /* Processing finished! */
    splitter->buffer_access = FALSE;
    SPLITTER_MSG("Splitter: pack_to_internal_cbuffer finished");
#endif
}
8420051e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200520:	d8 4c       	rts;

84200522 <Lc_unpack_data_from_internal_to_output_1>:

/**
 * Helper function to copy/unpack from the internal to the output.
 */
static void unpack_data_from_internal_to_output(SPLITTER_OP_DATA *splitter, unsigned data_0, unsigned data_1, unsigned data_to_remove)
{
84200522:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200524:	4c 4c       	SP = SP + 48;
84200526:	13 09       	r9 = r0 + Null;
84200528:	43 de       	M[FP + 32] = r1;
8420052a:	4c de       	M[FP + 36] = r2;
8420052c:	55 de       	M[FP + 40] = r3;
    splitter->buffer_access = TRUE;
#endif


#ifdef SPLITTER_EXT_BUFFER
    if (splitter->location == SRAM)
8420052e:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200532:	48 24       	Null = rMAC - 1;
84200534:	05 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_3;

84200536 <Lc_unpack_data_from_internal_to_output_2>:
    {
        /* Get access to the SRAM.*/
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
84200536:	03 00       	r1 = Null + Null;
84200538:	02 00       	r0 = Null + Null;
8420053a:	0f f0 23 e1 	call (m) $_extmem_lock;

8420053e <Lc_unpack_data_from_internal_to_output_3>:
    }
#endif
    /* Time to unpack/copy the data from the internal to the output */
    channel = splitter->channel_list;
8420053e:	b1 f0 00 e8 	rMAC = M[r9 + Null];
84200542:	59 de       	M[FP + 44] = rMAC;
84200544:	13 6e       	jump (m) Lc_unpack_data_from_internal_to_output_9;

84200546 <Lc_unpack_data_from_internal_to_output_4>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
84200546:	63 d8       	r1 = M[FP + 48];
84200548:	6a d8       	r0 = M[FP + 52];
8420054a:	0e f0 2b ee 	call (m) $_ext_buffer_set_read_offset;

8420054e <Lc_unpack_data_from_internal_to_output_5>:
    while (channel != NULL)
    {
        unpack_from_data_buffer(splitter, channel, data_0, data_1);

        if (data_to_remove)
8420054e:	51 d8       	rMAC = M[FP + 40];
84200550:	0a 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_8;

84200552 <Lc_unpack_data_from_internal_to_output_6>:
 * Function discards data from the internal data buffer.
 */
static inline void remove_from_data_buffer(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned data_to_remove)
{
    /* Select the correct interface */
    if (splitter->location == INTERNAL)
84200552:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200556:	a3 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_38;

84200558 <Lc_unpack_data_from_internal_to_output_7>:
    {
        splitter->cbuffer.discard(channel->internal.buffer.dsp, data_to_remove);
84200558:	b1 f0 20 88 	rMAC = M[r9 + 128];
8420055c:	5a d8       	r0 = M[FP + 44];
8420055e:	52 89       	r0 = M[r0 + 20];
84200560:	53 d8       	r1 = M[FP + 40];
84200562:	d1 4c       	call rMAC;

84200564 <Lc_unpack_data_from_internal_to_output_8>:
            /* Discard the unused data. */
            remove_from_data_buffer(splitter, channel, data_to_remove);
        }

        /* Move to next channel. */
        channel = channel->next;
84200564:	59 d8       	rMAC = M[FP + 44];
84200566:	09 e8       	rMAC = M[rMAC + Null];
84200568:	59 de       	M[FP + 44] = rMAC;

8420056a <Lc_unpack_data_from_internal_to_output_9>:
        extmem_lock(EXTMEM_SPI_RAM, FALSE);
    }
#endif
    /* Time to unpack/copy the data from the internal to the output */
    channel = splitter->channel_list;
    while (channel != NULL)
8420056a:	59 d8       	rMAC = M[FP + 44];
8420056c:	13 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_12;

8420056e <Lc_unpack_data_from_internal_to_output_10>:
{
    data_buffer_t internal;
    unsigned read_offset;
    unsigned i;

    internal = channel->internal.buffer;
8420056e:	59 d8       	rMAC = M[FP + 44];
84200570:	02 14       	r0 = FP + 64;
84200572:	09 29       	rMAC = rMAC + 20;
84200574:	0b e8       	r1 = M[rMAC + Null];
84200576:	13 ee       	M[r0 + Null] = r1;
 * Returns the read offset of the internal buffer.
 */
static inline unsigned get_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer)
{

    if (splitter->location == INTERNAL)
84200578:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
8420057c:	83 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_36;

8420057e <Lc_unpack_data_from_internal_to_output_11>:
    {
        unsigned int offset, ret_val;
        tCbuffer *cbuffer = buffer->dsp;
8420057e:	82 d8       	r0 = M[FP + 64];
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
84200580:	d6 88       	r4 = M[r0 + 12];

        ret_val = (unsigned int)(uintptr_t)cbuffer_get_read_address_ex(cbuffer, &offset) - base_addr;
84200582:	83 13       	r1 = FP + 56;
84200584:	0e f0 27 e5 	call (m) $_cbuffer_get_read_address_ex;
84200588:	91 05       	rMAC = r0 - r4;
        ret_val += offset;
8420058a:	72 d8       	r0 = M[FP + 56];
8420058c:	51 00       	rMAC = r0 + rMAC;
        return ret_val;
8420058e:	61 de       	M[FP + 48] = rMAC;
84200590:	7d 6e       	jump (m) Lc_unpack_data_from_internal_to_output_37;

84200592 <Lc_unpack_data_from_internal_to_output_12>:
        /* Move to next channel. */
        channel = channel->next;
    }/* END of channel loop. */

#ifdef SPLITTER_EXT_BUFFER
    if (splitter->location == SRAM)
84200592:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
84200596:	48 24       	Null = rMAC - 1;
84200598:	04 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_14;

8420059a <Lc_unpack_data_from_internal_to_output_13>:
    {
        /* Release the SRAM */
        extmem_unlock(EXTMEM_SPI_RAM);
8420059a:	02 00       	r0 = Null + Null;
8420059c:	0e f0 33 ee 	call (m) $_extmem_unlock;

842005a0 <Lc_unpack_data_from_internal_to_output_14>:
    }
#endif

    /* It is necessary to kick forward whenever data is produced. */
    splitter->kick_forward = TRUE;
842005a0:	b1 f0 68 82 	rMAC = MBU[r9 + 104];
842005a4:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
842005a8:	49 c9       	rMAC = rMAC OR 0x8;
842005aa:	b1 f0 68 8a 	MB[r9 + 104] = rMAC;
842005ae:	7e 6e       	jump (m) Lc_unpack_data_from_internal_to_output_39;

842005b0 <Lc_unpack_data_from_internal_to_output_15>:

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
    {
        unsigned data;
        /* Select the channel. */
        if (i==0)
842005b0:	0f fa 00 c2 	Null = r8 - Null;
842005b4:	03 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_17;

842005b6 <Lc_unpack_data_from_internal_to_output_16>:
        {
            data = data_0;
842005b6:	46 d8       	r4 = M[FP + 32];
842005b8:	02 6e       	jump (m) Lc_unpack_data_from_internal_to_output_18;

842005ba <Lc_unpack_data_from_internal_to_output_17>:
        }
        else
        {
            data = data_1;
842005ba:	4e d8       	r4 = M[FP + 36];

842005bc <Lc_unpack_data_from_internal_to_output_18>:
        }

        /* Check if anythings needs to be done for the output stream*/
        if ((data != 0) && (get_current_output_state(splitter, i) == ACTIVE))
842005bc:	30 04       	Null = r4 - Null;
842005be:	4f 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_33;

842005c0 <Lc_unpack_data_from_internal_to_output_19>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842005c0:	b1 f0 18 20 	rMAC = r9 + 24;
842005c4:	11 f0 0a e0 	rMAC = MBS[rMAC + r8];
842005c8:	48 24       	Null = rMAC - 1;
842005ca:	49 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_33;

842005cc <Lc_unpack_data_from_internal_to_output_20>:
        {
            tCbuffer *out = channel->output_buffer[i];
            PL_ASSERT(out != NULL);
842005cc:	97 f3 fd b9 	r5 = M[r7 + -12];
842005d0:	09 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_22;

842005d2 <Lc_unpack_data_from_internal_to_output_21>:
842005d2:	03 f0 89 42 	r1 = Null + 649;
842005d6:	02 f0 13 60 	r0 = Null + 4115;
842005da:	ff fd 9c f0 	call (m) 0x13f12;
842005de:	39 e9 
842005e0:	65 6e       	jump (m) Lc_unpack_data_from_internal_to_output_39;

842005e2 <Lc_unpack_data_from_internal_to_output_22>:

            /* Set up the internal buffer read pointers!*/
            set_buffer_rd_offset(splitter, &internal, channel->internal.read_offset[i]);
842005e2:	93 f0 00 e8 	r1 = M[r7 + Null];
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
842005e6:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
842005ea:	0b 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_24;

842005ec <Lc_unpack_data_from_internal_to_output_23>:
    {
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
842005ec:	81 f0 03 88 	rMAC = M[r6 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
842005f0:	9c c0       	r2 = r1 AND 0x3;
842005f2:	59 00       	rMAC = r1 + rMAC;
842005f4:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
842005f8:	42 08       	r0 = r6 + Null;
842005fa:	0e f0 27 e3 	call (m) $_cbuffer_set_read_address_ex;
842005fe:	04 6e       	jump (m) Lc_unpack_data_from_internal_to_output_25;

84200600 <Lc_unpack_data_from_internal_to_output_24>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
84200600:	6a d8       	r0 = M[FP + 52];
84200602:	0e f0 33 e8 	call (m) $_ext_buffer_set_read_offset;

84200606 <Lc_unpack_data_from_internal_to_output_25>:

            /* Select the correct interface */
            if (splitter->location == INTERNAL)
84200606:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
8420060a:	11 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_28;

8420060c <Lc_unpack_data_from_internal_to_output_26>:
            {
                unsigned unpacked;
                /* Unpack/copy the data to the output. */
                unpacked = splitter->cbuffer.unpack(out, internal.dsp, data);
8420060c:	b1 f0 1f 88 	rMAC = M[r9 + 124];
84200610:	34 00       	r2 = r4 + Null;
84200612:	43 08       	r1 = r6 + Null;
84200614:	3a 00       	r0 = r5 + Null;
84200616:	d1 4c       	call rMAC;
                /* If not all data could be unpacked something went wrong. */
                PL_ASSERT(unpacked == data);
84200618:	90 05       	Null = r0 - r4;
8420061a:	0f 60       	if EQ jump (m) Lc_unpack_data_from_internal_to_output_29;

8420061c <Lc_unpack_data_from_internal_to_output_27>:
8420061c:	03 f0 95 42 	r1 = Null + 661;
84200620:	02 f0 13 60 	r0 = Null + 4115;
84200624:	ff fd 9c f0 	call (m) 0x13f12;
84200628:	2f e7 
8420062a:	40 6e       	jump (m) Lc_unpack_data_from_internal_to_output_39;

8420062c <Lc_unpack_data_from_internal_to_output_28>:
            }
            else
            {
#ifdef SPLITTER_EXT_BUFFER
                /* Unpack the data to the output. */
                splitter->cbuffer.sram_unpack(out, internal.sram, data);
8420062c:	b1 f0 23 88 	rMAC = M[r9 + 140];
84200630:	34 00       	r2 = r4 + Null;
84200632:	3a 00       	r0 = r5 + Null;
84200634:	6b d8       	r1 = M[FP + 52];
84200636:	d1 4c       	call rMAC;

84200638 <Lc_unpack_data_from_internal_to_output_29>:
 * Returns the read offset of the internal buffer.
 */
static inline unsigned get_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer)
{

    if (splitter->location == INTERNAL)
84200638:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
8420063c:	0b 62       	if NE jump (m) Lc_unpack_data_from_internal_to_output_31;

8420063e <Lc_unpack_data_from_internal_to_output_30>:
    {
        unsigned int offset, ret_val;
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
8420063e:	86 f0 03 88 	r4 = M[r6 + 12];

        ret_val = (unsigned int)(uintptr_t)cbuffer_get_read_address_ex(cbuffer, &offset) - base_addr;
84200642:	c3 13       	r1 = FP + 60;
84200644:	42 08       	r0 = r6 + Null;
84200646:	0d f0 25 ef 	call (m) $_cbuffer_get_read_address_ex;
8420064a:	92 05       	r0 = r0 - r4;
        ret_val += offset;
8420064c:	79 d8       	rMAC = M[FP + 60];
8420064e:	8a 00       	r0 = rMAC + r0;
        return ret_val;
84200650:	04 6e       	jump (m) Lc_unpack_data_from_internal_to_output_32;

84200652 <Lc_unpack_data_from_internal_to_output_31>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        return ext_buffer_get_read_offset(buffer->sram);
84200652:	6a d8       	r0 = M[FP + 52];
84200654:	0e f0 2f e5 	call (m) $_ext_buffer_get_read_offset;

84200658 <Lc_unpack_data_from_internal_to_output_32>:
        PL_ASSERT(splitter->location == INTERNAL);
        /* Stop the compiler complaining */
        return 0;
#endif
    }
}
84200658:	92 f0 00 ee 	M[r7 + Null] = r0;

8420065c <Lc_unpack_data_from_internal_to_output_33>:
    unsigned i;

    internal = channel->internal.buffer;
    read_offset = get_buffer_rd_offset(splitter, &internal);

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420065c:	0a 75       	r8 = r8 + 1;
8420065e:	21 75       	r7 = r7 + 4;
84200660:	a0 f0 02 24 	Null = r8 - 2;
84200664:	a6 65       	if NC jump (m) Lc_unpack_data_from_internal_to_output_15;

84200666 <Lc_unpack_data_from_internal_to_output_34>:
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
84200666:	b1 f0 05 80 	rMAC = MBS[r9 + 5];
8420066a:	6e 63       	if NE jump (m) Lc_unpack_data_from_internal_to_output_4;

8420066c <Lc_unpack_data_from_internal_to_output_35>:
    {
        tCbuffer *cbuffer = buffer->dsp;
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
8420066c:	81 f0 03 88 	rMAC = M[r6 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
84200670:	62 d8       	r0 = M[FP + 48];
84200672:	94 c0       	r2 = r0 AND 0x3;
84200674:	51 00       	rMAC = r0 + rMAC;
84200676:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
8420067a:	42 08       	r0 = r6 + Null;
8420067c:	0d f0 25 ef 	call (m) $_cbuffer_set_read_address_ex;
84200680:	67 6f       	jump (m) Lc_unpack_data_from_internal_to_output_5;

84200682 <Lc_unpack_data_from_internal_to_output_36>:
        return ret_val;
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        return ext_buffer_get_read_offset(buffer->sram);
84200682:	82 d8       	r0 = M[FP + 64];
84200684:	0e f0 3f e3 	call (m) $_ext_buffer_get_read_offset;
84200688:	62 de       	M[FP + 48] = r0;

8420068a <Lc_unpack_data_from_internal_to_output_37>:
8420068a:	e8 f0 10 88 	r6 = M[FP + 64];
8420068e:	81 d8       	rMAC = M[FP + 64];
84200690:	69 de       	M[FP + 52] = rMAC;
84200692:	02 09       	r8 = Null + Null;
84200694:	59 d8       	rMAC = M[FP + 44];
84200696:	19 f0 18 20 	r7 = rMAC + 24;
8420069a:	8e 6f       	jump (m) Lc_unpack_data_from_internal_to_output_16;

8420069c <Lc_unpack_data_from_internal_to_output_38>:
        splitter->cbuffer.discard(channel->internal.buffer.dsp, data_to_remove);
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        splitter->cbuffer.sram_discard(channel->internal.buffer.sram, data_to_remove);
8420069c:	b1 f0 24 88 	rMAC = M[r9 + 144];
842006a0:	5a d8       	r0 = M[FP + 44];
842006a2:	52 89       	r0 = M[r0 + 20];
842006a4:	53 d8       	r1 = M[FP + 40];
842006a6:	d1 4c       	call rMAC;
842006a8:	5e 6f       	jump (m) Lc_unpack_data_from_internal_to_output_8;

842006aa <Lc_unpack_data_from_internal_to_output_39>:
#ifdef SPLITTER_OFFLOAD
    /* Processing finished! */
    splitter->buffer_access = FALSE;
    SPLITTER_MSG("Splitter Upack/copy finished");
#endif
}
842006aa:	74 4c       	SP = SP + -48;
842006ac:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842006ae:	d8 4c       	rts;

842006b0 <Lc_internal_buffer_data_1>:

/**
 * Helper function to get the amount of data per output streams.
 */
static void internal_buffer_data(SPLITTER_OP_DATA *splitter, unsigned *data)
{
842006b0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842006b2:	16 00       	r4 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
842006b4:	6a f0 15 88 	r8 = M[r4 + 84];
    SPLITTER_OUTPUT_STATE output_state;

    metadata_bufffer = get_internal_metadata_buffer(splitter);

    /* Save the read pointer */
    before_prev_rd_indexes = metadata_bufffer->metadata->prev_rd_index;
842006b8:	a1 f0 06 88 	rMAC = M[r8 + 24];
842006bc:	1b f0 03 88 	r9 = M[rMAC + 12];
    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842006c0:	07 00       	r5 = Null + Null;
842006c2:	18 09       	r6 = r1 + Null;
842006c4:	69 f0 58 20 	r7 = r4 + 88;

842006c8 <Lc_internal_buffer_data_2>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842006c8:	31 2a       	rMAC = r4 + 24;
    {
        output_state = get_current_output_state(splitter, i);
        if (output_state == INACTIVE)
842006ca:	c9 e1       	rMAC = MBS[rMAC + r5];
842006cc:	04 62       	if NE jump (m) Lc_internal_buffer_data_4;

842006ce <Lc_internal_buffer_data_3>:
        {
            /* Inactive channels discards data instantaneously.*/
            data[i] = 0;
842006ce:	80 f0 00 ee 	M[r6 + Null] = Null;
842006d2:	10 6e       	jump (m) Lc_internal_buffer_data_7;

842006d4 <Lc_internal_buffer_data_4>:
        }
        else if ((output_state == ACTIVE) || (output_state == HOLD))
842006d4:	48 24       	Null = rMAC - 1;
842006d6:	03 60       	if EQ jump (m) Lc_internal_buffer_data_6;

842006d8 <Lc_internal_buffer_data_5>:
842006d8:	88 24       	Null = rMAC - 2;
842006da:	0c 62       	if NE jump (m) Lc_internal_buffer_data_7;

842006dc <Lc_internal_buffer_data_6>:
        {
            /* Set up the internal buffer metadata read indexes!*/
            metadata_bufffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[i];
842006dc:	91 f0 00 e8 	rMAC = M[r7 + Null];
842006e0:	a2 f0 06 88 	r0 = M[r8 + 24];
842006e4:	d1 8e       	M[r0 + 12] = rMAC;

            SPLITTER_MSG2("Splitter internal_buffer_data output index %d  available meta data 0x%08x  ",
                    i, buff_metadata_available_octets(metadata_bufffer));
            /* The internal buffer is always synchronised with the metadata
             * so there is no need to check both data and metadata. */
            data[i] = buff_metadata_available_octets(metadata_bufffer);
842006e6:	52 08       	r0 = r8 + Null;
842006e8:	ff fd 8b f0 	call (m) 0x11d04;
842006ec:	3d e0 
842006ee:	82 f0 00 ee 	M[r6 + Null] = r0;

842006f2 <Lc_internal_buffer_data_7>:

    metadata_bufffer = get_internal_metadata_buffer(splitter);

    /* Save the read pointer */
    before_prev_rd_indexes = metadata_bufffer->metadata->prev_rd_index;
    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842006f2:	7f 20       	r5 = r5 + 1;
842006f4:	20 75       	r6 = r6 + 4;
842006f6:	21 75       	r7 = r7 + 4;
842006f8:	b8 24       	Null = r5 - 2;
842006fa:	e7 65       	if NC jump (m) Lc_internal_buffer_data_2;

842006fc <Lc_internal_buffer_data_8>:
            /* The internal buffer is always synchronised with the metadata
             * so there is no need to check both data and metadata. */
            data[i] = buff_metadata_available_octets(metadata_bufffer);
        }
    }/* END of output for loop. */
    metadata_bufffer->metadata->prev_rd_index = before_prev_rd_indexes;
842006fc:	a1 f0 06 88 	rMAC = M[r8 + 24];
84200700:	1b f0 03 8e 	M[rMAC + 12] = r9;

84200704 <Lc_internal_buffer_data_9>:
}
84200704:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200706:	d8 4c       	rts;

84200708 <Lc_limit_data_to_move_1>:
/**
 * Helper function to limit the amount of data per output streams which will
 * be unpacked/copied to the output buffers.
 */
static void limit_data_to_move(SPLITTER_OP_DATA *splitter, unsigned *data)
{
84200708:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420070a:	17 00       	r5 = r0 + Null;
8420070c:	43 de       	M[FP + 32] = r1;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
8420070e:	79 a9       	rMAC = M[r5 + 84];
84200710:	49 de       	M[FP + 36] = rMAC;
    tCbuffer *metadata_buffer;
    SPLITTER_OUTPUT_STATE output_state;

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* Limit the data based on the output space. */
    channel = splitter->channel_list;
84200712:	39 e8       	rMAC = M[r5 + Null];
84200714:	51 de       	M[FP + 40] = rMAC;
84200716:	10 6e       	jump (m) Lc_limit_data_to_move_5;

84200718 <Lc_limit_data_to_move_2>:
                    /* Leave three more words in case we are connected to a SBC decode.*/
                    data[i] = splitter->frame_size - space + 3;
                }
                else
                {
                    data[i] = 0;
84200718:	30 ee       	M[r4 + Null] = Null;

8420071a <Lc_limit_data_to_move_3>:
    while (channel != NULL)
    {
        /* Save the read pointer */
        before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420071a:	08 75       	r6 = r6 + 1;
8420071c:	23 75       	r9 = r9 + 4;
8420071e:	36 21       	r4 = r4 + 4;
84200720:	22 75       	r8 = r8 + 4;
84200722:	80 f0 02 24 	Null = r6 - 2;
84200726:	15 64       	if NC jump (m) Lc_limit_data_to_move_7;

84200728 <Lc_limit_data_to_move_4>:
                }
            }

        }/* END of output for loop. */

        metadata_buffer->metadata->prev_rd_index = before_prev_rd_indexes;
84200728:	49 d8       	rMAC = M[FP + 36];
8420072a:	5a d8       	r0 = M[FP + 44];
8420072c:	89 89       	rMAC = M[rMAC + 24];
8420072e:	ca 8e       	M[rMAC + 12] = r0;

        /* Move to next channel. */
        channel = channel->next;
84200730:	51 d8       	rMAC = M[FP + 40];
84200732:	09 e8       	rMAC = M[rMAC + Null];
84200734:	51 de       	M[FP + 40] = rMAC;

84200736 <Lc_limit_data_to_move_5>:
    SPLITTER_OUTPUT_STATE output_state;

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* Limit the data based on the output space. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200736:	51 d8       	rMAC = M[FP + 40];
84200738:	4e 60       	if EQ jump (m) Lc_limit_data_to_move_21;

8420073a <Lc_limit_data_to_move_6>:
    {
        /* Save the read pointer */
        before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;
8420073a:	49 d8       	rMAC = M[FP + 36];
8420073c:	89 89       	rMAC = M[rMAC + 24];
8420073e:	c9 88       	rMAC = M[rMAC + 12];
84200740:	59 de       	M[FP + 44] = rMAC;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84200742:	00 09       	r6 = Null + Null;
84200744:	51 d8       	rMAC = M[FP + 40];
84200746:	46 d8       	r4 = M[FP + 32];
84200748:	7a f0 58 20 	r8 = r5 + 88;
8420074c:	1b f0 0c 20 	r9 = rMAC + 12;

84200750 <Lc_limit_data_to_move_7>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200750:	39 2a       	rMAC = r5 + 24;
84200752:	11 f0 08 e0 	rMAC = MBS[rMAC + r6];
        {
            output_state = get_current_output_state(splitter, i);
            /* Inactive and hold output streams need no limiting. */
            if (output_state == ACTIVE)
84200756:	48 24       	Null = rMAC - 1;
84200758:	18 62       	if NE jump (m) Lc_limit_data_to_move_14;

8420075a <Lc_limit_data_to_move_8>:
            {
                unsigned space;
                tCbuffer *output = channel->output_buffer[i];
8420075a:	b9 f0 00 e8 	r7 = M[r9 + Null];

                space = splitter->cbuffer.unpacked_space(output);
8420075e:	f9 b8       	rMAC = M[r5 + 108];
84200760:	4a 08       	r0 = r7 + Null;
84200762:	d1 4c       	call rMAC;
                data[i] = MIN(data[i], space);
84200764:	2f f6 00 c3 	Null = M[r4] - r0;
84200768:	02 64       	if NC jump (m) Lc_limit_data_to_move_10;

8420076a <Lc_limit_data_to_move_9>:
8420076a:	32 ee       	M[r4 + Null] = r0;

8420076c <Lc_limit_data_to_move_10>:
                /* Now limit to the available metadata. */
                space = buff_metadata_available_space(output);
8420076c:	4a 08       	r0 = r7 + Null;
8420076e:	ff fd 8a f0 	call (m) 0x11d42;
84200772:	35 ee 
                if (splitter->cbuffer.data_size == 4)
84200774:	71 f0 25 88 	rMAC = M[r5 + 148];
84200778:	08 25       	Null = rMAC - 4;
8420077a:	02 62       	if NE jump (m) Lc_limit_data_to_move_12;

8420077c <Lc_limit_data_to_move_11>:

/** Converts octets to samples. The operation rounds down. */
static inline unsigned octets_to_samples(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val / OCTETS_PER_SAMPLE;
8420077c:	52 50       	r0 = r0 LSHIFT -2;

8420077e <Lc_limit_data_to_move_12>:
                {
                    space = octets_to_samples(space);
                }
                data[i] = MIN(data[i], space);
8420077e:	2f f6 00 c3 	Null = M[r4] - r0;
84200782:	cc 65       	if NC jump (m) Lc_limit_data_to_move_3;

84200784 <Lc_limit_data_to_move_13>:
84200784:	32 ee       	M[r4 + Null] = r0;
84200786:	ca 6f       	jump (m) Lc_limit_data_to_move_3;

84200788 <Lc_limit_data_to_move_14>:
            }
            else if (output_state == HOLD)
84200788:	88 24       	Null = rMAC - 2;
8420078a:	c8 63       	if NE jump (m) Lc_limit_data_to_move_3;

8420078c <Lc_limit_data_to_move_15>:
            {
                unsigned space;
                /* Set up the internal buffer metadata read indexes!*/
                metadata_buffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[i];
8420078c:	a1 f0 00 e8 	rMAC = M[r8 + Null];
84200790:	4a d8       	r0 = M[FP + 36];
84200792:	92 89       	r0 = M[r0 + 24];
84200794:	d1 8e       	M[r0 + 12] = rMAC;
/**
 * Returns the space in the metadat buffer.
 */
static inline unsigned get_interal_metadata_space(SPLITTER_OP_DATA *splitter)
{
    unsigned metadata_space_correction = 0;
84200796:	01 09       	r7 = Null + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200798:	7a a9       	r0 = M[r5 + 84];
    tCbuffer *metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Cbuffer leaves a word free to avoid overlaping read and write
     * pointers while the metadata works with offset. To avoid
     * differences the meadata space needs correction.*/
    if (splitter->tag_size_to_samples)
8420079a:	73 f0 68 82 	r1 = MBU[r5 + 104];
8420079e:	5b 50       	r1 = r1 LSHIFT -2;
842007a0:	19 c0       	rMAC = r1 AND 0x1;
842007a2:	07 60       	if EQ jump (m) Lc_limit_data_to_move_17;

842007a4 <Lc_limit_data_to_move_16>:
    {
        if (splitter->packing == PACKED)
        {
            metadata_space_correction = 1;
842007a4:	b9 81       	rMAC = MBS[r5 + 6];
842007a6:	01 09       	r7 = Null + Null;
842007a8:	48 24       	Null = rMAC - 1;
842007aa:	20 f0 49 ce 	if EQ r7 = Null + 1;
842007ae:	06 6e       	jump (m) Lc_limit_data_to_move_19;

842007b0 <Lc_limit_data_to_move_17>:
        else
        {
            metadata_space_correction = 0;
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
842007b0:	71 f0 25 88 	rMAC = M[r5 + 148];
842007b4:	48 24       	Null = rMAC - 1;
842007b6:	02 62       	if NE jump (m) Lc_limit_data_to_move_19;

842007b8 <Lc_limit_data_to_move_18>:
    {
        metadata_space_correction = 3;
842007b8:	19 71       	r7 = Null + 3;

842007ba <Lc_limit_data_to_move_19>:
    }

    return (buff_metadata_available_space(metadata_buffer) - metadata_space_correction);
842007ba:	ff fd 8a f0 	call (m) 0x11d42;
842007be:	29 ec 
842007c0:	9f f2 01 c2 	rMAC = r0 - r7;

                space = get_interal_metadata_space(splitter);
                SPLITTER_DEBUG_INSTR(check_data_space(splitter, channel, space, i));
                /* discard enough data to hold a frame*/
                if (space < splitter->frame_size + 3)
842007c4:	fa 98       	r0 = M[r5 + 44];
842007c6:	d2 20       	r0 = r0 + 3;
842007c8:	88 04       	Null = rMAC - r0;
842007ca:	f2 ff cf ee 	if C jump (m) Lc_limit_data_to_move_2;

842007ce <Lc_limit_data_to_move_20>:
                {
                    /* Leave three more words in case we are connected to a SBC decode.*/
                    data[i] = splitter->frame_size - space + 3;
842007ce:	1f f2 86 c3 	M[r4] = r0 - rMAC;
842007d2:	a4 6f       	jump (m) Lc_limit_data_to_move_3;

842007d4 <Lc_limit_data_to_move_21>:
    }/* END of channel loop. */

    SPLITTER_MSG2("Splitter limit data data[0],data[1]\n"
            " 0x%08x 0x%08x  ",
            data[0],data[1]);
}
842007d4:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842007d6:	d8 4c       	rts;

842007d8 <Lc_splitter_transition_to_active_1>:
 * Transition from INACTIVE to ACTIVE.
 *
 * Start copying to the output when the next metadata tag arrives.
 */
static bool splitter_transition_to_active(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
842007d8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842007da:	12 09       	r8 = r0 + Null;
842007dc:	43 de       	M[FP + 32] = r1;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
842007de:	a6 f0 15 88 	r4 = M[r8 + 84];
    unsigned read_index;
    unsigned read_offset;

    metadata_buffer = get_internal_metadata_buffer(splitter);

    tag_list = buff_metadata_peek_ex(metadata_buffer, &b4idx);
842007e2:	43 12       	r1 = FP + 36;
842007e4:	32 00       	r0 = r4 + Null;
842007e6:	ff fd 8a f0 	call (m) 0x11cd8;
842007ea:	33 e7 
842007ec:	17 00       	r5 = r0 + Null;
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842007ee:	51 08       	rMAC = r8 + Null;
842007f0:	42 d8       	r0 = M[FP + 32];
842007f2:	51 00       	rMAC = r0 + rMAC;
842007f4:	1b f0 18 20 	r9 = rMAC + 24;
842007f8:	b1 f0 00 e0 	rMAC = MBS[r9 + Null];

    output_state = get_current_output_state(splitter, output_index);
    if (output_state == HOLD)
842007fc:	88 24       	Null = rMAC - 2;
842007fe:	e1 62       	if NE jump (m) Lc_splitter_transition_to_active_50;

84200800 <Lc_splitter_transition_to_active_2>:
        /* Go trough the metadata and discard unwanted tags.*/
        unsigned channel_data_to_remove, input_data;
        unsigned data_to_remove;
        unsigned internal_data[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];

        if (tag_list == NULL)
84200800:	38 04       	Null = r5 - Null;
84200802:	0f 62       	if NE jump (m) Lc_splitter_transition_to_active_4;

84200804 <Lc_splitter_transition_to_active_3>:
        {
            SPLITTER_ERRORMSG("splitter_transition_to_active: No tags to align to! Not enough data buffered. ");
84200804:	55 f1 02 f0 	r0 = Null + 357564443;
84200808:	1b 40 
8420080a:	ff fd 00 f0 	call (m) 0x9a2;
8420080e:	39 ec 
            splitter->kick_backward = TRUE;
84200810:	a1 f0 68 82 	rMAC = MBU[r8 + 104];
84200814:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
84200818:	c9 c9       	rMAC = rMAC OR 0x10;
8420081a:	a1 f0 68 8a 	MB[r8 + 104] = rMAC;
8420081e:	e1 6e       	jump (m) Lc_splitter_transition_to_active_54;

84200820 <Lc_splitter_transition_to_active_4>:
        }
        else
        {
            SPLITTER_ERRORMSG3("splitter_transition_to_active"
                    "\n first buffered tag timestamp 0x%08x index 0x%08x b4idx %d " ,
                    tag_list->timestamp, tag_list->index, b4idx);
84200820:	4d d8       	r3 = M[FP + 36];
84200822:	bc 88       	r2 = M[r5 + 8];
84200824:	3b 89       	r1 = M[r5 + 16];
84200826:	55 f1 02 f0 	r0 = Null + 357564522;
8420082a:	6a 40 
8420082c:	ff fd 00 f0 	call (m) 0x9de;
84200830:	33 ed 
        }
        /* Check if timestamp too far in past. */
        if (IS_TIMESTAMPED_TAG(tag_list) && (tag_list->timestamp >= splitter->transition_point))
84200832:	79 88       	rMAC = M[r5 + 4];
84200834:	12 f0 30 00 	r0 = rMAC AND 0x30;
84200838:	0e 60       	if EQ jump (m) Lc_splitter_transition_to_active_8;

8420083a <Lc_splitter_transition_to_active_5>:
8420083a:	c9 c2       	rMAC = rMAC AND 0x40;
8420083c:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_8;

8420083e <Lc_splitter_transition_to_active_6>:
8420083e:	39 89       	rMAC = M[r5 + 16];
84200840:	a2 f0 0a 88 	r0 = M[r8 + 40];
84200844:	88 04       	Null = rMAC - r0;
84200846:	07 64       	if NC jump (m) Lc_splitter_transition_to_active_8;

84200848 <Lc_splitter_transition_to_active_7>:
        {
            SPLITTER_ERRORMSG("Splitter: Timestamp too far in the past. Maybe you need a bigger buffer. ");
84200848:	55 f1 02 f0 	r0 = Null + 357564612;
8420084c:	c4 40 
8420084e:	ff fd 00 f0 	call (m) 0x9a2;
84200852:	35 ea 

84200854 <Lc_splitter_transition_to_active_8>:
        }

        /* Discard the data from the previous tag */
        channel_data_to_remove = b4idx;
84200854:	e9 f0 09 88 	r7 = M[FP + 36];
        input_data = buff_metadata_available_octets(metadata_buffer);
84200858:	32 00       	r0 = r4 + Null;
8420085a:	ff fd 8a f0 	call (m) 0x11d04;
8420085e:	2b e5 
84200860:	16 00       	r4 = r0 + Null;

84200862 <Lc_splitter_transition_to_active_9>:

        /* Go through the metadata until the last tag. */
        while((tag_list->next != NULL) &&
              (input_data != 0) &&
              (IS_TIMESTAMPED_TAG(tag_list) || IS_TIME_OF_ARRIVAL_TAG(tag_list)) &&
              (tag_list->timestamp < splitter->transition_point))
84200862:	39 e8       	rMAC = M[r5 + Null];
84200864:	2a 60       	if EQ jump (m) Lc_splitter_transition_to_active_21;

84200866 <Lc_splitter_transition_to_active_10>:
84200866:	30 04       	Null = r4 - Null;
84200868:	26 60       	if EQ jump (m) Lc_splitter_transition_to_active_20;

8420086a <Lc_splitter_transition_to_active_11>:
8420086a:	7a 88       	r0 = M[r5 + 4];
8420086c:	23 f0 30 00 	r1 = r0 AND 0x30;
84200870:	03 60       	if EQ jump (m) Lc_splitter_transition_to_active_13;

84200872 <Lc_splitter_transition_to_active_12>:
84200872:	d3 c2       	r1 = r0 AND 0x40;
84200874:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_14;

84200876 <Lc_splitter_transition_to_active_13>:
84200876:	22 f0 70 00 	r0 = r0 AND 0x70;
8420087a:	20 f0 40 24 	Null = r0 - 64;
8420087e:	1b 62       	if NE jump (m) Lc_splitter_transition_to_active_20;

84200880 <Lc_splitter_transition_to_active_14>:
84200880:	3b 89       	r1 = M[r5 + 16];
84200882:	a2 f0 0a 88 	r0 = M[r8 + 40];
84200886:	98 04       	Null = r1 - r0;
84200888:	02 f0 ad e0 	if C jump (m) Lc_splitter_transition_to_active_20;

8420088c <Lc_splitter_transition_to_active_15>:
        {
            unsigned tag_data;
            /* tag_legth = tag_list->length / data_size */
            tag_data = MIN(input_data, tag_list->length);
8420088c:	f9 88       	rMAC = M[r5 + 12];
8420088e:	70 04       	Null = r4 - rMAC;
84200890:	02 f0 9f e0 	if C jump (m) Lc_splitter_transition_to_active_19;

84200894 <Lc_splitter_transition_to_active_16>:
84200894:	30 09       	r6 = r4 + Null;

84200896 <Lc_splitter_transition_to_active_17>:

            if (tag_data != 0)
            {
                SPLITTER_ERRORMSG2("Splitter: Metadata tag with timestamp 0x%08x and "
                        "index 0x%08x will be discarded.",
                        tag_list->timestamp, tag_list->index);
84200896:	bc 88       	r2 = M[r5 + 8];
84200898:	55 f1 02 f0 	r0 = Null + 357564686;
8420089c:	0e 41 
8420089e:	ff fd 00 f0 	call (m) 0x9c8;
842008a2:	2b e9 
                /* Increase the discarded amount by the tag length. */
                channel_data_to_remove += tag_data;
842008a4:	41 0d       	r7 = r6 + r7;
                /* ... decrease the amount of data. */
                input_data -= tag_data;
842008a6:	00 f8 36 c2 	r4 = r4 - r6;

842008aa <Lc_splitter_transition_to_active_18>:
            }
            tag_list = tag_list->next;
842008aa:	3f e8       	r5 = M[r5 + Null];
842008ac:	db 6f       	jump (m) Lc_splitter_transition_to_active_9;

842008ae <Lc_splitter_transition_to_active_19>:
        {
            unsigned tag_data;
            /* tag_legth = tag_list->length / data_size */
            tag_data = MIN(input_data, tag_list->length);

            if (tag_data != 0)
842008ae:	08 09       	r6 = rMAC + Null;
842008b0:	f3 63       	if NE jump (m) Lc_splitter_transition_to_active_17;

842008b2 <Lc_19>:
842008b2:	fc 6f       	jump (m) Lc_splitter_transition_to_active_18;

842008b4 <Lc_splitter_transition_to_active_20>:
            tag_list = tag_list->next;

        }

        /* Check if all data was discarded.*/
        if (tag_list->next == NULL)
842008b4:	08 04       	Null = rMAC - Null;
842008b6:	07 62       	if NE jump (m) Lc_splitter_transition_to_active_22;

842008b8 <Lc_splitter_transition_to_active_21>:
        {
            SPLITTER_ERRORMSG("Splitter: All buffered data discarded. Timestamp in future? ");
842008b8:	55 f1 02 f0 	r0 = Null + 357564767;
842008bc:	5f 41 
842008be:	ff fd 00 f0 	call (m) 0x9a2;
842008c2:	25 e7 

842008c4 <Lc_splitter_transition_to_active_22>:
        }
        /* Sanity check the result of the discard. */
        if (tag_list == NULL)
842008c4:	38 04       	Null = r5 - Null;
842008c6:	08 62       	if NE jump (m) Lc_splitter_transition_to_active_24;

842008c8 <Lc_splitter_transition_to_active_23>:
        {
            SPLITTER_ERRORMSG("Splitter: No more metadata tag at the input buffer. Probably the buffering is too small. ");
842008c8:	55 f1 02 f0 	r0 = Null + 357564828;
842008cc:	9c 41 
842008ce:	ff fd 00 f0 	call (m) 0x9a2;
842008d2:	35 e6 
842008d4:	86 6e       	jump (m) Lc_splitter_transition_to_active_54;

842008d6 <Lc_splitter_transition_to_active_24>:
            return FALSE;
        }
        else if (input_data == 0)
842008d6:	30 04       	Null = r4 - Null;
842008d8:	08 62       	if NE jump (m) Lc_splitter_transition_to_active_26;

842008da <Lc_splitter_transition_to_active_25>:
        {
            SPLITTER_ERRORMSG("Splitter: No data left to search for timestamp (probably the buffering is too small). "
                    "Activating output anyways.");
842008da:	55 f1 02 f0 	r0 = Null + 357564918;
842008de:	f6 41 
842008e0:	ff fd 00 f0 	call (m) 0x9a2;
842008e4:	23 e6 
842008e6:	18 6e       	jump (m) Lc_splitter_transition_to_active_30;

842008e8 <Lc_splitter_transition_to_active_26>:
        }
        else if (!IS_TIMESTAMPED_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
842008e8:	79 88       	rMAC = M[r5 + 4];
842008ea:	12 f0 30 00 	r0 = rMAC AND 0x30;
842008ee:	03 60       	if EQ jump (m) Lc_splitter_transition_to_active_28;

842008f0 <Lc_splitter_transition_to_active_27>:
842008f0:	ca c2       	r0 = rMAC AND 0x40;
842008f2:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_29;

842008f4 <Lc_splitter_transition_to_active_28>:
842008f4:	11 f0 70 00 	rMAC = rMAC AND 0x70;
842008f8:	10 f0 40 24 	Null = rMAC - 64;
842008fc:	1a 62       	if NE jump (m) Lc_splitter_transition_to_active_32;

842008fe <Lc_splitter_transition_to_active_29>:
        else
        {
            SPLITTER_ERRORMSG4("Splitter: Tag with ttp 0x%08x and index 0x%08x "
                    "is the first valid tag after transition 0x%08x"
                    "\n Total discarded octets %d",
                    tag_list->timestamp, tag_list->index, splitter->transition_point, channel_data_to_remove);
842008fe:	18 1c       	pushm <r7>;
84200900:	a5 f0 0a 88 	r3 = M[r8 + 40];
84200904:	bc 88       	r2 = M[r5 + 8];
84200906:	3b 89       	r1 = M[r5 + 16];
84200908:	55 f1 02 f0 	r0 = Null + 357565213;
8420090c:	1d 43 
8420090e:	ff fd 00 f0 	call (m) 0x9f6;
84200912:	29 e7 
84200914:	7f 4c       	SP = SP + -4;

84200916 <Lc_splitter_transition_to_active_30>:
        }


        /* get the available data in the internal buffer */
        internal_buffer_data(splitter, internal_data);
84200916:	83 12       	r1 = FP + 40;
84200918:	52 08       	r0 = r8 + Null;
8420091a:	fe ff 37 ec 	call (m) Lc_internal_buffer_data_1;
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data[0], internal_data[1]);
8420091e:	e8 f0 0a 88 	r6 = M[FP + 40];
84200922:	59 d8       	rMAC = M[FP + 44];
84200924:	1f f8 00 c2 	Null = r6 - rMAC;
84200928:	02 f0 cd e0 	if C jump (m) Lc_splitter_transition_to_active_40;

8420092c <Lc_splitter_transition_to_active_31>:
8420092c:	08 09       	r6 = rMAC + Null;
8420092e:	23 6e       	jump (m) Lc_splitter_transition_to_active_40;

84200930 <Lc_splitter_transition_to_active_32>:
                    "Activating output anyways.");
        }
        else if (!IS_TIMESTAMPED_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
        {
            while((tag_list->next != NULL) &&
                  (input_data != 0))
84200930:	39 e8       	rMAC = M[r5 + Null];
84200932:	18 60       	if EQ jump (m) Lc_splitter_transition_to_active_39;

84200934 <Lc_splitter_transition_to_active_33>:
84200934:	30 04       	Null = r4 - Null;
84200936:	16 60       	if EQ jump (m) Lc_splitter_transition_to_active_39;

84200938 <Lc_splitter_transition_to_active_34>:
            {
                unsigned tag_data;
                /* tag_legth = tag_list->length / data_size */
                tag_data = MIN(input_data, tag_list->length);
84200938:	f9 88       	rMAC = M[r5 + 12];
8420093a:	70 04       	Null = r4 - rMAC;
8420093c:	02 f0 a1 e0 	if C jump (m) Lc_splitter_transition_to_active_38;

84200940 <Lc_splitter_transition_to_active_35>:
84200940:	30 09       	r6 = r4 + Null;

84200942 <Lc_splitter_transition_to_active_36>:

                if (tag_data != 0)
                {
                    SPLITTER_ERRORMSG2("Splitter: Metadata tag with timestamp 0x%08x and "
                            "index 0x%08x will be discarded.",
                            tag_list->timestamp, tag_list->index);
84200942:	bc 88       	r2 = M[r5 + 8];
84200944:	3b 89       	r1 = M[r5 + 16];
84200946:	55 f1 02 f0 	r0 = Null + 357564686;
8420094a:	0e 41 
8420094c:	ff fd 00 f0 	call (m) 0x9c8;
84200950:	3d e3 
                    /* Increase the discarded amount by the tag length. */
                    channel_data_to_remove += tag_data;
84200952:	41 0d       	r7 = r6 + r7;
                    /* ... decrease the amount of data. */
                    input_data -= tag_data;
84200954:	00 f8 36 c2 	r4 = r4 - r6;

84200958 <Lc_splitter_transition_to_active_37>:
                }
                tag_list = tag_list->next;
84200958:	3f e8       	r5 = M[r5 + Null];
                    "Activating output anyways.");
        }
        else if (!IS_TIMESTAMPED_TAG(tag_list) && !IS_TIME_OF_ARRIVAL_TAG(tag_list))
        {
            while((tag_list->next != NULL) &&
                  (input_data != 0))
8420095a:	eb 6f       	jump (m) Lc_splitter_transition_to_active_32;

8420095c <Lc_splitter_transition_to_active_38>:
            {
                unsigned tag_data;
                /* tag_legth = tag_list->length / data_size */
                tag_data = MIN(input_data, tag_list->length);

                if (tag_data != 0)
8420095c:	08 09       	r6 = rMAC + Null;
8420095e:	f2 63       	if NE jump (m) Lc_splitter_transition_to_active_36;

84200960 <Lc_20>:
84200960:	fc 6f       	jump (m) Lc_splitter_transition_to_active_37;

84200962 <Lc_splitter_transition_to_active_39>:
            }
            SPLITTER_ERRORMSG2("Splitter: Non timestamped tag found.\n"
                    " All data will be discarded and output stream will be activated!\n"
                    " Tag with index 0x%08x is the last tag in the buffer"
                    "\n Total discarded octets %d",
                    tag_list->index, channel_data_to_remove);
84200962:	bb 88       	r1 = M[r5 + 8];
84200964:	55 f1 02 f0 	r0 = Null + 357565031;
84200968:	67 42 
8420096a:	4c 08       	r2 = r7 + Null;
8420096c:	ff fd 00 f0 	call (m) 0x9c8;
84200970:	3d e2 
84200972:	d2 6f       	jump (m) Lc_splitter_transition_to_active_30;

84200974 <Lc_splitter_transition_to_active_40>:
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(internal_data[0], internal_data[1]);
        /* remove the data from the current channel */
        internal_data[output_index] = internal_data[output_index] - channel_data_to_remove;
84200974:	81 12       	rMAC = FP + 40;
84200976:	42 d8       	r0 = M[FP + 32];
84200978:	52 54       	r0 = r0 LSHIFT 2;
8420097a:	51 00       	rMAC = r0 + rMAC;
8420097c:	0a e8       	r0 = M[rMAC + Null];
8420097e:	9f f2 81 c3 	M[rMAC] = r0 - r7;
        data_to_remove = data_to_remove - MAX(internal_data[0], internal_data[1]);
84200982:	52 d8       	r0 = M[FP + 40];
84200984:	59 d8       	rMAC = M[FP + 44];
84200986:	50 04       	Null = r0 - rMAC;
84200988:	02 f0 87 e0 	if C jump (m) Lc_splitter_transition_to_active_43;

8420098c <Lc_splitter_transition_to_active_42>:
8420098c:	02 6e       	jump (m) Lc_splitter_transition_to_active_44;

8420098e <Lc_splitter_transition_to_active_43>:
8420098e:	11 00       	rMAC = r0 + Null;

84200990 <Lc_splitter_transition_to_active_44>:
84200990:	00 f1 38 c2 	r6 = r6 - rMAC;
                internal_data[0],
                internal_data[1],
                data_to_remove);

        /* This will remove data from all channels. */
        if (data_to_remove !=0)
84200994:	0f f8 00 c2 	Null = r6 - Null;
84200998:	12 60       	if EQ jump (m) Lc_splitter_transition_to_active_49;

8420099a <Lc_splitter_transition_to_active_45>:
        {
            /* The channel is still in hold. so by moving data
             * the data will be discarded from the channel.
             */
            unsigned data_0 = 0, data_1 = 0;
8420099a:	01 09       	r7 = Null + Null;
8420099c:	06 00       	r4 = Null + Null;
            if (output_index == 0)
8420099e:	41 d8       	rMAC = M[FP + 32];
842009a0:	03 62       	if NE jump (m) Lc_splitter_transition_to_active_47;

842009a2 <Lc_splitter_transition_to_active_46>:
            {
                data_0 = data_to_remove;
842009a2:	41 09       	r7 = r6 + Null;
842009a4:	02 6e       	jump (m) Lc_splitter_transition_to_active_48;

842009a6 <Lc_splitter_transition_to_active_47>:
            }
            else
            {
                data_1 = data_to_remove;
842009a6:	46 08       	r4 = r6 + Null;

842009a8 <Lc_splitter_transition_to_active_48>:
            }
            /* remove the metadata */
            remove_metadata_from_internal(splitter, data_to_remove);
842009a8:	43 08       	r1 = r6 + Null;
842009aa:	52 08       	r0 = r8 + Null;
842009ac:	09 f0 39 e2 	call (m) $_remove_metadata_from_internal;
            /* remove the data by copying 0 0 but  removing data */
            unpack_data_from_internal_to_output(splitter, data_0, data_1, data_to_remove);
842009b0:	45 08       	r3 = r6 + Null;
842009b2:	34 00       	r2 = r4 + Null;
842009b4:	4b 08       	r1 = r7 + Null;
842009b6:	52 08       	r0 = r8 + Null;
842009b8:	fd ff 2b eb 	call (m) Lc_unpack_data_from_internal_to_output_1;

842009bc <Lc_splitter_transition_to_active_49>:
        }

        read_index = tag_list->index;
842009bc:	be 88       	r4 = M[r5 + 8];
842009be:	26 6e       	jump (m) Lc_splitter_transition_to_active_58;

842009c0 <Lc_splitter_transition_to_active_50>:
    }
    else
    {
        /* make sure that the operator is in INACTIVE state. */
        SPLITTER_DEBUG_INSTR(PL_ASSERT(output_state == INACTIVE));
        if (tag_list == NULL)
842009c0:	38 04       	Null = r5 - Null;
842009c2:	11 62       	if NE jump (m) Lc_splitter_transition_to_active_55;

842009c4 <Lc_splitter_transition_to_active_51>:
        {
            if (splitter->reframe_enabled)
842009c4:	a2 f0 68 82 	r0 = MBU[r8 + 104];
842009c8:	12 50       	r0 = r0 LSHIFT -1;
842009ca:	11 c0       	rMAC = r0 AND 0x1;
842009cc:	04 60       	if EQ jump (m) Lc_splitter_transition_to_active_53;

842009ce <Lc_splitter_transition_to_active_52>:
            {
                /* Because re-frame is enabled the next tag will
                 * have no b4idx. in this manner we can use the
                 * write index. */
                read_index = metadata_buffer->metadata->prev_wr_index;
842009ce:	b1 89       	rMAC = M[r4 + 24];
842009d0:	8e 88       	r4 = M[rMAC + 8];
842009d2:	1c 6e       	jump (m) Lc_splitter_transition_to_active_58;

842009d4 <Lc_splitter_transition_to_active_53>:
            }
            else
            {
                SPLITTER_ERRORMSG("splitter_transition_to_active: "
                        "No tags to align to and re-frame is disabled. ");
842009d4:	55 f1 02 f0 	r0 = Null + 357565334;
842009d8:	96 43 
842009da:	ef fd ff ff 	call (m) 0x9a2;
842009de:	29 ee 

842009e0 <Lc_splitter_transition_to_active_54>:

        if (tag_list == NULL)
        {
            SPLITTER_ERRORMSG("splitter_transition_to_active: No tags to align to! Not enough data buffered. ");
            splitter->kick_backward = TRUE;
            return FALSE;
842009e0:	02 00       	r0 = Null + Null;
842009e2:	3d 6e       	jump (m) Lc_splitter_transition_to_active_68;

842009e4 <Lc_splitter_transition_to_active_55>:
        else
        {
            SPLITTER_MSG3("splitter_transition_to_active"
                    "\n tag_list 0x%08x  tag_list->index 0x%08x b4idx %d " ,
                    tag_list, tag_list->index, b4idx);
            read_index = tag_list->index;
842009e4:	be 88       	r4 = M[r5 + 8];
/**
 * Returns the opposite output stream index.
 */
static inline unsigned opposite_output_index(unsigned output_index)
{
    return (output_index + 1) & 1;
842009e6:	41 d8       	rMAC = M[FP + 32];
842009e8:	49 20       	rMAC = rMAC + 1;
842009ea:	0a c0       	r0 = rMAC AND 0x1;
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
842009ec:	51 08       	rMAC = r8 + Null;
842009ee:	51 00       	rMAC = r0 + rMAC;
            /* Remove data until the tag start.*/
            if((get_current_output_state(splitter, opposite_output_index(output_index)) == INACTIVE)&&(b4idx != 0))
842009f0:	09 b0       	rMAC = MBS[rMAC + 24];
842009f2:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_58;

842009f4 <Lc_splitter_transition_to_active_56>:
842009f4:	4b d8       	r1 = M[FP + 36];
842009f6:	0a 60       	if EQ jump (m) Lc_splitter_transition_to_active_58;

842009f8 <Lc_splitter_transition_to_active_57>:
            {
                /* remove the metadata */
                remove_metadata_from_internal(splitter, b4idx);
842009f8:	52 08       	r0 = r8 + Null;
842009fa:	09 f0 2b e0 	call (m) $_remove_metadata_from_internal;
                /* remove the data by copying 0 0 but  removing data */
                unpack_data_from_internal_to_output(splitter, 0, 0, b4idx);
842009fe:	4d d8       	r3 = M[FP + 36];
84200a00:	04 00       	r2 = Null + Null;
84200a02:	03 00       	r1 = Null + Null;
84200a04:	52 08       	r0 = r8 + Null;
84200a06:	fd ff 3d e8 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200a0a <Lc_splitter_transition_to_active_58>:
            }
        }
    }

    /* set the metadata read index and head. */
    splitter->internal_metadata.prev_rd_indexes[output_index] = read_index;
84200a0a:	42 d8       	r0 = M[FP + 32];
84200a0c:	51 08       	rMAC = r8 + Null;
84200a0e:	52 54       	r0 = r0 LSHIFT 2;
84200a10:	51 00       	rMAC = r0 + rMAC;
84200a12:	8e af       	M[rMAC + 88] = r4;
    splitter->internal_metadata.head_tag[output_index] = tag_list;
84200a14:	0f be       	M[rMAC + 96] = r5;
/**
 * Converts metadata read index to buffer offset.
 */
static inline unsigned metadata_read_idx_to_buffer_offset(SPLITTER_OP_DATA *splitter, unsigned position)
{
    unsigned read_offset = -1;
84200a16:	42 24       	r0 = Null - 1;
    /* convert the index to read offset.*/
    if (splitter->tag_size_to_samples)
84200a18:	a3 f0 68 82 	r1 = MBU[r8 + 104];
84200a1c:	5b 50       	r1 = r1 LSHIFT -2;
84200a1e:	19 c0       	rMAC = r1 AND 0x1;
84200a20:	12 60       	if EQ jump (m) Lc_splitter_transition_to_active_65;

84200a22 <Lc_splitter_transition_to_active_59>:
    {
        if (splitter->packing == PACKED)
84200a22:	a1 f0 06 80 	rMAC = MBS[r8 + 6];
84200a26:	48 24       	Null = rMAC - 1;
84200a28:	0c 62       	if NE jump (m) Lc_splitter_transition_to_active_64;

84200a2a <Lc_splitter_transition_to_active_60>:
        {
            read_offset = position<<1;
84200a2a:	32 54       	r0 = r4 LSHIFT 1;
84200a2c:	11 6e       	jump (m) Lc_splitter_transition_to_active_67;

84200a2e <Lc_splitter_transition_to_active_61>:
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
    while (channel != NULL)
84200a2e:	08 04       	Null = rMAC - Null;
84200a30:	06 60       	if EQ jump (m) Lc_splitter_transition_to_active_63;

84200a32 <Lc_splitter_transition_to_active_62>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200a32:	b3 f0 00 ea 	MB[r9 + Null] = r1;
/**
 * Function which sets the read offset of one of the output streams.
 */
static inline void set_data_buffer_read_offset(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned output_index, unsigned read_offset)
{
    channel->internal.read_offset[output_index] = read_offset;
84200a36:	0a ef       	M[rMAC + r2] = r0;
        set_current_output_state(splitter, output_index, ACTIVE);

        /* set the read offset in the buffer.*/
        set_data_buffer_read_offset(splitter, channel, output_index,  read_offset);

        channel = channel->next;
84200a38:	09 e8       	rMAC = M[rMAC + Null];
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
    while (channel != NULL)
84200a3a:	fa 6f       	jump (m) Lc_splitter_transition_to_active_61;

84200a3c <Lc_splitter_transition_to_active_63>:
        set_data_buffer_read_offset(splitter, channel, output_index,  read_offset);

        channel = channel->next;
    }

    return TRUE;
84200a3c:	1a 00       	r0 = r1 + Null;
84200a3e:	0f 6e       	jump (m) Lc_splitter_transition_to_active_68;

84200a40 <Lc_splitter_transition_to_active_64>:
        {
            read_offset = position<<1;
        }
        else
        {
            read_offset = position<<2;
84200a40:	72 54       	r0 = r4 LSHIFT 2;
84200a42:	06 6e       	jump (m) Lc_splitter_transition_to_active_67;

84200a44 <Lc_splitter_transition_to_active_65>:
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
84200a44:	a1 f0 25 88 	rMAC = M[r8 + 148];
84200a48:	48 24       	Null = rMAC - 1;
84200a4a:	02 62       	if NE jump (m) Lc_splitter_transition_to_active_67;

84200a4c <Lc_splitter_transition_to_active_66>:
    {
        read_offset = position;
84200a4c:	32 00       	r0 = r4 + Null;

84200a4e <Lc_splitter_transition_to_active_67>:

    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* set the read pointer for all channels */
    channel = splitter->channel_list;
84200a4e:	a1 f0 00 e8 	rMAC = M[r8 + Null];
84200a52:	43 20       	r1 = Null + 1;
84200a54:	44 d8       	r2 = M[FP + 32];
84200a56:	64 54       	r2 = r2 LSHIFT 2;
84200a58:	24 2a       	r2 = r2 + 24;
84200a5a:	ea 6f       	jump (m) Lc_splitter_transition_to_active_61;

84200a5c <Lc_splitter_transition_to_active_68>:

        channel = channel->next;
    }

    return TRUE;
}
84200a5c:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200a5e:	d8 4c       	rts;

84200a60 <Lc_splitter_finish_copying_last_tag_1>:

static bool splitter_finish_copying_last_tag(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
84200a60:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200a62:	16 00       	r4 = r0 + Null;
84200a64:	1f 00       	r5 = r1 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200a66:	69 f0 15 88 	r7 = M[r4 + 84];
    SPLITTER_OUTPUT_STATE output_state;

    metadata_buffer = get_internal_metadata_buffer(splitter);

    /* Save the index value. */
    before_prev_rd_indexes = metadata_buffer->metadata->prev_rd_index;
84200a6a:	92 f0 06 88 	r0 = M[r7 + 24];
84200a6e:	2a f0 03 88 	r8 = M[r0 + 12];
    before_head_tag = metadata_buffer->metadata->tags.head;
84200a72:	28 f0 00 e8 	r6 = M[r0 + Null];

    /* Set up the internal buffer read pointers!*/
    metadata_buffer->metadata->prev_rd_index = splitter->internal_metadata.prev_rd_indexes[output_index];
84200a76:	7b 54       	r1 = r5 LSHIFT 2;
84200a78:	31 00       	rMAC = r4 + Null;
84200a7a:	59 00       	rMAC = r1 + rMAC;
84200a7c:	8b a9       	r1 = M[rMAC + 88];
84200a7e:	d3 8e       	M[r0 + 12] = r1;
    metadata_buffer->metadata->tags.head = splitter->internal_metadata.head_tag[output_index];
84200a80:	09 b8       	rMAC = M[rMAC + 96];
84200a82:	92 f0 06 88 	r0 = M[r7 + 24];
84200a86:	11 ee       	M[r0 + Null] = rMAC;

    /* b4idx will indicate the octets remaining from the last tag. */
    tag_list = buff_metadata_peek_ex(metadata_buffer, &b4idx);
84200a88:	c3 11       	r1 = FP + 28;
84200a8a:	4a 08       	r0 = r7 + Null;
84200a8c:	ff fd 89 f0 	call (m) 0x11cd8;
84200a90:	2d e2 

    /* restore the index value. */
    metadata_buffer->metadata->prev_rd_index = before_prev_rd_indexes;
84200a92:	91 f0 06 88 	rMAC = M[r7 + 24];
84200a96:	1a f0 03 8e 	M[rMAC + 12] = r8;
    metadata_buffer->metadata->tags.head = before_head_tag;
84200a9a:	91 f0 06 88 	rMAC = M[r7 + 24];
84200a9e:	18 f0 00 ee 	M[rMAC + Null] = r6;

    SPLITTER_MSG3("splitter_finish_copying_last_tag"
            "\n tag_list 0x%08x  tag_list->index 0x%08x b4idx %d octets" ,
            tag_list, tag_list->index, b4idx);

    if (tag_list == NULL)
84200aa2:	10 04       	Null = r0 - Null;
84200aa4:	2f 60       	if EQ jump (m) Lc_splitter_finish_copying_last_tag_5;

84200aa6 <Lc_splitter_finish_copying_last_tag_2>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200aa6:	31 00       	rMAC = r4 + Null;
84200aa8:	79 00       	rMAC = r5 + rMAC;
84200aaa:	09 b0       	rMAC = MBS[rMAC + 24];
        /* Would be nice to code against this. */
        return FALSE;
    }

    output_state = get_current_output_state(splitter, output_index);
    if (output_state == ACTIVE)
84200aac:	48 24       	Null = rMAC - 1;
84200aae:	49 62       	if NE jump (m) Lc_splitter_finish_copying_last_tag_13;

84200ab0 <Lc_splitter_finish_copying_last_tag_3>:
    {
        unsigned data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL] = {0,0};
84200ab0:	07 f0 01 f0 	rMAC = Null + 7340224;
84200ab4:	c0 40 
84200ab6:	02 12       	r0 = FP + 32;
84200ab8:	0b e8       	r1 = M[rMAC + Null];
84200aba:	4c 88       	r2 = M[rMAC + 4];
84200abc:	13 ee       	M[r0 + Null] = r1;
84200abe:	54 8e       	M[r0 + 4] = r2;
        unsigned data_to_move[SPLITTER_MAX_OUTPUTS_PER_CHANNEL] = {0,0};
84200ac0:	07 f0 01 f0 	rMAC = Null + 7340232;
84200ac4:	c8 40 
84200ac6:	82 12       	r0 = FP + 40;
84200ac8:	0b e8       	r1 = M[rMAC + Null];
84200aca:	4c 88       	r2 = M[rMAC + 4];
84200acc:	13 ee       	M[r0 + Null] = r1;
84200ace:	54 8e       	M[r0 + 4] = r2;
        unsigned data_to_remove = 0;

        /* Get the amount of date buffered internally. */
        internal_buffer_data(splitter, data_before);
84200ad0:	03 12       	r1 = FP + 32;
84200ad2:	32 00       	r0 = r4 + Null;
84200ad4:	fd ff 3d ee 	call (m) Lc_internal_buffer_data_1;

        /* finish copying the current tag. */
        data_to_move[output_index] = b4idx;
84200ad8:	e8 f0 28 20 	r6 = FP + 40;
84200adc:	7a 54       	r0 = r5 LSHIFT 2;
84200ade:	39 d8       	rMAC = M[FP + 28];
84200ae0:	10 0d       	r6 = r0 + r6;
84200ae2:	81 f0 00 ee 	M[r6 + Null] = rMAC;
        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n output_index %d  data_to_move[0] %d data_to_move[1] %d" ,
                   output_index, data_to_move[0], data_to_move[1]);

        /* Limit the data to move based on the output space. */
        limit_data_to_move(splitter, data_to_move);
84200ae6:	83 12       	r1 = FP + 40;
84200ae8:	32 00       	r0 = r4 + Null;
84200aea:	fe ff 3f e0 	call (m) Lc_limit_data_to_move_1;

        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n after limit: data_to_move[0] %d data_to_move[1] %d b4idx %d " ,
                   data_to_move[0], data_to_move[1], b4idx);
        if (data_to_move[output_index] != b4idx)
84200aee:	39 d8       	rMAC = M[FP + 28];
84200af0:	1f f8 00 c3 	Null = M[r6] - rMAC;
84200af4:	09 60       	if EQ jump (m) Lc_splitter_finish_copying_last_tag_6;

84200af6 <Lc_splitter_finish_copying_last_tag_4>:
        {
            SPLITTER_ERRORMSG("splitter_finish_copying_last_tag:"
                       " Not enough space to finish copying tag!" );
84200af6:	55 f1 02 f0 	r0 = Null + 357565412;
84200afa:	e4 43 
84200afc:	ef fd ff ff 	call (m) 0x9a2;
84200b00:	27 e5 

84200b02 <Lc_splitter_finish_copying_last_tag_5>:
            tag_list, tag_list->index, b4idx);

    if (tag_list == NULL)
    {
        /* Would be nice to code against this. */
        return FALSE;
84200b02:	02 00       	r0 = Null + Null;
84200b04:	1f 6e       	jump (m) Lc_splitter_finish_copying_last_tag_14;

84200b06 <Lc_splitter_finish_copying_last_tag_6>:
        /*
         * data_to_remove =
         *    MAX(internal_data_before[0], internal_data_before[1]) -
         *    MAX(internal_data_after[0], internal_data_after[1]);
         */
        data_to_remove = MAX(data_before[0], data_before[1]);
84200b06:	41 d8       	rMAC = M[FP + 32];
84200b08:	4b d8       	r1 = M[FP + 36];
84200b0a:	c8 04       	Null = rMAC - r1;
84200b0c:	02 f0 89 e0 	if C jump (m) Lc_splitter_finish_copying_last_tag_8;

84200b10 <Lc_splitter_finish_copying_last_tag_7>:
84200b10:	1f 00       	r5 = r1 + Null;
84200b12:	02 6e       	jump (m) Lc_splitter_finish_copying_last_tag_9;

84200b14 <Lc_splitter_finish_copying_last_tag_8>:
84200b14:	0f 00       	r5 = rMAC + Null;

84200b16 <Lc_splitter_finish_copying_last_tag_9>:
        data_to_remove = data_to_remove -  (
                MAX(data_before[0] - data_to_move[0], data_before[1] - data_to_move[1])
            );
84200b16:	52 d8       	r0 = M[FP + 40];
84200b18:	8a 04       	r0 = rMAC - r0;
84200b1a:	59 d8       	rMAC = M[FP + 44];
84200b1c:	59 04       	rMAC = r1 - rMAC;
84200b1e:	50 04       	Null = r0 - rMAC;
84200b20:	02 f0 87 e0 	if C jump (m) Lc_splitter_finish_copying_last_tag_11;

84200b24 <Lc_splitter_finish_copying_last_tag_10>:
84200b24:	02 6e       	jump (m) Lc_splitter_finish_copying_last_tag_12;

84200b26 <Lc_splitter_finish_copying_last_tag_11>:
84200b26:	11 00       	rMAC = r0 + Null;

84200b28 <Lc_splitter_finish_copying_last_tag_12>:
84200b28:	7f 04       	r5 = r5 - rMAC;
        SPLITTER_MSG3("splitter_finish_copying_last_tag:"
                   "\n BATTER: data_before[0] %d data_before[1] %d data_to_remove %d " ,
                   data_before[0], data_before[1], data_to_remove);

        /* copy the metadata to the active output streams */
        splitter_metadata_copy(splitter, data_to_move, data_to_remove);
84200b2a:	83 12       	r1 = FP + 40;
84200b2c:	3c 00       	r2 = r5 + Null;
84200b2e:	32 00       	r0 = r4 + Null;
84200b30:	08 f0 21 e1 	call (m) $_splitter_metadata_copy;

        /* Finish copying last tag. */
        unpack_data_from_internal_to_output(splitter, data_to_move[0], data_to_move[1], data_to_remove);
84200b34:	5c d8       	r2 = M[FP + 44];
84200b36:	53 d8       	r1 = M[FP + 40];
84200b38:	3d 00       	r3 = r5 + Null;
84200b3a:	32 00       	r0 = r4 + Null;
84200b3c:	fc ff 27 ef 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200b40 <Lc_splitter_finish_copying_last_tag_13>:
    }

    SPLITTER_MSG("splitter_finish_copying_last_tag: finished");
    return TRUE;
84200b40:	42 20       	r0 = Null + 1;

84200b42 <Lc_splitter_finish_copying_last_tag_14>:

}
84200b42:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84200b44:	d8 4c       	rts;

84200b46 <Lc_splitter_transition_to_inactive_1>:
/**
 * Transition from any state to INACTIVE.
 *
 */
static bool splitter_transition_to_inactive(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
84200b46:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200b48:	16 00       	r4 = r0 + Null;
84200b4a:	1f 00       	r5 = r1 + Null;
    SPLITTER_CHANNEL_STRUC *channel;
    unsigned data_to_remove;
    unsigned internal_data_before[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];
    unsigned internal_data_after[SPLITTER_MAX_OUTPUTS_PER_CHANNEL];

    if (splitter->finish_last_tag)
84200b4c:	61 f0 68 82 	rMAC = MBU[r4 + 104];
84200b50:	09 c0       	rMAC = rMAC AND 0x1;
84200b52:	06 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_4;

84200b54 <Lc_splitter_transition_to_inactive_2>:
    {
        /* If copying the last tag failed, return failure */
        if (!splitter_finish_copying_last_tag(splitter, output_index))
84200b54:	86 4f       	call (m) Lc_splitter_finish_copying_last_tag_1;
84200b56:	10 04       	Null = r0 - Null;
84200b58:	03 62       	if NE jump (m) Lc_splitter_transition_to_inactive_4;

84200b5a <Lc_splitter_transition_to_inactive_3>:
        {
            return FALSE;
84200b5a:	02 00       	r0 = Null + Null;
84200b5c:	39 6e       	jump (m) Lc_splitter_transition_to_inactive_16;

84200b5e <Lc_splitter_transition_to_inactive_4>:
        }
    }

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_before);
84200b5e:	03 11       	r1 = FP + 16;
84200b60:	32 00       	r0 = r4 + Null;
84200b62:	fd ff 2f ea 	call (m) Lc_internal_buffer_data_1;

    /* set the metadata read index and head. */
    splitter->internal_metadata.prev_rd_indexes[output_index] = -1;
84200b66:	7a 54       	r0 = r5 LSHIFT 2;
84200b68:	31 00       	rMAC = r4 + Null;
84200b6a:	51 00       	rMAC = r0 + rMAC;
84200b6c:	42 24       	r0 = Null - 1;
84200b6e:	8a af       	M[rMAC + 88] = r0;
    splitter->internal_metadata.head_tag[output_index] = (metadata_tag *)-1;
84200b70:	42 24       	r0 = Null - 1;
84200b72:	0a be       	M[rMAC + 96] = r0;

    /* Deactivate all output streams with index "output_index". */
    channel = splitter->channel_list;
84200b74:	31 e8       	rMAC = M[r4 + Null];
84200b76:	32 00       	r0 = r4 + Null;
84200b78:	43 24       	r1 = Null - 1;
84200b7a:	7c 54       	r2 = r5 LSHIFT 2;
84200b7c:	ba 00       	r0 = r5 + r0;
84200b7e:	24 2a       	r2 = r2 + 24;
84200b80:	12 2a       	r0 = r0 + 24;

84200b82 <Lc_splitter_transition_to_inactive_5>:
    while (channel != NULL)
84200b82:	08 04       	Null = rMAC - Null;
84200b84:	05 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_7;

84200b86 <Lc_splitter_transition_to_inactive_6>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200b86:	10 ea       	MB[r0 + Null] = Null;
/**
 * Function which invalidates the read position.
 */
static inline void invalidate_read_offset(SPLITTER_CHANNEL_STRUC *channel, unsigned output_index)
{
    channel->internal.read_offset[output_index] = -1;
84200b88:	0b ef       	M[rMAC + r2] = r1;
        set_current_output_state(splitter, output_index, INACTIVE);

        /* For security invalidate the read position.*/
        invalidate_read_offset(channel, output_index);

        channel = channel->next;
84200b8a:	09 e8       	rMAC = M[rMAC + Null];
    splitter->internal_metadata.prev_rd_indexes[output_index] = -1;
    splitter->internal_metadata.head_tag[output_index] = (metadata_tag *)-1;

    /* Deactivate all output streams with index "output_index". */
    channel = splitter->channel_list;
    while (channel != NULL)
84200b8c:	fb 6f       	jump (m) Lc_splitter_transition_to_inactive_5;

84200b8e <Lc_splitter_transition_to_inactive_7>:

        channel = channel->next;
    }

    /* get the available data in the internal buffer */
    internal_buffer_data(splitter, internal_data_after);
84200b8e:	83 11       	r1 = FP + 24;
84200b90:	32 00       	r0 = r4 + Null;
84200b92:	fd ff 3f e8 	call (m) Lc_internal_buffer_data_1;
    /*
     * data_to_remove =
     *    MAX(internal_data_before[0], internal_data_before[1]) -
     *    MAX(internal_data_after[0], internal_data_after[1]);
     */
    data_to_remove = MAX(internal_data_before[0], internal_data_before[1]);
84200b96:	27 d8       	r5 = M[FP + 16];
84200b98:	29 d8       	rMAC = M[FP + 20];
84200b9a:	78 04       	Null = r5 - rMAC;
84200b9c:	02 f0 89 e0 	if C jump (m) Lc_splitter_transition_to_inactive_10;

84200ba0 <Lc_splitter_transition_to_inactive_8>:
84200ba0:	0f 00       	r5 = rMAC + Null;
84200ba2:	01 6e       	jump (m) Lc_splitter_transition_to_inactive_10;

84200ba4 <Lc_splitter_transition_to_inactive_10>:
    data_to_remove = data_to_remove - MAX(internal_data_after[0], internal_data_after[1]);
84200ba4:	32 d8       	r0 = M[FP + 24];
84200ba6:	39 d8       	rMAC = M[FP + 28];
84200ba8:	50 04       	Null = r0 - rMAC;
84200baa:	02 f0 87 e0 	if C jump (m) Lc_splitter_transition_to_inactive_12;

84200bae <Lc_splitter_transition_to_inactive_11>:
84200bae:	02 6e       	jump (m) Lc_splitter_transition_to_inactive_13;

84200bb0 <Lc_splitter_transition_to_inactive_12>:
84200bb0:	11 00       	rMAC = r0 + Null;

84200bb2 <Lc_splitter_transition_to_inactive_13>:
84200bb2:	7f 04       	r5 = r5 - rMAC;
            internal_data_after[0],
            internal_data_before[1],
            internal_data_after[1],
            data_to_remove);
    /* Now remove the data */
    if (data_to_remove !=0)
84200bb4:	38 04       	Null = r5 - Null;
84200bb6:	0b 60       	if EQ jump (m) Lc_splitter_transition_to_inactive_15;

84200bb8 <Lc_splitter_transition_to_inactive_14>:
    {
        /* remove the metadata */
        remove_metadata_from_internal(splitter, data_to_remove);
84200bb8:	3b 00       	r1 = r5 + Null;
84200bba:	32 00       	r0 = r4 + Null;
84200bbc:	08 f0 29 e2 	call (m) $_remove_metadata_from_internal;
        /* remove the data by copying 0 0 but  removing data */
        unpack_data_from_internal_to_output(splitter, 0, 0, data_to_remove);
84200bc0:	04 00       	r2 = Null + Null;
84200bc2:	03 00       	r1 = Null + Null;
84200bc4:	3d 00       	r3 = r5 + Null;
84200bc6:	32 00       	r0 = r4 + Null;
84200bc8:	fc ff 3b ea 	call (m) Lc_unpack_data_from_internal_to_output_1;

84200bcc <Lc_splitter_transition_to_inactive_15>:
    }

    return TRUE;
84200bcc:	42 20       	r0 = Null + 1;

84200bce <Lc_splitter_transition_to_inactive_16>:
}
84200bce:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84200bd0:	d8 4c       	rts;

84200bd2 <Lc_splitter_transition_to_hold_1>:

/**
 * Transition to HOLD.
 */
static bool splitter_transition_to_hold(SPLITTER_OP_DATA *splitter, unsigned output_index)
{
84200bd2:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200bd4:	10 09       	r6 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84200bd6:	84 f0 15 88 	r2 = M[r6 + 84];
    unsigned read_index;
    unsigned read_offset;

    metadata_buffer = get_internal_metadata_buffer(splitter);
    /* set the metadata read index and head. */
    read_index = metadata_buffer->metadata->prev_rd_index;
84200bda:	a1 89       	rMAC = M[r2 + 24];
84200bdc:	ca 88       	r0 = M[rMAC + 12];
    splitter->internal_metadata.prev_rd_indexes[output_index] = read_index;
84200bde:	5d 54       	r3 = r1 LSHIFT 2;
84200be0:	41 08       	rMAC = r6 + Null;
84200be2:	69 00       	rMAC = r3 + rMAC;
84200be4:	8a af       	M[rMAC + 88] = r0;
    splitter->internal_metadata.head_tag[output_index] = metadata_buffer->metadata->tags.head;
84200be6:	a4 89       	r2 = M[r2 + 24];
84200be8:	24 e8       	r2 = M[r2 + Null];
84200bea:	0c be       	M[rMAC + 96] = r2;
/**
 * Converts metadata read index to buffer offset.
 */
static inline unsigned metadata_read_idx_to_buffer_offset(SPLITTER_OP_DATA *splitter, unsigned position)
{
    unsigned read_offset = -1;
84200bec:	47 24       	r5 = Null - 1;
    /* convert the index to read offset.*/
    if (splitter->tag_size_to_samples)
84200bee:	84 f0 68 82 	r2 = MBU[r6 + 104];
84200bf2:	64 50       	r2 = r2 LSHIFT -2;
84200bf4:	21 c0       	rMAC = r2 AND 0x1;
84200bf6:	23 60       	if EQ jump (m) Lc_splitter_transition_to_hold_11;

84200bf8 <Lc_splitter_transition_to_hold_2>:
    {
        if (splitter->packing == PACKED)
84200bf8:	81 f0 06 80 	rMAC = MBS[r6 + 6];
84200bfc:	48 24       	Null = rMAC - 1;
84200bfe:	1d 62       	if NE jump (m) Lc_splitter_transition_to_hold_10;

84200c00 <Lc_splitter_transition_to_hold_3>:
        {
            read_offset = position<<1;
84200c00:	17 54       	r5 = r0 LSHIFT 1;
84200c02:	22 6e       	jump (m) Lc_splitter_transition_to_hold_13;

84200c04 <Lc_splitter_transition_to_hold_4>:
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200c04:	30 04       	Null = r4 - Null;
84200c06:	17 60       	if EQ jump (m) Lc_splitter_transition_to_hold_9;

84200c08 <Lc_splitter_transition_to_hold_5>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200c08:	41 d8       	rMAC = M[FP + 32];
84200c0a:	1b f0 00 ea 	MB[rMAC + Null] = r9;
/**
 * Function which sets the read offset of one of the output streams.
 */
static inline void set_data_buffer_read_offset(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel, unsigned output_index, unsigned read_offset)
{
    channel->internal.read_offset[output_index] = read_offset;
84200c0e:	67 f0 09 ee 	M[r4 + r7] = r5;
        set_current_output_state(splitter, output_index, HOLD);

        /* set the read offset in the buffer.*/
        set_data_buffer_read_offset(splitter, channel, output_index, read_offset);
        /* If the other output is disconnected set the new read offset.*/
        if (get_current_output_state(splitter, opposite_output_index(output_index)) == INACTIVE)
84200c12:	a1 f0 00 e0 	rMAC = MBS[r8 + Null];
84200c16:	0d 62       	if NE jump (m) Lc_splitter_transition_to_hold_8;

84200c18 <Lc_splitter_transition_to_hold_6>:
        {
            set_buffer_rd_offset(splitter, &channel->internal.buffer, read_offset);
84200c18:	31 29       	rMAC = r4 + 20;
 * Sets the read offset of the internal buffer.
 */
static inline void set_buffer_rd_offset(SPLITTER_OP_DATA *splitter, data_buffer_t *buffer, unsigned offset)
{

    if (splitter->location == INTERNAL)
84200c1a:	82 f0 05 80 	r0 = MBS[r6 + 5];
84200c1e:	25 62       	if NE jump (m) Lc_splitter_transition_to_hold_14;

84200c20 <Lc_splitter_transition_to_hold_7>:
    {
        tCbuffer *cbuffer = buffer->dsp;
84200c20:	0a e8       	r0 = M[rMAC + Null];
        unsigned int base_addr = (unsigned int)(uintptr_t)cbuffer->base_addr;
84200c22:	d1 88       	rMAC = M[r0 + 12];

        cbuffer_set_read_address_ex(cbuffer,
                                    (unsigned int *)((base_addr + offset) & WORD_ALIGNED_MASK),
                                    (offset) & OFFSET_MASK);
84200c24:	bc c0       	r2 = r5 AND 0x3;
84200c26:	79 00       	rMAC = r5 + rMAC;
84200c28:	13 ff fc 1f 	r1 = rMAC AND 0xfffffffc;
84200c2c:	0b f0 35 e1 	call (m) $_cbuffer_set_read_address_ex;

84200c30 <Lc_splitter_transition_to_hold_8>:
        }

        channel = channel->next;
84200c30:	36 e8       	r4 = M[r4 + Null];
    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
    while (channel != NULL)
84200c32:	e9 6f       	jump (m) Lc_splitter_transition_to_hold_4;

84200c34 <Lc_splitter_transition_to_hold_9>:
        }

        channel = channel->next;
    }

    return TRUE;
84200c34:	42 20       	r0 = Null + 1;
84200c36:	1e 6e       	jump (m) Lc_splitter_transition_to_hold_15;

84200c38 <Lc_splitter_transition_to_hold_10>:
        {
            read_offset = position<<1;
        }
        else
        {
            read_offset = position<<2;
84200c38:	57 54       	r5 = r0 LSHIFT 2;
84200c3a:	06 6e       	jump (m) Lc_splitter_transition_to_hold_13;

84200c3c <Lc_splitter_transition_to_hold_11>:
        }
    }
    else if (splitter->cbuffer.data_size  == 1)
84200c3c:	81 f0 25 88 	rMAC = M[r6 + 148];
84200c40:	48 24       	Null = rMAC - 1;
84200c42:	02 62       	if NE jump (m) Lc_splitter_transition_to_hold_13;

84200c44 <Lc_splitter_transition_to_hold_12>:
    {
        read_offset = position;
84200c44:	17 00       	r5 = r0 + Null;

84200c46 <Lc_splitter_transition_to_hold_13>:

    /* Convert the read index to buffer read offset */
    read_offset = metadata_read_idx_to_buffer_offset(splitter, read_index);

    /* Put output streams with index "output_index" on hold. */
    channel = splitter->channel_list;
84200c46:	86 f0 00 e8 	r4 = M[r6 + Null];
84200c4a:	41 08       	rMAC = r6 + Null;
84200c4c:	13 71       	r9 = Null + 2;
84200c4e:	59 00       	rMAC = r1 + rMAC;
84200c50:	09 2a       	rMAC = rMAC + 24;
84200c52:	41 de       	M[FP + 32] = rMAC;
84200c54:	59 20       	rMAC = r1 + 1;
84200c56:	0a c0       	r0 = rMAC AND 0x1;
84200c58:	41 08       	rMAC = r6 + Null;
84200c5a:	51 00       	rMAC = r0 + rMAC;
84200c5c:	1a f0 18 20 	r8 = rMAC + 24;
84200c60:	5a 54       	r0 = r1 LSHIFT 2;
84200c62:	29 f0 18 20 	r7 = r0 + 24;
84200c66:	cf 6f       	jump (m) Lc_splitter_transition_to_hold_4;

84200c68 <Lc_splitter_transition_to_hold_14>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        /* Update the read index for the output.*/
        ext_buffer_set_read_offset(buffer->sram, offset);
84200c68:	0a e8       	r0 = M[rMAC + Null];
84200c6a:	3b 00       	r1 = r5 + Null;
84200c6c:	0b f0 29 e5 	call (m) $_ext_buffer_set_read_offset;
84200c70:	e0 6f       	jump (m) Lc_splitter_transition_to_hold_8;

84200c72 <Lc_splitter_transition_to_hold_15>:

        channel = channel->next;
    }

    return TRUE;
}
84200c72:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200c74:	d8 4c       	rts;

84200c76 <$_splitter_create>:
84200c76:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200c78:	10 09       	r6 = r0 + Null;
84200c7a:	1a 09       	r8 = r1 + Null;
84200c7c:	27 00       	r5 = r2 + Null;
84200c7e:	29 09       	r7 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84200c80:	0a f0 27 eb 	call (m) $_base_op_get_instance_data;
84200c84:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200c86:	4d 08       	r3 = r7 + Null;
84200c88:	3c 00       	r2 = r5 + Null;
84200c8a:	53 08       	r1 = r8 + Null;
84200c8c:	42 08       	r0 = r6 + Null;
84200c8e:	ef fd f9 ff 	call (m) 0x8c;
84200c92:	3f ef 
84200c94:	10 04       	Null = r0 - Null;
84200c96:	03 62       	if NE jump (m) Lc_splitter_create_3;

84200c98 <Lc_splitter_create_2>:
    {
        return FALSE;
84200c98:	02 00       	r0 = Null + Null;
84200c9a:	1d 6e       	jump (m) Lc_splitter_create_4;

84200c9c <Lc_splitter_create_3>:
    }

    splitter->buffer_size = SPLITTER_MIN_INTERNAL_BUFFER_SIZE;
84200c9c:	01 f0 00 48 	rMAC = Null + 1024;
84200ca0:	b1 8e       	M[r4 + 8] = rMAC;
    splitter->data_format = AUDIO_DATA_FORMAT_FIXP;
84200ca2:	41 20       	rMAC = Null + 1;
84200ca4:	f1 8e       	M[r4 + 12] = rMAC;
    splitter->active_streams = OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1;
84200ca6:	b1 b2       	rMAC = MBU[r4 + 26];
84200ca8:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
84200cac:	89 c8       	rMAC = rMAC OR 0x3;
84200cae:	b1 ba       	MB[r4 + 26] = rMAC;
    splitter->self_kick_timer = TIMER_ID_INVALID;
84200cb0:	70 9e       	M[r4 + 36] = Null;
    splitter->working_mode = CLONE_BUFFER;
84200cb2:	30 8b       	MB[r4 + 4] = Null;
#ifdef SPLITTER_OFFLOAD
    /* Todo ask mib if the operator needs to run in offload mode. */
    splitter->offload_enabled = audio_thread_offload_is_active();
#endif

    set_cbuffer_functions(splitter);
84200cb4:	32 00       	r0 = r4 + Null;
84200cb6:	08 f0 2b e8 	call (m) $_set_cbuffer_functions;

    splitter->frame_size = SPLITTER_MIN_FRAME_SIZE;
84200cba:	01 f0 80 40 	rMAC = Null + 128;
84200cbe:	f1 9e       	M[r4 + 44] = rMAC;
    splitter->reframe_data.last_tag_samples       = LAST_TAG_SAMPLES_INVALID;
84200cc0:	41 24       	rMAC = Null - 1;
84200cc2:	71 ae       	M[r4 + 68] = rMAC;
    splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
84200cc4:	b0 ae       	M[r4 + 72] = Null;
    splitter->reframe_enabled = FALSE;
84200cc6:	61 f0 68 82 	rMAC = MBU[r4 + 104];
84200cca:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
84200cce:	61 f0 68 8a 	MB[r4 + 104] = rMAC;

    return TRUE;
84200cd2:	42 20       	r0 = Null + 1;

84200cd4 <Lc_splitter_create_4>:
}
84200cd4:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200cd6:	d8 4c       	rts;

84200cd8 <$_splitter_buffer_details>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200cd8:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200cda:	17 00       	r5 = r0 + Null;
84200cdc:	1e 00       	r4 = r1 + Null;
84200cde:	21 09       	r7 = r2 + Null;
84200ce0:	2a 09       	r8 = r3 + Null;
84200ce2:	0a f0 25 e8 	call (m) $_base_op_get_instance_data;
84200ce6:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200ce8:	6b f0 00 e8 	r9 = M[r4 + Null];
    OP_BUF_DETAILS_RSP *buf_details;
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200cec:	55 08       	r3 = r8 + Null;
84200cee:	4c 08       	r2 = r7 + Null;
84200cf0:	33 00       	r1 = r4 + Null;
84200cf2:	3a 00       	r0 = r5 + Null;
84200cf4:	ef fd f9 ff 	call (m) 0xbe;
84200cf8:	2b ee 
84200cfa:	10 04       	Null = r0 - Null;
84200cfc:	03 62       	if NE jump (m) Lc_splitter_buffer_details_3;

84200cfe <Lc_splitter_buffer_details_2>:
    {
        return FALSE;
84200cfe:	02 00       	r0 = Null + Null;
84200d00:	6c 6e       	jump (m) Lc_splitter_buffer_details_21;

84200d02 <Lc_splitter_buffer_details_3>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
84200d02:	04 12       	r2 = FP + 32;
84200d04:	05 00       	r3 = Null + Null;
84200d06:	03 00       	r1 = Null + Null;
84200d08:	5a 08       	r0 = r9 + Null;
84200d0a:	08 f0 2f e3 	call (m) $_get_terminal_info;
84200d0e:	10 04       	Null = r0 - Null;
84200d10:	07 62       	if NE jump (m) Lc_splitter_buffer_details_5;

84200d12 <Lc_splitter_buffer_details_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
84200d12:	01 f0 03 60 	rMAC = Null + 4099;
84200d16:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200d1a:	51 8e       	M[r0 + 4] = rMAC;
84200d1c:	5d 6e       	jump (m) Lc_splitter_buffer_details_20;

84200d1e <Lc_splitter_buffer_details_5>:
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* Alias the void* to the actual structure to make it easier to work with */
    buf_details = (OP_BUF_DETAILS_RSP*)*response_data;
84200d1e:	a7 f0 00 e8 	r5 = M[r8 + Null];
#ifdef INSTALL_METADATA
    buf_details->supports_metadata = TRUE;
84200d22:	39 92       	rMAC = MBU[r5 + 8];
84200d24:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
84200d28:	c9 c9       	rMAC = rMAC OR 0x10;
84200d2a:	39 9a       	MB[r5 + 8] = rMAC;
    buf_details->metadata_buffer = get_metadata_buffer(splitter, terminal_info.is_input, terminal_info.index);
84200d2c:	5c d8       	r2 = M[FP + 44];
84200d2e:	4b d8       	r1 = M[FP + 36];
84200d30:	42 08       	r0 = r6 + Null;
84200d32:	06 f0 2b e1 	call (m) $_get_metadata_buffer;
84200d36:	fa 8e       	M[r5 + 12] = r0;
#endif
    channel = get_channel_struct(splitter, terminal_info.channel_id);
84200d38:	43 d8       	r1 = M[FP + 32];
84200d3a:	42 08       	r0 = r6 + Null;
84200d3c:	08 f0 2f ec 	call (m) $_get_channel_struct;
    if (channel == NULL)
84200d40:	10 04       	Null = r0 - Null;
84200d42:	07 62       	if NE jump (m) Lc_splitter_buffer_details_7;

84200d44 <Lc_splitter_buffer_details_6>:
84200d44:	01 f0 00 60 	rMAC = Null + 4096;
84200d48:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200d4c:	51 8e       	M[r0 + 4] = rMAC;
84200d4e:	44 6e       	jump (m) Lc_splitter_buffer_details_20;

84200d50 <Lc_splitter_buffer_details_7>:
        /* Unable to find/create the channel.*/
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (splitter->working_mode == CLONE_BUFFER)
84200d50:	81 f0 04 80 	rMAC = MBS[r6 + 4];
84200d54:	39 62       	if NE jump (m) Lc_splitter_buffer_details_19;

84200d56 <Lc_splitter_buffer_details_8>:
    {
        if (terminal_info.is_input)
84200d56:	48 d8       	Null = M[FP + 36];
84200d58:	06 60       	if EQ jump (m) Lc_splitter_buffer_details_11;

84200d5a <Lc_splitter_buffer_details_9>:
        {
            if (splitter->buffer_size != 0)
84200d5a:	81 f0 02 88 	rMAC = M[r6 + 8];
84200d5e:	3c 60       	if EQ jump (m) Lc_splitter_buffer_details_20;

84200d60 <Lc_splitter_buffer_details_10>:
            {
                /* Override the calculated buffer size if one has been set */
                buf_details->b.buffer_size = splitter->buffer_size;
84200d60:	39 8f       	M[r5 + 16] = rMAC;
84200d62:	3a 6e       	jump (m) Lc_splitter_buffer_details_20;

84200d64 <Lc_splitter_buffer_details_11>:
            }
        }
        else
        {
            if (channel->input_buffer == NULL)
84200d64:	96 88       	r4 = M[r0 + 8];
84200d66:	ef 61       	if EQ jump (m) Lc_splitter_buffer_details_6;

84200d68 <Lc_splitter_buffer_details_12>:
            }
            else
            {
                tCbuffer *buffer_to_wrap = channel->input_buffer;

                buf_details->supplies_buffer = TRUE;
84200d68:	39 92       	rMAC = MBU[r5 + 8];
84200d6a:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;
84200d6e:	09 c8       	rMAC = rMAC OR 0x1;
84200d70:	39 9a       	MB[r5 + 8] = rMAC;

                if (channel->output_buffer[terminal_info.index] != NULL)
84200d72:	5b d8       	r1 = M[FP + 44];
84200d74:	5b 54       	r1 = r1 LSHIFT 2;
84200d76:	9a 00       	r0 = r1 + r0;
84200d78:	d1 88       	rMAC = M[r0 + 12];
84200d7a:	03 60       	if EQ jump (m) Lc_splitter_buffer_details_14;

84200d7c <Lc_splitter_buffer_details_13>:
                {
                    /* If this terminal is already connected then make sure the buffer that
                     * is in use is returned to the caller. */
                    buf_details->b.buffer = channel->output_buffer[terminal_info.index];
84200d7c:	39 8f       	M[r5 + 16] = rMAC;
84200d7e:	2c 6e       	jump (m) Lc_splitter_buffer_details_20;

84200d80 <Lc_splitter_buffer_details_14>:
                }
                else
                {
                    /* If buffer details is requested during connect for the same channel
                     * return the buffer being used for connect */
                    if (splitter->curr_connecting == NULL || splitter->curr_connecting->base_addr != buffer_to_wrap->base_addr)
84200d80:	82 f0 08 88 	r0 = M[r6 + 32];
84200d84:	05 60       	if EQ jump (m) Lc_splitter_buffer_details_16;

84200d86 <Lc_splitter_buffer_details_15>:
84200d86:	d1 88       	rMAC = M[r0 + 12];
84200d88:	f3 88       	r1 = M[r4 + 12];
84200d8a:	c8 04       	Null = rMAC - r1;
84200d8c:	19 60       	if EQ jump (m) Lc_splitter_buffer_details_18;

84200d8e <Lc_splitter_buffer_details_16>:
                    {
                        /* A buffer orphaned in a previously aborted connect might exist, free it
                         * before we create a new buffer that might get orphaned that we want to track. */
                        cbuffer_destroy_struct(splitter->curr_connecting);
84200d8e:	ff fd 8d f0 	call (m) 0x12834;
84200d92:	27 e5 

                        /* Store the buffer created here in case it gets orphaned by connect failing */
                        splitter->curr_connecting = cbuffer_create(buffer_to_wrap->base_addr,
                            cbuffer_get_size_in_words(buffer_to_wrap), BUF_DESC_SW_BUFFER);
84200d94:	32 00       	r0 = r4 + Null;
84200d96:	ff fd 8d f0 	call (m) 0x12858;
84200d9a:	23 e6 
84200d9c:	13 00       	r1 = r0 + Null;
84200d9e:	f2 88       	r0 = M[r4 + 12];
84200da0:	04 00       	r2 = Null + Null;
84200da2:	ff fd 8c f0 	call (m) 0x12762;
84200da6:	21 ee 
84200da8:	82 f0 08 8e 	M[r6 + 32] = r0;

                        if (splitter->curr_connecting != NULL)
84200dac:	81 f0 08 88 	rMAC = M[r6 + 32];
84200db0:	ca 61       	if EQ jump (m) Lc_splitter_buffer_details_6;

84200db2 <Lc_splitter_buffer_details_17>:
                        {
                            splitter->curr_connecting->write_ptr = buffer_to_wrap->write_ptr;
84200db2:	b2 88       	r0 = M[r4 + 8];
84200db4:	8a 8e       	M[rMAC + 8] = r0;
                            splitter->curr_connecting->read_ptr = buffer_to_wrap->write_ptr;
84200db6:	b1 88       	rMAC = M[r4 + 8];
84200db8:	82 f0 08 88 	r0 = M[r6 + 32];
84200dbc:	51 8e       	M[r0 + 4] = rMAC;

84200dbe <Lc_splitter_buffer_details_18>:
                            /* There wasn't enough RAM so we have to fail */
                            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                            return TRUE;
                        }
                    }
                    buf_details->b.buffer = splitter->curr_connecting;
84200dbe:	81 f0 08 88 	rMAC = M[r6 + 32];
84200dc2:	39 8f       	M[r5 + 16] = rMAC;
84200dc4:	09 6e       	jump (m) Lc_splitter_buffer_details_20;

84200dc6 <Lc_splitter_buffer_details_19>:
        }

    }
    else
    {
        buf_details->supplies_buffer = FALSE;
84200dc6:	39 92       	rMAC = MBU[r5 + 8];
84200dc8:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;
84200dcc:	39 9a       	MB[r5 + 8] = rMAC;
        /* The splitter capability will have an internal or external buffer.
         * Use a transform buffer which can fit two frames. */
        buf_details->b.buffer_size = splitter->frame_size * 2 ;
84200dce:	82 f0 0b 88 	r0 = M[r6 + 44];
84200dd2:	12 54       	r0 = r0 LSHIFT 1;
84200dd4:	3a 8f       	M[r5 + 16] = r0;

84200dd6 <Lc_splitter_buffer_details_20>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200dd6:	42 20       	r0 = Null + 1;

84200dd8 <Lc_splitter_buffer_details_21>:
        buf_details->b.buffer_size = splitter->frame_size * 2 ;
    }


    return TRUE;
}
84200dd8:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200dda:	d8 4c       	rts;

84200ddc <$_splitter_get_sched_info>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200ddc:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200dde:	17 00       	r5 = r0 + Null;
84200de0:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;
    *response_id = OPCMD_GET_SCHED_INFO;
84200de2:	41 22       	rMAC = Null + 9;
84200de4:	21 ee       	M[r2 + Null] = rMAC;
    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200de6:	09 f0 35 ed 	call (m) $_base_op_get_sched_info_ex;
    if (resp == NULL)
84200dea:	10 04       	Null = r0 - Null;
84200dec:	08 62       	if NE jump (m) Lc_splitter_get_sched_info_3;

84200dee <Lc_splitter_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200dee:	03 f0 00 60 	r1 = Null + 4096;
84200df2:	34 00       	r2 = r4 + Null;
84200df4:	3a 00       	r0 = r5 + Null;
84200df6:	09 f0 25 ee 	call (m) $_base_op_build_std_response_ex;
84200dfa:	05 6e       	jump (m) Lc_splitter_get_sched_info_4;

84200dfc <Lc_splitter_get_sched_info_3>:
    }
    *response_data = resp;
84200dfc:	32 ee       	M[r4 + Null] = r0;

    /* Same buffer size for sink and source.
       No additional verification needed.*/
    resp->block_size = SPLITTER_BLOCK_SIZE;
84200dfe:	41 20       	rMAC = Null + 1;
84200e00:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200e02:	0a 00       	r0 = rMAC + Null;

84200e04 <Lc_splitter_get_sched_info_4>:
}
84200e04:	f2 48       	popm <FP, r4, r5, rLink>;
84200e06:	d8 4c       	rts;

84200e08 <$_splitter_connect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200e08:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200e0a:	12 09       	r8 = r0 + Null;
84200e0c:	1e 00       	r4 = r1 + Null;
84200e0e:	20 09       	r6 = r2 + Null;
84200e10:	29 09       	r7 = r3 + Null;
84200e12:	09 f0 35 ee 	call (m) $_base_op_get_instance_data;
84200e16:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);
84200e18:	6b f0 00 e8 	r9 = M[r4 + Null];
    tCbuffer* buffer = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
84200e1c:	76 88       	r4 = M[r4 + 4];
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_connect",base_op_get_ext_op_id(op_data));

    *response_id = OPCMD_CONNECT;
84200e1e:	41 21       	rMAC = Null + 5;
84200e20:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200e24:	03 00       	r1 = Null + Null;
84200e26:	4c 08       	r2 = r7 + Null;
84200e28:	52 08       	r0 = r8 + Null;
84200e2a:	09 f0 31 ec 	call (m) $_base_op_build_std_response_ex;
84200e2e:	10 04       	Null = r0 - Null;
84200e30:	03 62       	if NE jump (m) Lc_splitter_connect_3;

84200e32 <Lc_splitter_connect_2>:
    {
        return FALSE;
84200e32:	02 00       	r0 = Null + Null;
84200e34:	c9 6e       	jump (m) Lc_splitter_connect_35;

84200e36 <Lc_splitter_connect_3>:
    }

    if (!get_terminal_info(terminal_id, buffer, &terminal_info, TRUE))
84200e36:	45 20       	r3 = Null + 1;
84200e38:	04 12       	r2 = FP + 32;
84200e3a:	33 00       	r1 = r4 + Null;
84200e3c:	5a 08       	r0 = r9 + Null;
84200e3e:	07 f0 3b e9 	call (m) $_get_terminal_info;
84200e42:	10 04       	Null = r0 - Null;
84200e44:	07 62       	if NE jump (m) Lc_splitter_connect_5;

84200e46 <Lc_splitter_connect_4>:
84200e46:	01 f0 03 60 	rMAC = Null + 4099;
84200e4a:	92 f0 00 e8 	r0 = M[r7 + Null];
84200e4e:	51 8e       	M[r0 + 4] = rMAC;
84200e50:	ba 6e       	jump (m) Lc_splitter_connect_34;

84200e52 <Lc_splitter_connect_5>:
    }

    SPLITTER_MSG1("#### SPLITTER 0x%08x ####",base_op_get_ext_op_id(op_data));
    SPLITTER_MSG2("connect is_input = %d, index = %d",terminal_info.is_input, terminal_info.index);

    channel = get_channel_struct(splitter, terminal_info.channel_id);
84200e52:	43 d8       	r1 = M[FP + 32];
84200e54:	3a 00       	r0 = r5 + Null;
84200e56:	08 f0 35 e3 	call (m) $_get_channel_struct;
84200e5a:	16 00       	r4 = r0 + Null;
    if (channel == NULL)
84200e5c:	07 62       	if NE jump (m) Lc_splitter_connect_7;

84200e5e <Lc_splitter_connect_6>:
84200e5e:	01 f0 00 60 	rMAC = Null + 4096;
84200e62:	92 f0 00 e8 	r0 = M[r7 + Null];
84200e66:	51 8e       	M[r0 + 4] = rMAC;
84200e68:	ae 6e       	jump (m) Lc_splitter_connect_34;

84200e6a <Lc_splitter_connect_7>:
        /* Unable to find/create the channel.*/
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (terminal_info.is_input)
84200e6a:	4b d8       	r1 = M[FP + 36];
84200e6c:	23 60       	if EQ jump (m) Lc_splitter_connect_13;

84200e6e <Lc_splitter_connect_8>:
    {
        SPLITTER_MSG2("Splitter: Connecting sink terminal %4d to buff 0x%08x!", terminal_info.terminal_num, terminal_info.buffer);
        if (channel->input_buffer == NULL)
84200e6e:	b1 88       	rMAC = M[r4 + 8];
84200e70:	aa 62       	if NE jump (m) Lc_splitter_connect_34;

84200e72 <Lc_splitter_connect_9>:
        {
#ifdef INSTALL_METADATA
            tCbuffer *metadata_buf = get_metadata_buffer(splitter, terminal_info.is_input, terminal_info.index);
84200e72:	5c d8       	r2 = M[FP + 44];
84200e74:	3a 00       	r0 = r5 + Null;
84200e76:	05 f0 27 e7 	call (m) $_get_metadata_buffer;

            if ((metadata_buf != NULL) && (metadata_buf->metadata != terminal_info.buffer->metadata))
84200e7a:	10 04       	Null = r0 - Null;
84200e7c:	12 60       	if EQ jump (m) Lc_splitter_connect_12;

84200e7e <Lc_splitter_connect_10>:
84200e7e:	91 89       	rMAC = M[r0 + 24];
84200e80:	62 d8       	r0 = M[FP + 48];
84200e82:	92 89       	r0 = M[r0 + 24];
84200e84:	88 04       	Null = rMAC - r0;
84200e86:	0d 60       	if EQ jump (m) Lc_splitter_connect_12;

84200e88 <Lc_splitter_connect_11>:
84200e88:	01 f0 00 60 	rMAC = Null + 4096;
84200e8c:	92 f0 00 e8 	r0 = M[r7 + Null];
84200e90:	51 8e       	M[r0 + 4] = rMAC;
            {
                base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                SPLITTER_ERRORMSG("Splitter: The two input has different metadata!");
84200e92:	55 f1 02 f0 	r0 = Null + 357565738;
84200e96:	2a 49 
84200e98:	ef fd fd ff 	call (m) 0x9a2;
84200e9c:	2b e8 
84200e9e:	93 6e       	jump (m) Lc_splitter_connect_34;

84200ea0 <Lc_splitter_connect_12>:
                return TRUE;
            }
#endif
            channel->input_buffer = terminal_info.buffer;
84200ea0:	61 d8       	rMAC = M[FP + 48];
84200ea2:	b1 8e       	M[r4 + 8] = rMAC;

            /* Set the active sinks. */
            splitter->touched_sinks |= TOUCHED_SINK_0 << terminal_info.terminal_num;
84200ea4:	51 d8       	rMAC = M[FP + 40];
84200ea6:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200eaa:	39 89       	rMAC = M[r5 + 16];
84200eac:	89 12       	rMAC = rMAC OR r0;
84200eae:	39 8f       	M[r5 + 16] = rMAC;
84200eb0:	8a 6e       	jump (m) Lc_splitter_connect_34;

84200eb2 <Lc_splitter_connect_13>:
        }
    }
    else
    {
        SPLITTER_MSG2("Splitter: Connecting source terminal %4d to buff 0x%08x!", terminal_info.terminal_num, terminal_info.buffer);
        if (opmgr_op_is_running(op_data) &&(get_current_output_state(splitter, terminal_info.index) == ACTIVE))
84200eb2:	52 08       	r0 = r8 + Null;
84200eb4:	09 f0 23 e6 	call (m) $_opmgr_op_is_running;
84200eb8:	10 04       	Null = r0 - Null;
84200eba:	15 60       	if EQ jump (m) Lc_splitter_connect_16;

84200ebc <Lc_splitter_connect_14>:
84200ebc:	5a d8       	r0 = M[FP + 44];
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200ebe:	39 00       	rMAC = r5 + Null;
84200ec0:	51 00       	rMAC = r0 + rMAC;
84200ec2:	09 b0       	rMAC = MBS[rMAC + 24];
84200ec4:	48 24       	Null = rMAC - 1;
84200ec6:	0f 62       	if NE jump (m) Lc_splitter_connect_16;

84200ec8 <Lc_splitter_connect_15>:
84200ec8:	01 f0 00 60 	rMAC = Null + 4096;
84200ecc:	92 f0 00 e8 	r0 = M[r7 + Null];
84200ed0:	51 8e       	M[r0 + 4] = rMAC;
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            SPLITTER_ERRORMSG2("Splitter: Channel %d Output %d is already active and operator is running!",
                    terminal_info.channel_id, terminal_info.index);
84200ed2:	5c d8       	r2 = M[FP + 44];
84200ed4:	43 d8       	r1 = M[FP + 32];
84200ed6:	55 f1 02 f0 	r0 = Null + 357565786;
84200eda:	5a 49 
84200edc:	ef fd fd ff 	call (m) 0x9c8;
84200ee0:	2d e7 
84200ee2:	71 6e       	jump (m) Lc_splitter_connect_34;

84200ee4 <Lc_splitter_connect_16>:
            return TRUE;
        }
        if (channel->output_buffer[terminal_info.index] == NULL)
84200ee4:	5a d8       	r0 = M[FP + 44];
84200ee6:	31 00       	rMAC = r4 + Null;
84200ee8:	52 54       	r0 = r0 LSHIFT 2;
84200eea:	51 00       	rMAC = r0 + rMAC;
84200eec:	09 23       	rMAC = rMAC + 12;
84200eee:	0a e8       	r0 = M[rMAC + Null];
84200ef0:	5d 62       	if NE jump (m) Lc_splitter_connect_33;

84200ef2 <Lc_splitter_connect_17>:
        {
            channel->output_buffer[terminal_info.index] = terminal_info.buffer;
84200ef2:	62 d8       	r0 = M[FP + 48];
84200ef4:	0a ee       	M[rMAC + Null] = r0;

            if(splitter->working_mode == CLONE_BUFFER)
84200ef6:	39 81       	rMAC = MBS[r5 + 4];
84200ef8:	0e 62       	if NE jump (m) Lc_splitter_connect_21;

84200efa <Lc_splitter_connect_18>:
            {
                /* This should be the curr_connecting buffer that buffer_details
                 * stashed. If it isn't fail the request as something went wrong,
                 * otherwise it's not in danger of being orphaned any more. */
                PL_ASSERT(terminal_info.buffer == splitter->curr_connecting);
84200efa:	61 d8       	rMAC = M[FP + 48];
84200efc:	3a 98       	r0 = M[r5 + 32];
84200efe:	88 04       	Null = rMAC - r0;
84200f00:	09 60       	if EQ jump (m) Lc_splitter_connect_20;

84200f02 <Lc_splitter_connect_19>:
84200f02:	03 f0 a4 41 	r1 = Null + 420;
84200f06:	02 f0 13 60 	r0 = Null + 4115;
84200f0a:	ff fd 98 f0 	call (m) 0x13f12;
84200f0e:	29 e0 
84200f10:	5b 6e       	jump (m) Lc_splitter_connect_35;

84200f12 <Lc_splitter_connect_20>:
                splitter->curr_connecting = NULL;
84200f12:	38 9e       	M[r5 + 32] = Null;

84200f14 <Lc_splitter_connect_21>:
            }

#ifdef INSTALL_METADATA
            if (buff_has_metadata(terminal_info.buffer))
84200f14:	61 d8       	rMAC = M[FP + 48];
84200f16:	49 89       	rMAC = M[rMAC + 20];
84200f18:	49 c6       	rMAC = rMAC AND 0x8000;
84200f1a:	0b 60       	if EQ jump (m) Lc_splitter_connect_23;

84200f1c <Lc_splitter_connect_22>:
            {
                /* Set the usable octet */
                cbuffer_set_usable_octets(channel->output_buffer[terminal_info.index],
                        cbuffer_get_usable_octets(channel->input_buffer));
84200f1c:	b2 88       	r0 = M[r4 + 8];
84200f1e:	09 f0 29 e7 	call (m) $_cbuffer_get_usable_octets;
84200f22:	13 00       	r1 = r0 + Null;
84200f24:	5a d8       	r0 = M[FP + 44];
84200f26:	52 54       	r0 = r0 LSHIFT 2;
84200f28:	96 01       	r4 = r0 + r4;
84200f2a:	f2 88       	r0 = M[r4 + 12];
84200f2c:	09 f0 2d e7 	call (m) $_cbuffer_set_usable_octets;

84200f30 <Lc_splitter_connect_23>:
            }
#endif
            /* Activate the stream if needed if the operator is not running. */
            if (get_next_output_state(splitter, terminal_info.index) == ACTIVE)
84200f30:	59 d8       	rMAC = M[FP + 44];
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84200f32:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
    if (splitter->active_streams & channel_mask)
84200f36:	b9 b2       	rMAC = MBU[r5 + 26];
84200f38:	89 10       	rMAC = rMAC AND r0;
84200f3a:	89 c0       	rMAC = rMAC AND 0x3;
84200f3c:	0b 60       	if EQ jump (m) Lc_splitter_connect_26;

84200f3e <Lc_splitter_connect_24>:
            {
                PL_ASSERT(!opmgr_op_is_running(op_data));
84200f3e:	52 08       	r0 = r8 + Null;
84200f40:	09 f0 37 e1 	call (m) $_opmgr_op_is_running;
84200f44:	10 04       	Null = r0 - Null;
84200f46:	15 62       	if NE jump (m) Lc_splitter_connect_28;

84200f48 <Lc_splitter_connect_25>:
                set_current_output_state(splitter, terminal_info.index, ACTIVE);
84200f48:	5a d8       	r0 = M[FP + 44];
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
84200f4a:	43 20       	r1 = Null + 1;
84200f4c:	39 00       	rMAC = r5 + Null;
84200f4e:	51 00       	rMAC = r0 + rMAC;
84200f50:	0b ba       	MB[rMAC + 24] = r1;

84200f52 <Lc_splitter_connect_26>:
            }
            /* Check if the channel is already on hold. */
            if (get_next_output_state(splitter, terminal_info.index) == HOLD)
84200f52:	59 d8       	rMAC = M[FP + 44];
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84200f54:	0a 00       	r0 = rMAC + Null;
84200f56:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
    if (splitter->active_streams & channel_mask)
84200f5a:	bb b2       	r1 = MBU[r5 + 26];
84200f5c:	9c 10       	r2 = r1 AND r0;
84200f5e:	a4 c0       	r2 = r2 AND 0x3;
84200f60:	10 60       	if EQ jump (m) Lc_splitter_connect_29;

84200f62 <Lc_splitter_connect_27>:
            {
                PL_ASSERT(get_current_output_state(splitter, terminal_info.index) == HOLD);
            }
            /* Set the active sources.*/
            splitter->touched_sources |= TOUCHED_SOURCE_0 << terminal_info.terminal_num;
84200f62:	51 d8       	rMAC = M[FP + 40];
84200f64:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200f68:	79 89       	rMAC = M[r5 + 20];
84200f6a:	89 12       	rMAC = rMAC OR r0;
84200f6c:	79 8f       	M[r5 + 20] = rMAC;
84200f6e:	2b 6e       	jump (m) Lc_splitter_connect_34;

84200f70 <Lc_splitter_connect_28>:
            }
#endif
            /* Activate the stream if needed if the operator is not running. */
            if (get_next_output_state(splitter, terminal_info.index) == ACTIVE)
            {
                PL_ASSERT(!opmgr_op_is_running(op_data));
84200f70:	03 f0 b3 41 	r1 = Null + 435;
84200f74:	02 f0 13 60 	r0 = Null + 4115;
84200f78:	ff fd 97 f0 	call (m) 0x13f12;
84200f7c:	3b ec 
84200f7e:	24 6e       	jump (m) Lc_splitter_connect_35;

84200f80 <Lc_splitter_connect_29>:
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
84200f80:	5c 50       	r2 = r1 LSHIFT -2;
84200f82:	a4 10       	r2 = r2 AND r0;
84200f84:	a4 c0       	r2 = r2 AND 0x3;
84200f86:	ee 63       	if NE jump (m) Lc_splitter_connect_27;

84200f88 <Lc_splitter_connect_30>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
84200f88:	db 50       	r1 = r1 LSHIFT -4;
84200f8a:	d2 10       	r0 = r0 AND r1;
84200f8c:	92 c0       	r0 = r0 AND 0x3;
84200f8e:	ea 61       	if EQ jump (m) Lc_splitter_connect_27;

84200f90 <Lc_splitter_connect_31>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84200f90:	3a 00       	r0 = r5 + Null;
84200f92:	8a 00       	r0 = rMAC + r0;
84200f94:	11 b0       	rMAC = MBS[r0 + 24];
                set_current_output_state(splitter, terminal_info.index, ACTIVE);
            }
            /* Check if the channel is already on hold. */
            if (get_next_output_state(splitter, terminal_info.index) == HOLD)
            {
                PL_ASSERT(get_current_output_state(splitter, terminal_info.index) == HOLD);
84200f96:	88 24       	Null = rMAC - 2;
84200f98:	e5 61       	if EQ jump (m) Lc_splitter_connect_27;

84200f9a <Lc_splitter_connect_32>:
84200f9a:	03 f0 b9 41 	r1 = Null + 441;
84200f9e:	02 f0 13 60 	r0 = Null + 4115;
84200fa2:	ff fd 97 f0 	call (m) 0x13f12;
84200fa6:	31 eb 
84200fa8:	0f 6e       	jump (m) Lc_splitter_connect_35;

84200faa <Lc_splitter_connect_33>:
84200faa:	01 f0 00 60 	rMAC = Null + 4096;
84200fae:	92 f0 00 e8 	r0 = M[r7 + Null];
84200fb2:	51 8e       	M[r0 + 4] = rMAC;
        }
        else
        {
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            SPLITTER_ERRORMSG2("Splitter: Channel %d Output %d is already connected!",
                    terminal_info.channel_id, terminal_info.index);
84200fb4:	5c d8       	r2 = M[FP + 44];
84200fb6:	43 d8       	r1 = M[FP + 32];
84200fb8:	55 f1 02 f0 	r0 = Null + 357565860;
84200fbc:	a4 49 
84200fbe:	ef fd fd ff 	call (m) 0x9c8;
84200fc2:	2b e0 

84200fc4 <Lc_splitter_connect_34>:
    }

    if (!get_terminal_info(terminal_id, buffer, &terminal_info, TRUE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200fc4:	42 20       	r0 = Null + 1;

84200fc6 <Lc_splitter_connect_35>:
        }

    }

    return TRUE;
}
84200fc6:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200fc8:	d8 4c       	rts;

84200fca <$_splitter_start>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200fca:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200fcc:	16 00       	r4 = r0 + Null;
84200fce:	1a 09       	r8 = r1 + Null;
84200fd0:	27 00       	r5 = r2 + Null;
84200fd2:	28 09       	r6 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84200fd4:	09 f0 33 e0 	call (m) $_base_op_get_instance_data;
84200fd8:	11 09       	r7 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_start",base_op_get_ext_op_id(op_data));
    
    *response_id = OPCMD_START;
84200fda:	81 20       	rMAC = Null + 2;
84200fdc:	39 ee       	M[r5 + Null] = rMAC;
    /* Check if the operator is already running */
    if (opmgr_op_is_running(op_data))
84200fde:	32 00       	r0 = r4 + Null;
84200fe0:	08 f0 37 ec 	call (m) $_opmgr_op_is_running;
84200fe4:	10 04       	Null = r0 - Null;
84200fe6:	0a 60       	if EQ jump (m) Lc_splitter_start_4;

84200fe8 <Lc_splitter_start_2>:
    {
        if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200fe8:	03 00       	r1 = Null + Null;
84200fea:	44 08       	r2 = r6 + Null;
84200fec:	32 00       	r0 = r4 + Null;
84200fee:	08 f0 2d ee 	call (m) $_base_op_build_std_response_ex;
84200ff2:	10 04       	Null = r0 - Null;
84200ff4:	14 62       	if NE jump (m) Lc_splitter_start_7;

84200ff6 <Lc_splitter_start_3>:
        {
            return FALSE;
84200ff6:	02 00       	r0 = Null + Null;
84200ff8:	13 6e       	jump (m) Lc_splitter_start_8;

84200ffa <Lc_splitter_start_4>:
            return TRUE;
        }
    }

    /* Start the operator. */
    if (!base_op_start(op_data, message_data, response_id, response_data))
84200ffa:	45 08       	r3 = r6 + Null;
84200ffc:	3c 00       	r2 = r5 + Null;
84200ffe:	53 08       	r1 = r8 + Null;
84201000:	32 00       	r0 = r4 + Null;
84201002:	ef fd f8 ff 	call (m) 0x4a;
84201006:	29 e2 
84201008:	10 04       	Null = r0 - Null;
8420100a:	f6 61       	if EQ jump (m) Lc_splitter_start_3;

8420100c <Lc_splitter_start_5>:
    {
        return FALSE;
    }

    /* Splitter cannot run without channels. */
    if (splitter->channel_list == NULL)
8420100c:	91 f0 00 e8 	rMAC = M[r7 + Null];
84201010:	06 62       	if NE jump (m) Lc_splitter_start_7;

84201012 <Lc_splitter_start_6>:
84201012:	01 f0 00 60 	rMAC = Null + 4096;
84201016:	82 f0 00 e8 	r0 = M[r6 + Null];
8420101a:	51 8e       	M[r0 + 4] = rMAC;

8420101c <Lc_splitter_start_7>:
        {
            return FALSE;
        }
        else
        {
            return TRUE;
8420101c:	42 20       	r0 = Null + 1;

8420101e <Lc_splitter_start_8>:
        /* At least one input and its corresponding output(s)
           need to be connected */
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    }
    return TRUE;
}
8420101e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201020:	d8 4c       	rts;

84201022 <$_splitter_disconnect>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84201022:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84201024:	11 09       	r7 = r0 + Null;
84201026:	1f 00       	r5 = r1 + Null;
84201028:	20 09       	r6 = r2 + Null;
8420102a:	2a 09       	r8 = r3 + Null;
8420102c:	08 f0 3b ed 	call (m) $_base_op_get_instance_data;
84201030:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
84201032:	3f e8       	r5 = M[r5 + Null];
    unsigned i;
    terminal_info_t terminal_info;
    SPLITTER_CHANNEL_STRUC *channel;

    *response_id = OPCMD_DISCONNECT;
84201034:	81 21       	rMAC = Null + 6;
84201036:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420103a:	03 00       	r1 = Null + Null;
8420103c:	54 08       	r2 = r8 + Null;
8420103e:	4a 08       	r0 = r7 + Null;
84201040:	08 f0 3b eb 	call (m) $_base_op_build_std_response_ex;
84201044:	10 04       	Null = r0 - Null;
84201046:	03 62       	if NE jump (m) Lc_splitter_disconnect_3;

84201048 <Lc_splitter_disconnect_2>:
    {
        return FALSE;
84201048:	02 00       	r0 = Null + Null;
8420104a:	6b 6e       	jump (m) Lc_splitter_disconnect_24;

8420104c <Lc_splitter_disconnect_3>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
8420104c:	c4 11       	r2 = FP + 28;
8420104e:	05 00       	r3 = Null + Null;
84201050:	03 00       	r1 = Null + Null;
84201052:	3a 00       	r0 = r5 + Null;
84201054:	06 f0 25 e9 	call (m) $_get_terminal_info;
84201058:	10 04       	Null = r0 - Null;
8420105a:	07 62       	if NE jump (m) Lc_splitter_disconnect_5;

8420105c <Lc_splitter_disconnect_4>:
8420105c:	01 f0 03 60 	rMAC = Null + 4099;
84201060:	a2 f0 00 e8 	r0 = M[r8 + Null];
84201064:	51 8e       	M[r0 + 4] = rMAC;
84201066:	5c 6e       	jump (m) Lc_splitter_disconnect_23;

84201068 <Lc_splitter_disconnect_5>:
    }

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_disconnect",base_op_get_ext_op_id(op_data));
    SPLITTER_MSG2("disconnect is_input = %d, index = %d",terminal_info.is_input, terminal_info.index);

    channel = get_channel_struct(splitter, terminal_info.channel_id);
84201068:	3b d8       	r1 = M[FP + 28];
8420106a:	32 00       	r0 = r4 + Null;
8420106c:	07 f0 3f e2 	call (m) $_get_channel_struct;
84201070:	17 00       	r5 = r0 + Null;
    if (channel == NULL)
84201072:	0e 60       	if EQ jump (m) Lc_splitter_disconnect_9;

84201074 <Lc_splitter_disconnect_6>:
        /* Unable to find/create the channel.*/
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
84201074:	4a 08       	r0 = r7 + Null;
84201076:	08 f0 21 e8 	call (m) $_opmgr_op_is_running;
8420107a:	10 04       	Null = r0 - Null;
8420107c:	1c 60       	if EQ jump (m) Lc_splitter_disconnect_12;

8420107e <Lc_splitter_disconnect_7>:
    {
        bool error = FALSE;
        if (terminal_info.is_input)
8420107e:	40 d8       	Null = M[FP + 32];
84201080:	0d 60       	if EQ jump (m) Lc_splitter_disconnect_10;

84201082 <Lc_splitter_disconnect_8>:
        {
            SPLITTER_ERRORMSG("Splitter: Input buffers cannot be disconnected even if the data is buffered.");
84201082:	55 f1 02 f0 	r0 = Null + 357565913;
84201086:	d9 49 
84201088:	ef fd fc ff 	call (m) 0x9a2;
8420108c:	3b e8 

8420108e <Lc_splitter_disconnect_9>:
8420108e:	01 f0 00 60 	rMAC = Null + 4096;
84201092:	a2 f0 00 e8 	r0 = M[r8 + Null];
84201096:	51 8e       	M[r0 + 4] = rMAC;
84201098:	43 6e       	jump (m) Lc_splitter_disconnect_23;

8420109a <Lc_splitter_disconnect_10>:
            error = TRUE;
        }
        else
        {
            if (get_current_output_state(splitter, terminal_info.index) == ACTIVE)
8420109a:	52 d8       	r0 = M[FP + 40];
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
8420109c:	31 00       	rMAC = r4 + Null;
8420109e:	51 00       	rMAC = r0 + rMAC;
842010a0:	09 b0       	rMAC = MBS[rMAC + 24];
842010a2:	48 24       	Null = rMAC - 1;
842010a4:	08 62       	if NE jump (m) Lc_splitter_disconnect_12;

842010a6 <Lc_splitter_disconnect_11>:
            {
                SPLITTER_ERRORMSG("Splitter: Active outputs cannot be disconnected.");
842010a6:	55 f1 02 f0 	r0 = Null + 357565990;
842010aa:	26 4a 
842010ac:	ef fd fc ff 	call (m) 0x9a2;
842010b0:	37 e7 
842010b2:	ee 6f       	jump (m) Lc_splitter_disconnect_9;

842010b4 <Lc_splitter_disconnect_12>:
            return TRUE;
        }
    }


    if (terminal_info.is_input)
842010b4:	40 d8       	Null = M[FP + 32];
842010b6:	1b 60       	if EQ jump (m) Lc_splitter_disconnect_19;

842010b8 <Lc_splitter_disconnect_13>:
    {
        SPLITTER_MSG1("Splitter: Disconnecting sink terminal %4d!", terminal_info.terminal_num);
        channel->input_buffer = NULL;
842010b8:	b8 8e       	M[r5 + 8] = Null;
        splitter->touched_sinks &= ~(TOUCHED_SINK_0 << terminal_info.terminal_num);
842010ba:	49 d8       	rMAC = M[FP + 36];
842010bc:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
842010c0:	ff f2 51 d6 	rMAC = -1 - r0;
842010c4:	32 89       	r0 = M[r4 + 16];
842010c6:	89 10       	rMAC = rMAC AND r0;
842010c8:	31 8f       	M[r4 + 16] = rMAC;

        if (splitter->working_mode == CLONE_BUFFER)
842010ca:	31 81       	rMAC = MBS[r4 + 4];
842010cc:	26 62       	if NE jump (m) Lc_splitter_disconnect_22;

842010ce <Lc_splitter_disconnect_14>:
        {
            /* If there are outputs connected we need to make them look empty.
             * This shouldn't be done by the user, but we can't reject the
             * scenario when we're stopped as destroy operator needs to
             * disconnect all terminals before the operator are destroyed. */
            opmgr_op_suspend_processing(op_data);
842010ce:	4a 08       	r0 = r7 + Null;
842010d0:	08 f0 33 e5 	call (m) $_opmgr_op_suspend_processing;
842010d4:	3a 23       	r0 = r5 + 12;
            for (i = 0; i < SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842010d6:	14 71       	r10 = Null + 2;
842010d8:	06 4c       	do (m) Lc__loop0;

842010da <Lc_splitter_disconnect_15>:
            {
                tCbuffer *out = channel->output_buffer[i];
                if (out != NULL)
842010da:	11 e8       	rMAC = M[r0 + Null];
842010dc:	03 60       	if EQ jump (m) Lc_splitter_disconnect_17;

842010de <Lc_splitter_disconnect_16>:
                {
                    out->write_ptr = out->read_ptr;
842010de:	4b 88       	r1 = M[rMAC + 4];
842010e0:	8b 8e       	M[rMAC + 8] = r1;

842010e2 <Lc_splitter_disconnect_17>:
842010e2:	12 21       	r0 = r0 + 4;

842010e4 <Lc__loop0>:
            /* If there are outputs connected we need to make them look empty.
             * This shouldn't be done by the user, but we can't reject the
             * scenario when we're stopped as destroy operator needs to
             * disconnect all terminals before the operator are destroyed. */
            opmgr_op_suspend_processing(op_data);
            for (i = 0; i < SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
842010e4:	4a 08       	r0 = r7 + Null;
842010e6:	08 f0 29 e5 	call (m) $_opmgr_op_resume_processing;
842010ea:	17 6e       	jump (m) Lc_splitter_disconnect_22;

842010ec <Lc_splitter_disconnect_19>:
        }
    }
    else
    {
        SPLITTER_MSG1("Splitter: Disconnecting source terminal %4d!", terminal_info.terminal_num);
        splitter->touched_sinks &= ~(TOUCHED_SINK_0 << terminal_info.terminal_num);
842010ec:	49 d8       	rMAC = M[FP + 36];
842010ee:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
842010f2:	ff f2 51 d6 	rMAC = -1 - r0;
842010f6:	32 89       	r0 = M[r4 + 16];
842010f8:	89 10       	rMAC = rMAC AND r0;
842010fa:	31 8f       	M[r4 + 16] = rMAC;

        if (splitter->working_mode == CLONE_BUFFER)
842010fc:	31 81       	rMAC = MBS[r4 + 4];
842010fe:	09 62       	if NE jump (m) Lc_splitter_disconnect_21;

84201100 <Lc_splitter_disconnect_20>:
        {
            tCbuffer* buff;
            buff = channel->output_buffer[terminal_info.index];
84201100:	52 d8       	r0 = M[FP + 40];
84201102:	39 00       	rMAC = r5 + Null;
84201104:	52 54       	r0 = r0 LSHIFT 2;
84201106:	51 00       	rMAC = r0 + rMAC;
84201108:	ca 88       	r0 = M[rMAC + 12];
            cbuffer_destroy_struct(buff);
8420110a:	ff fd 8b f0 	call (m) 0x12834;
8420110e:	2b e9 

84201110 <Lc_splitter_disconnect_21>:
        }
        channel->output_buffer[terminal_info.index] = NULL;
84201110:	52 d8       	r0 = M[FP + 40];
84201112:	52 54       	r0 = r0 LSHIFT 2;
84201114:	d7 01       	r5 = r0 + r5;
84201116:	f8 8e       	M[r5 + 12] = Null;

84201118 <Lc_splitter_disconnect_22>:
    }

    delete_disconnected_channel(splitter);
84201118:	32 00       	r0 = r4 + Null;
8420111a:	07 f0 21 e0 	call (m) $_delete_disconnected_channel;

8420111e <Lc_splitter_disconnect_23>:
    }

    if (!get_terminal_info(terminal_id, NULL, &terminal_info, FALSE))
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
8420111e:	42 20       	r0 = Null + 1;

84201120 <Lc_splitter_disconnect_24>:
        channel->output_buffer[terminal_info.index] = NULL;
    }

    delete_disconnected_channel(splitter);
    return TRUE;
}
84201120:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
84201122:	d8 4c       	rts;

84201124 <$_splitter_destroy>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84201124:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201126:	10 09       	r6 = r0 + Null;
84201128:	1b 09       	r9 = r1 + Null;
8420112a:	22 09       	r8 = r2 + Null;
8420112c:	29 09       	r7 = r3 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
8420112e:	08 f0 39 e5 	call (m) $_base_op_get_instance_data;
84201132:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    timer_cancel_event_atomic(&splitter->self_kick_timer);
84201134:	37 31       	r5 = r4 + 36;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84201136:	ff fd 5d f1 	call (m) 0x2cc9c;
8420113a:	27 eb 
    if (*timer_id != TIMER_ID_INVALID)
8420113c:	3a e8       	r0 = M[r5 + Null];
8420113e:	07 60       	if EQ jump (m) Lc_splitter_destroy_3;

84201140 <Lc_splitter_destroy_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84201140:	04 00       	r2 = Null + Null;
84201142:	03 00       	r1 = Null + Null;
84201144:	ff fd 98 f0 	call (m) 0x141bc;
84201148:	39 e3 
        *timer_id = TIMER_ID_INVALID;
8420114a:	38 ee       	M[r5 + Null] = Null;

8420114c <Lc_splitter_destroy_3>:
    }
    interrupt_unblock();
8420114c:	ff fd 5d f1 	call (m) 0x2ccb8;
84201150:	2d eb 

    if (splitter->curr_connecting)
84201152:	32 98       	r0 = M[r4 + 32];
84201154:	04 60       	if EQ jump (m) Lc_splitter_destroy_5;

84201156 <Lc_splitter_destroy_4>:
    {
        /* Clear up the capability specific data. */
        /* A buffer may have been orphaned during a failed connect make sure it
         * gets freed. */
        cbuffer_destroy_struct(splitter->curr_connecting);
84201156:	ff fd 8b f0 	call (m) 0x12834;
8420115a:	3f e6 

8420115c <Lc_splitter_destroy_5>:
    }
#ifdef SPLITTER_EXT_BUFFER
    /* Check if SRAM need disabling. */
    if (splitter->location == SRAM)
8420115c:	71 81       	rMAC = MBS[r4 + 5];
8420115e:	48 24       	Null = rMAC - 1;
84201160:	08 62       	if NE jump (m) Lc_splitter_destroy_7;

84201162 <Lc_splitter_destroy_6>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_OFF, NULL, EXT_MEM_WAIT);
84201162:	15 f0 10 4b 	r3 = Null + 10000;
84201166:	04 00       	r2 = Null + Null;
84201168:	03 00       	r1 = Null + Null;
8420116a:	02 00       	r0 = Null + Null;
8420116c:	09 f0 35 e0 	call (m) $_extmem_enable_with_retry;

84201170 <Lc_splitter_destroy_7>:
    }
#endif

    return base_op_destroy(op_data, message_data, response_id, response_data);
84201170:	4d 08       	r3 = r7 + Null;
84201172:	54 08       	r2 = r8 + Null;
84201174:	5b 08       	r1 = r9 + Null;
84201176:	42 08       	r0 = r6 + Null;
84201178:	ef fd f7 ff 	call (m) 0xac;
8420117c:	35 e9 

8420117e <Lc_splitter_destroy_8>:
}
8420117e:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201180:	d8 4c       	rts;

84201182 <$_splitter_get_data_format>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84201182:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84201184:	17 00       	r5 = r0 + Null;
84201186:	20 09       	r6 = r2 + Null;
84201188:	2e 00       	r4 = r3 + Null;
8420118a:	08 f0 3d e2 	call (m) $_base_op_get_instance_data;
8420118e:	11 09       	r7 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    *response_id = OPCMD_DATA_FORMAT;
84201190:	01 22       	rMAC = Null + 8;
84201192:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    /* Set up the a default success response information */
    if (base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84201196:	03 00       	r1 = Null + Null;
84201198:	34 00       	r2 = r4 + Null;
8420119a:	3a 00       	r0 = r5 + Null;
8420119c:	08 f0 3f e0 	call (m) $_base_op_build_std_response_ex;
842011a0:	10 04       	Null = r0 - Null;
842011a2:	07 60       	if EQ jump (m) Lc_splitter_get_data_format_3;

842011a4 <Lc_splitter_get_data_format_2>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = splitter->data_format;
842011a4:	91 f0 03 88 	rMAC = M[r7 + 12];
842011a8:	32 e8       	r0 = M[r4 + Null];
842011aa:	91 8e       	M[r0 + 8] = rMAC;
        return TRUE;
842011ac:	42 20       	r0 = Null + 1;
842011ae:	02 6e       	jump (m) Lc_splitter_get_data_format_4;

842011b0 <Lc_splitter_get_data_format_3>:
    }
    else
    {
        return FALSE;
842011b0:	02 00       	r0 = Null + Null;

842011b2 <Lc_splitter_get_data_format_4>:
    }
}
842011b2:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842011b4:	d8 4c       	rts;

842011b6 <$_splitter_set_working_mode>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_working_mode(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011b6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842011b8:	17 00       	r5 = r0 + Null;
842011ba:	1e 00       	r4 = r1 + Null;
842011bc:	08 f0 2b e1 	call (m) $_base_op_get_instance_data;
842011c0:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_MODES working_mode;
    if (opmgr_op_is_running(op_data))
842011c2:	3a 00       	r0 = r5 + Null;
842011c4:	07 f0 33 ed 	call (m) $_opmgr_op_is_running;
842011c8:	10 04       	Null = r0 - Null;
842011ca:	08 60       	if EQ jump (m) Lc_splitter_set_working_mode_3;

842011cc <Lc_splitter_set_working_mode_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_working_mode: Cannot configure working mode while running!");
842011cc:	55 f1 02 f0 	r0 = Null + 357566307;
842011d0:	63 4b 
842011d2:	ef fd fb ff 	call (m) 0x9a2;
842011d6:	31 ee 
842011d8:	16 6e       	jump (m) Lc_splitter_set_working_mode_7;

842011da <Lc_splitter_set_working_mode_3>:
        return FALSE;
    }
    if  (splitter->channel_list != NULL)
842011da:	81 f0 00 e8 	rMAC = M[r6 + Null];
842011de:	08 60       	if EQ jump (m) Lc_splitter_set_working_mode_5;

842011e0 <Lc_splitter_set_working_mode_4>:
    {
        SPLITTER_ERRORMSG("splitter_set_working_mode: Cannot set working mode with connected terminals!");
842011e0:	55 f1 02 f0 	r0 = Null + 357566379;
842011e4:	ab 4b 
842011e6:	ef fd fb ff 	call (m) 0x9a2;
842011ea:	3d ed 
842011ec:	0c 6e       	jump (m) Lc_splitter_set_working_mode_7;

842011ee <Lc_splitter_set_working_mode_5>:
        return FALSE;
    }
    working_mode = (SPLITTER_MODES)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_WORKING_MODE, WORKING_MODE);
842011ee:	f1 88       	rMAC = M[r4 + 12];
842011f0:	89 c6       	rMAC = rMAC AND 0xffff;
842011f2:	0b 08       	r1 = SE8 rMAC;
    if  (working_mode >= NR_OF_MODES)
842011f4:	98 24       	Null = r1 - 2;
842011f6:	09 68       	if LT jump (m) Lc_splitter_set_working_mode_8;

842011f8 <Lc_splitter_set_working_mode_6>:
    {
        SPLITTER_ERRORMSG1("splitter_set_working_mode: %d is an unknonw working mode!", working_mode);
842011f8:	55 f1 02 f0 	r0 = Null + 357566456;
842011fc:	f8 4b 
842011fe:	ef fd fb ff 	call (m) 0x9b4;
84201202:	37 ed 

84201204 <Lc_splitter_set_working_mode_7>:
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_MODES working_mode;
    if (opmgr_op_is_running(op_data))
    {
        SPLITTER_ERRORMSG("splitter_set_working_mode: Cannot configure working mode while running!");
        return FALSE;
84201204:	02 00       	r0 = Null + Null;
84201206:	12 6e       	jump (m) Lc_splitter_set_working_mode_11;

84201208 <Lc_splitter_set_working_mode_8>:
    if  (working_mode >= NR_OF_MODES)
    {
        SPLITTER_ERRORMSG1("splitter_set_working_mode: %d is an unknonw working mode!", working_mode);
        return FALSE;
    }
    if(working_mode == BUFFER_DATA)
84201208:	58 24       	Null = r1 - 1;
8420120a:	0d 62       	if NE jump (m) Lc_splitter_set_working_mode_10;

8420120c <Lc_splitter_set_working_mode_9>:
    {
        /* Deactivate all output streams. */
        splitter->active_streams = OUT_STREAM__0_OFF__1_OFF;
8420120c:	81 f0 1a 82 	rMAC = MBU[r6 + 26];
84201210:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
        splitter->inactive_streams = OUT_STREAM__0_ON___1_ON;
84201214:	11 ff f3 1f 	rMAC = rMAC AND 0xfffffff3;
84201218:	06 f1 51 c8 	rMAC = rMAC OR 0xc;
        splitter->hold_streams = OUT_STREAM__0_OFF__1_OFF;
8420121c:	11 ff cf 1f 	rMAC = rMAC AND 0xffffffcf;
84201220:	81 f0 1a 8a 	MB[r6 + 26] = rMAC;

84201224 <Lc_splitter_set_working_mode_10>:
    }
    splitter->working_mode = working_mode;
84201224:	83 f0 04 8a 	MB[r6 + 4] = r1;
    SPLITTER_MSG1("splitter: Working mode set to %d (0 CLONE_BUFFER, 1 BUFFER_DATA)!",working_mode);
    return TRUE;
84201228:	42 20       	r0 = Null + 1;

8420122a <Lc_splitter_set_working_mode_11>:
}
8420122a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420122c:	d8 4c       	rts;

8420122e <$_splitter_set_location>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_location(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420122e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201230:	16 00       	r4 = r0 + Null;
84201232:	18 09       	r6 = r1 + Null;
84201234:	07 f0 33 ed 	call (m) $_base_op_get_instance_data;
84201238:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_BUFFER_LOCATION location;
    if (opmgr_op_is_running(op_data))
8420123a:	32 00       	r0 = r4 + Null;
8420123c:	07 f0 3b e9 	call (m) $_opmgr_op_is_running;
84201240:	10 04       	Null = r0 - Null;
84201242:	08 60       	if EQ jump (m) Lc_splitter_set_location_3;

84201244 <Lc_splitter_set_location_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_location: Cannot configure buffering location mode while running!");
84201244:	55 f1 02 f0 	r0 = Null + 357566514;
84201248:	32 50 
8420124a:	ef fd fb ff 	call (m) 0x9a2;
8420124e:	39 ea 
84201250:	18 6e       	jump (m) Lc_splitter_set_location_7;

84201252 <Lc_splitter_set_location_3>:
        return FALSE;
    }
    if (splitter->working_mode != BUFFER_DATA)
84201252:	39 81       	rMAC = MBS[r5 + 4];
84201254:	48 24       	Null = rMAC - 1;
84201256:	08 60       	if EQ jump (m) Lc_splitter_set_location_5;

84201258 <Lc_splitter_set_location_4>:
    {
        SPLITTER_ERRORMSG("splitter_set_location: Cannot set location when input buffer is cloned!");
84201258:	55 f1 02 f0 	r0 = Null + 357566593;
8420125c:	81 50 
8420125e:	ef fd fb ff 	call (m) 0x9a2;
84201262:	25 ea 
84201264:	0e 6e       	jump (m) Lc_splitter_set_location_7;

84201266 <Lc_splitter_set_location_5>:
        return FALSE;
    }
    location = (SPLITTER_BUFFER_LOCATION)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_LOCATION, LOCATION);
84201266:	81 f0 03 88 	rMAC = M[r6 + 12];
8420126a:	89 c6       	rMAC = rMAC AND 0xffff;
8420126c:	0e 08       	r4 = SE8 rMAC;
    if (location >= NR_OF_LOCATIONS)
8420126e:	b0 24       	Null = r4 - 2;
84201270:	0a 68       	if LT jump (m) Lc_splitter_set_location_8;

84201272 <Lc_splitter_set_location_6>:
    {
        SPLITTER_ERRORMSG1("splitter_set_location: %d is a unknown location for SPLITTER_BUFFER_LOCATION!", location);
84201272:	55 f1 02 f0 	r0 = Null + 357566665;
84201276:	c9 50 
84201278:	33 00       	r1 = r4 + Null;
8420127a:	ef fd fb ff 	call (m) 0x9b4;
8420127e:	3b e9 

84201280 <Lc_splitter_set_location_7>:
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_BUFFER_LOCATION location;
    if (opmgr_op_is_running(op_data))
    {
        SPLITTER_ERRORMSG("splitter_set_location: Cannot configure buffering location mode while running!");
        return FALSE;
84201280:	02 00       	r0 = Null + Null;
84201282:	1a 6e       	jump (m) Lc_splitter_set_location_15;

84201284 <Lc_splitter_set_location_8>:
        return FALSE;
    }

#ifdef SPLITTER_EXT_BUFFER
    /* Check if SRAM need enabling */
    if ((splitter->location == INTERNAL) && (location == SRAM))
84201284:	79 81       	rMAC = MBS[r5 + 5];
84201286:	0a 62       	if NE jump (m) Lc_splitter_set_location_11;

84201288 <Lc_splitter_set_location_9>:
84201288:	70 24       	Null = r4 - 1;
8420128a:	08 62       	if NE jump (m) Lc_splitter_set_location_11;

8420128c <Lc_splitter_set_location_10>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_ON, NULL, EXT_MEM_WAIT);
8420128c:	15 f0 10 4b 	r3 = Null + 10000;
84201290:	43 20       	r1 = Null + 1;
84201292:	04 00       	r2 = Null + Null;
84201294:	02 00       	r0 = Null + Null;
84201296:	08 f0 2b e7 	call (m) $_extmem_enable_with_retry;

8420129a <Lc_splitter_set_location_11>:
    }
    /* Check if SRAM need disabling. */
    if ((splitter->location == SRAM) && (location == INTERNAL))
8420129a:	79 81       	rMAC = MBS[r5 + 5];
8420129c:	48 24       	Null = rMAC - 1;
8420129e:	0a 62       	if NE jump (m) Lc_splitter_set_location_14;

842012a0 <Lc_splitter_set_location_12>:
842012a0:	30 04       	Null = r4 - Null;
842012a2:	08 62       	if NE jump (m) Lc_splitter_set_location_14;

842012a4 <Lc_splitter_set_location_13>:
    {
        extmem_enable_with_retry(EXTMEM_SPI_RAM, EXTMEM_OFF, NULL, EXT_MEM_WAIT);
842012a4:	15 f0 10 4b 	r3 = Null + 10000;
842012a8:	04 00       	r2 = Null + Null;
842012aa:	03 00       	r1 = Null + Null;
842012ac:	02 00       	r0 = Null + Null;
842012ae:	08 f0 33 e6 	call (m) $_extmem_enable_with_retry;

842012b2 <Lc_splitter_set_location_14>:
    }
#else
     PL_ASSERT(location == INTERNAL);
#endif

    splitter->location = location;
842012b2:	7e 8b       	MB[r5 + 5] = r4;
    SPLITTER_MSG1("splitter_set_location: Location set to %d (0 INTERNAL, 1 SRAM)!", location);
    return TRUE;
842012b4:	42 20       	r0 = Null + 1;

842012b6 <Lc_splitter_set_location_15>:
}
842012b6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842012b8:	d8 4c       	rts;

842012ba <$_splitter_set_packing>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_packing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012ba:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842012bc:	17 00       	r5 = r0 + Null;
842012be:	1e 00       	r4 = r1 + Null;
842012c0:	07 f0 27 e9 	call (m) $_base_op_get_instance_data;
842012c4:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_PACKING packing;
    if (opmgr_op_is_running(op_data))
842012c6:	3a 00       	r0 = r5 + Null;
842012c8:	07 f0 2f e5 	call (m) $_opmgr_op_is_running;
842012cc:	10 04       	Null = r0 - Null;
842012ce:	08 60       	if EQ jump (m) Lc_splitter_set_packing_3;

842012d0 <Lc_splitter_set_packing_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot configure working packing while running!");
842012d0:	55 f1 02 f0 	r0 = Null + 357566743;
842012d4:	17 51 
842012d6:	ef fd fb ff 	call (m) 0x9a2;
842012da:	2d e6 
842012dc:	17 6e       	jump (m) Lc_splitter_set_packing_7;

842012de <Lc_splitter_set_packing_3>:
        return FALSE;
    }
    if (splitter->working_mode != BUFFER_DATA)
842012de:	81 f0 04 80 	rMAC = MBS[r6 + 4];
842012e2:	48 24       	Null = rMAC - 1;
842012e4:	08 60       	if EQ jump (m) Lc_splitter_set_packing_5;

842012e6 <Lc_splitter_set_packing_4>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot set packing when input buffer is cloned!");
842012e6:	55 f1 02 f0 	r0 = Null + 357566813;
842012ea:	5d 51 
842012ec:	ef fd fb ff 	call (m) 0x9a2;
842012f0:	37 e5 
842012f2:	0c 6e       	jump (m) Lc_splitter_set_packing_7;

842012f4 <Lc_splitter_set_packing_5>:
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot set packing when data format is different than audio and DATAFORMAT_32 is defined!");
        return FALSE;
    }
#endif
    packing = (SPLITTER_MODES)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_PACKING, PACKING);
842012f4:	f1 88       	rMAC = M[r4 + 12];
842012f6:	89 c6       	rMAC = rMAC AND 0xffff;
842012f8:	0b 08       	r1 = SE8 rMAC;
    if (packing >= NR_OF_PACKING)
842012fa:	98 24       	Null = r1 - 2;
842012fc:	09 68       	if LT jump (m) Lc_splitter_set_packing_8;

842012fe <Lc_splitter_set_packing_6>:
    {
        SPLITTER_ERRORMSG1("splitter_set_packing: %d is an invalid packing!", packing);
842012fe:	55 f1 02 f0 	r0 = Null + 357566883;
84201302:	a3 51 
84201304:	ef fd fb ff 	call (m) 0x9b4;
84201308:	31 e5 

8420130a <Lc_splitter_set_packing_7>:
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    SPLITTER_PACKING packing;
    if (opmgr_op_is_running(op_data))
    {
        SPLITTER_ERRORMSG("splitter_set_packing: Cannot configure working packing while running!");
        return FALSE;
8420130a:	02 00       	r0 = Null + Null;
8420130c:	04 6e       	jump (m) Lc_splitter_set_packing_9;

8420130e <Lc_splitter_set_packing_8>:
    {
        SPLITTER_ERRORMSG1("splitter_set_packing: %d is an invalid packing!", packing);
        return FALSE;
    }

    splitter->packing = packing;
8420130e:	83 f0 06 8a 	MB[r6 + 6] = r1;
    SPLITTER_MSG1("splitter_set_packing: Packing set to %d (0 UNPACKED, 1 PACKED)!", packing);
    return TRUE;
84201312:	42 20       	r0 = Null + 1;

84201314 <Lc_splitter_set_packing_9>:
}
84201314:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201316:	d8 4c       	rts;

84201318 <$_splitter_set_buffer_size>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201318:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420131a:	16 00       	r4 = r0 + Null;
8420131c:	18 09       	r6 = r1 + Null;
8420131e:	07 f0 29 e6 	call (m) $_base_op_get_instance_data;
84201322:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned buffer_size;
    if (opmgr_op_is_running(op_data))
84201324:	32 00       	r0 = r4 + Null;
84201326:	07 f0 31 e2 	call (m) $_opmgr_op_is_running;
8420132a:	10 04       	Null = r0 - Null;
8420132c:	08 60       	if EQ jump (m) Lc_splitter_set_buffer_size_3;

8420132e <Lc_splitter_set_buffer_size_2>:
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Operator running!");
8420132e:	55 f1 02 f0 	r0 = Null + 357566039;
84201332:	57 4a 
84201334:	ef fd fb ff 	call (m) 0x9a2;
84201338:	2f e3 
8420133a:	09 6e       	jump (m) Lc_splitter_set_buffer_size_5;

8420133c <Lc_splitter_set_buffer_size_3>:
        return FALSE;
    }
    /* Channels are created on demand so if there is any the operaor is connected. */
    if  (splitter->channel_list != NULL)
8420133c:	39 e8       	rMAC = M[r5 + Null];
8420133e:	09 60       	if EQ jump (m) Lc_splitter_set_buffer_size_6;

84201340 <Lc_splitter_set_buffer_size_4>:
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Cannot set the buffer size for an operator with connected terminals!");
84201340:	55 f1 02 f0 	r0 = Null + 357566083;
84201344:	83 4a 
84201346:	ef fd fb ff 	call (m) 0x9a2;
8420134a:	3d e2 

8420134c <Lc_splitter_set_buffer_size_5>:
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned buffer_size;
    if (opmgr_op_is_running(op_data))
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Operator running!");
        return FALSE;
8420134c:	02 00       	r0 = Null + Null;
8420134e:	12 6e       	jump (m) Lc_splitter_set_buffer_size_9;

84201350 <Lc_splitter_set_buffer_size_6>:
    if  (splitter->channel_list != NULL)
    {
        SPLITTER_ERRORMSG("splitter_set_buffer_size: Cannot set the buffer size for an operator with connected terminals!");
        return FALSE;
    }
    buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
84201350:	81 f0 03 88 	rMAC = M[r6 + 12];
84201354:	8e c6       	r4 = rMAC AND 0xffff;
    if (buffer_size < SPLITTER_MIN_INTERNAL_BUFFER_SIZE)
84201356:	60 f0 00 2c 	Null = r4 - 1024;
8420135a:	02 f0 95 e0 	if C jump (m) Lc_splitter_set_buffer_size_8;

8420135e <Lc_splitter_set_buffer_size_7>:
    {
        SPLITTER_ERRORMSG1("splitter_set_buffer_size: Buffer size too small! "
                "Please use an internal buffer size of at least %d words to increase efficiency.",
                SPLITTER_MIN_INTERNAL_BUFFER_SIZE);
8420135e:	03 f0 00 48 	r1 = Null + 1024;
84201362:	55 f1 02 f0 	r0 = Null + 357566178;
84201366:	e2 4a 
84201368:	ef fd fb ff 	call (m) 0x9b4;
8420136c:	2d e2 

8420136e <Lc_splitter_set_buffer_size_8>:
        /* This could be a valid settings in some cases so continue with no errors.*/
    }
    splitter->buffer_size = buffer_size;
8420136e:	be 8e       	M[r5 + 8] = r4;
    SPLITTER_MSG1("splitter_set_buffer_size: Internal buffer size set to %d words!", splitter->buffer_size);
    return TRUE;
84201370:	42 20       	r0 = Null + 1;

84201372 <Lc_splitter_set_buffer_size_9>:
}
84201372:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201374:	d8 4c       	rts;

84201376 <$_splitter_set_data_format>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201376:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201378:	17 00       	r5 = r0 + Null;
8420137a:	1e 00       	r4 = r1 + Null;
8420137c:	07 f0 2b e3 	call (m) $_base_op_get_instance_data;
84201380:	10 09       	r6 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    AUDIO_DATA_FORMAT data_format;

    if (opmgr_op_is_running(op_data))
84201382:	3a 00       	r0 = r5 + Null;
84201384:	06 f0 33 ef 	call (m) $_opmgr_op_is_running;
84201388:	10 04       	Null = r0 - Null;
8420138a:	09 60       	if EQ jump (m) Lc_splitter_set_data_format_3;

8420138c <Lc_splitter_set_data_format_2>:
    {
        SPLITTER_ERRORMSG("splitter: Cannot set data format while running!");
8420138c:	55 f1 02 f0 	r0 = Null + 357566931;
84201390:	d3 51 
84201392:	ef fd fb ff 	call (m) 0x9a2;
84201396:	31 e0 
        return FALSE;
84201398:	02 00       	r0 = Null + Null;
8420139a:	21 6e       	jump (m) Lc_splitter_set_data_format_8;

8420139c <Lc_splitter_set_data_format_3>:
    }
    data_format = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_DATA_FORMAT, DATA_TYPE);
8420139c:	f1 88       	rMAC = M[r4 + 12];
8420139e:	8e c6       	r4 = rMAC AND 0xffff;

    /* Always activate tag reframing when the data format is audio.*/
    if ((data_format == AUDIO_DATA_FORMAT_FIXP) || (data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA))
842013a0:	70 24       	Null = r4 - 1;
842013a2:	03 60       	if EQ jump (m) Lc_splitter_set_data_format_5;

842013a4 <Lc_splitter_set_data_format_4>:
842013a4:	f0 24       	Null = r4 - 3;
842013a6:	09 62       	if NE jump (m) Lc_splitter_set_data_format_6;

842013a8 <Lc_splitter_set_data_format_5>:
    {
        splitter->tag_size_to_samples = TRUE;
842013a8:	81 f0 68 82 	rMAC = MBU[r6 + 104];
842013ac:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
842013b0:	c9 c8       	rMAC = rMAC OR 0x4;
842013b2:	81 f0 68 8a 	MB[r6 + 104] = rMAC;
842013b6:	0d 6e       	jump (m) Lc_splitter_set_data_format_7;

842013b8 <Lc_splitter_set_data_format_6>:
    }
    else
    {
        splitter->tag_size_to_samples = FALSE;
842013b8:	81 f0 68 82 	rMAC = MBU[r6 + 104];
842013bc:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
842013c0:	81 f0 68 8a 	MB[r6 + 104] = rMAC;
#ifndef DATAFORMAT_32
        SPLITTER_ERRORMSG("splitter_set_data_format: Data will be packed if DATAFORMAT_32 is not defined!");
842013c4:	55 f1 02 f0 	r0 = Null + 357566979;
842013c8:	03 52 
842013ca:	ef fd fa ff 	call (m) 0x9a2;
842013ce:	39 ee 

842013d0 <Lc_splitter_set_data_format_7>:
#endif
    }

    splitter->data_format = data_format;
842013d0:	86 f0 03 8e 	M[r6 + 12] = r4;
    set_cbuffer_functions(splitter);
842013d4:	42 08       	r0 = r6 + Null;
842013d6:	04 f0 2b ef 	call (m) $_set_cbuffer_functions;
    SPLITTER_MSG1("splitter: Data format set to %d!", splitter->data_format);
    return TRUE;
842013da:	42 20       	r0 = Null + 1;

842013dc <Lc_splitter_set_data_format_8>:
}
842013dc:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842013de:	d8 4c       	rts;

842013e0 <$_splitter_set_running_streams>:
 * response
 */
bool splitter_set_running_streams(OPERATOR_DATA *op_data, void *message_data,
                                  unsigned *resp_length,
                                  OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842013e0:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842013e2:	10 09       	r6 = r0 + Null;
842013e4:	1f 00       	r5 = r1 + Null;
842013e6:	07 f0 21 e0 	call (m) $_base_op_get_instance_data;
842013ea:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_RUNNING_STREAMS, RUNNING_STREAMS);
842013ec:	f9 88       	rMAC = M[r5 + 12];
842013ee:	8f c6       	r5 = rMAC AND 0xffff;
/**
 * Checks if the bitfield received is within range.
 */
static inline bool invalid_stream_setting(unsigned stream_bitfield)
{
    return (stream_bitfield > (OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1));
842013f0:	01 00       	rMAC = Null + Null;
842013f2:	f8 24       	Null = r5 - 3;
842013f4:	28 f0 41 ce 	if HI rMAC = Null + 1;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_set_running_streams",base_op_get_ext_op_id(op_data));

    if (invalid_stream_setting(bitfield))
842013f8:	08 04       	Null = rMAC - Null;
842013fa:	1e 62       	if NE jump (m) Lc_splitter_set_running_streams_8;

842013fc <Lc_splitter_set_running_streams_2>:
    {
        return FALSE;
    }


    if (splitter->working_mode == CLONE_BUFFER)
842013fc:	31 81       	rMAC = MBS[r4 + 4];
842013fe:	09 62       	if NE jump (m) Lc_splitter_set_running_streams_5;

84201400 <Lc_splitter_set_running_streams_3>:
        unsigned    cur_channel, new_channel;
        SPLITTER_CHANNEL_STRUC *channel;
        /* Before setting the stream active make all the channels buffer pointers
         * look empty like it's just been connected, BUT aligned with the write
         * pointer of the other stream so that there is no chance of stalls. */
        if ((splitter->active_streams ^ bitfield) == OPMSG_SPLITTER_STREAM_1)
84201400:	b1 b2       	rMAC = MBU[r4 + 26];
84201402:	89 c0       	rMAC = rMAC AND 0x3;
84201404:	c9 15       	rMAC = rMAC XOR r5;
84201406:	88 24       	Null = rMAC - 2;
84201408:	19 62       	if NE jump (m) Lc_splitter_set_running_streams_9;

8420140a <Lc_splitter_set_running_streams_4>:
        {
            new_channel = 1;
8420140a:	0a 71       	r8 = Null + 1;
            cur_channel = 0;
8420140c:	01 09       	r7 = Null + Null;
8420140e:	18 6e       	jump (m) Lc_splitter_set_running_streams_10;

84201410 <Lc_splitter_set_running_streams_5>:
        return TRUE;
    }
    else
    {
        SPLITTER_STREAMS streams;
        if (!validate_input_and_splitter_state(splitter, bitfield))
84201410:	3b 00       	r1 = r5 + Null;
84201412:	01 f0 31 ed 	call (m) Lc_validate_input_and_splitter_state_1;
84201416:	10 04       	Null = r0 - Null;
84201418:	0f 60       	if EQ jump (m) Lc_splitter_set_running_streams_8;

8420141a <Lc_splitter_set_running_streams_6>:
        {
            return FALSE;
        }
        streams = (SPLITTER_STREAMS)bitfield;
8420141a:	3f 08       	r5 = SE8 r5;
        if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
8420141c:	b2 b2       	r0 = MBU[r4 + 26];
8420141e:	d3 50       	r1 = r0 LSHIFT -4;
84201420:	9d c0       	r3 = r1 AND 0x3;
84201422:	4f 60       	if EQ jump (m) Lc_splitter_set_running_streams_19;

84201424 <Lc_splitter_set_running_streams_7>:
        {
            SPLITTER_ERRORMSG3("splitter_set_running_streams: Streams on hold! cannot use this command."
                    "\n Active %d\n Inactive %d\n Hold %d",
                    splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
84201424:	53 50       	r1 = r0 LSHIFT -2;
84201426:	9c c0       	r2 = r1 AND 0x3;
84201428:	93 c0       	r1 = r0 AND 0x3;
8420142a:	55 f1 02 f0 	r0 = Null + 357567058;
8420142e:	52 52 
84201430:	ef fd fa ff 	call (m) 0x9de;
84201434:	2f ed 

84201436 <Lc_splitter_set_running_streams_8>:

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_set_running_streams",base_op_get_ext_op_id(op_data));

    if (invalid_stream_setting(bitfield))
    {
        return FALSE;
84201436:	02 00       	r0 = Null + Null;
84201438:	5f 6e       	jump (m) Lc_splitter_set_running_streams_22;

8420143a <Lc_splitter_set_running_streams_9>:
            new_channel = 1;
            cur_channel = 0;
        }
        else
        {
            new_channel = 0;
8420143a:	02 09       	r8 = Null + Null;
            cur_channel = 1;
8420143c:	09 71       	r7 = Null + 1;

8420143e <Lc_splitter_set_running_streams_10>:

        /* Prevent processing while the read and write ptrs for the stream that is
         * coming online is aligned to the current write pointer of the running
         * stream.
         */
        opmgr_op_suspend_processing(op_data);
8420143e:	42 08       	r0 = r6 + Null;
84201440:	06 f0 23 ea 	call (m) $_opmgr_op_suspend_processing;
        channel = splitter->channel_list;
84201444:	31 e8       	rMAC = M[r4 + Null];

        /* Align the buffers if the output goes active. */
        if ((bitfield & (1<<new_channel)) != 0)
84201446:	52 08       	r0 = r8 + Null;
84201448:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
8420144c:	d2 11       	r0 = r0 AND r5;
8420144e:	23 60       	if EQ jump (m) Lc_splitter_set_running_streams_17;

84201450 <Lc_splitter_set_running_streams_11>:
84201450:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84201454:	14 23       	r2 = r0 + 12;
84201456:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420145a:	15 23       	r3 = r0 + 12;

8420145c <Lc_splitter_set_running_streams_12>:
        {
            while (channel)
8420145c:	08 04       	Null = rMAC - Null;
8420145e:	16 60       	if EQ jump (m) Lc_splitter_set_running_streams_16;

84201460 <Lc_splitter_set_running_streams_13>:
            {
                tCbuffer *new_out_buffer = channel->output_buffer[new_channel];
                if (new_out_buffer != NULL)
84201460:	0a e9       	r0 = M[rMAC + r2];
84201462:	12 60       	if EQ jump (m) Lc_splitter_set_running_streams_15;

84201464 <Lc_splitter_set_running_streams_14>:
                {
                    tCbuffer *cur_out_buffer = channel->output_buffer[cur_channel];
84201464:	4b e9       	r1 = M[rMAC + r3];
                    new_out_buffer->read_ptr = cur_out_buffer->write_ptr;
84201466:	39 f0 02 88 	r7 = M[r1 + 8];
8420146a:	29 f0 01 8e 	M[r0 + 4] = r7;
                    new_out_buffer->write_ptr = cur_out_buffer->write_ptr;
8420146e:	39 f0 02 88 	r7 = M[r1 + 8];
84201472:	29 f0 02 8e 	M[r0 + 8] = r7;
                        /* Set both metadata read/write indices on the new stream
                         * to match the write index for the running stream.
                         * This ensures that new tags have the same indices on both
                         * streams.
                         */
                        metadata_list *new_metadata = new_out_buffer->metadata;
84201476:	92 89       	r0 = M[r0 + 24];
                        metadata_list *cur_metadata = cur_out_buffer->metadata;
84201478:	9b 89       	r1 = M[r1 + 24];
                        new_metadata->prev_wr_index = cur_metadata->prev_wr_index;
8420147a:	39 f0 02 88 	r7 = M[r1 + 8];
8420147e:	29 f0 02 8e 	M[r0 + 8] = r7;
                        new_metadata->prev_rd_index = cur_metadata->prev_wr_index;
84201482:	9b 88       	r1 = M[r1 + 8];
84201484:	d3 8e       	M[r0 + 12] = r1;

84201486 <Lc_splitter_set_running_streams_15>:
                    }
#endif /* INSTALL_METADATA */
                }
                channel = channel->next;
84201486:	09 e8       	rMAC = M[rMAC + Null];
        channel = splitter->channel_list;

        /* Align the buffers if the output goes active. */
        if ((bitfield & (1<<new_channel)) != 0)
        {
            while (channel)
84201488:	ea 6f       	jump (m) Lc_splitter_set_running_streams_12;

8420148a <Lc_splitter_set_running_streams_16>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
8420148a:	42 20       	r0 = Null + 1;
8420148c:	31 00       	rMAC = r4 + Null;
8420148e:	51 0c       	rMAC = r8 + rMAC;
84201490:	0a ba       	MB[rMAC + 24] = r0;
84201492:	04 6e       	jump (m) Lc_splitter_set_running_streams_18;

84201494 <Lc_splitter_set_running_streams_17>:
84201494:	31 00       	rMAC = r4 + Null;
84201496:	51 0c       	rMAC = r8 + rMAC;
84201498:	08 ba       	MB[rMAC + 24] = Null;

8420149a <Lc_splitter_set_running_streams_18>:
        else
        {
            /* Just inactivate the output channel. */
            set_current_output_state(splitter, new_channel, INACTIVE);
        }
        opmgr_op_resume_processing(op_data);
8420149a:	42 08       	r0 = r6 + Null;
8420149c:	06 f0 33 e7 	call (m) $_opmgr_op_resume_processing;
        splitter->active_streams = (SPLITTER_STREAMS)bitfield;
842014a0:	b1 b2       	rMAC = MBU[r4 + 26];
842014a2:	ba c0       	r0 = r5 AND 0x3;
842014a4:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
842014a8:	89 12       	rMAC = rMAC OR r0;
        splitter->inactive_streams = ~(SPLITTER_STREAMS)bitfield;
842014aa:	11 ff f3 1f 	rMAC = rMAC AND 0xfffffff3;
842014ae:	3a 08       	r0 = SE8 r5;
842014b0:	ff f2 52 d6 	r0 = -1 - r0;
842014b4:	92 c0       	r0 = r0 AND 0x3;
842014b6:	52 54       	r0 = r0 LSHIFT 2;
842014b8:	89 12       	rMAC = rMAC OR r0;
842014ba:	b1 ba       	MB[r4 + 26] = rMAC;

        return TRUE;
842014bc:	42 20       	r0 = Null + 1;
842014be:	1c 6e       	jump (m) Lc_splitter_set_running_streams_22;

842014c0 <Lc_splitter_set_running_streams_19>:
                    "\n Active %d\n Inactive %d\n Hold %d",
                    splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
            return FALSE;
        }
        /* Check if all output terminals are connected. */
        if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
842014c0:	42 08       	r0 = r6 + Null;
842014c2:	06 f0 35 e5 	call (m) $_opmgr_op_is_running;
842014c6:	10 04       	Null = r0 - Null;
842014c8:	07 60       	if EQ jump (m) Lc_splitter_set_running_streams_21;

842014ca <Lc_splitter_set_running_streams_20>:
842014ca:	3b 00       	r1 = r5 + Null;
842014cc:	32 00       	r0 = r4 + Null;
842014ce:	01 f0 31 ec 	call (m) Lc_splitter_output_stream_connected_1;
842014d2:	10 04       	Null = r0 - Null;
842014d4:	b1 61       	if EQ jump (m) Lc_splitter_set_running_streams_8;

842014d6 <Lc_splitter_set_running_streams_21>:
        {
            return FALSE;
        }
        /* Change the three main stream. */
        splitter->active_streams = streams;
842014d6:	b1 b2       	rMAC = MBU[r4 + 26];
842014d8:	ba c0       	r0 = r5 AND 0x3;
842014da:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
842014de:	89 12       	rMAC = rMAC OR r0;
        splitter->inactive_streams = ~streams;
842014e0:	11 ff f3 1f 	rMAC = rMAC AND 0xfffffff3;
842014e4:	ff f7 52 d6 	r0 = -1 - r5;
842014e8:	92 c0       	r0 = r0 AND 0x3;
842014ea:	52 54       	r0 = r0 LSHIFT 2;
842014ec:	89 12       	rMAC = rMAC OR r0;
842014ee:	b1 ba       	MB[r4 + 26] = rMAC;

        /* verify the new state validity. */
        return validate_new_splitter_state(op_data);
842014f0:	42 08       	r0 = r6 + Null;
842014f2:	01 f0 3d e8 	call (m) Lc_validate_new_splitter_state_1;

842014f6 <Lc_splitter_set_running_streams_22>:
    }
}
842014f6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842014f8:	d8 4c       	rts;

842014fa <$_splitter_activate_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_activate_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842014fa:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842014fc:	10 09       	r6 = r0 + Null;
842014fe:	1f 00       	r5 = r1 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201500:	06 f0 27 e7 	call (m) $_base_op_get_instance_data;
84201504:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams",base_op_get_ext_op_id(op_data));
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS, STREAMS);
84201506:	f9 88       	rMAC = M[r5 + 12];
84201508:	8f c6       	r5 = rMAC AND 0xffff;

    if (!validate_input_and_splitter_state(splitter, bitfield))
8420150a:	3b 00       	r1 = r5 + Null;
8420150c:	01 f0 37 e5 	call (m) Lc_validate_input_and_splitter_state_1;
84201510:	10 04       	Null = r0 - Null;
84201512:	11 60       	if EQ jump (m) Lc_splitter_activate_streams_4;

84201514 <Lc_splitter_activate_streams_2>:
    {
        return FALSE;
    }
    streams = (SPLITTER_STREAMS)bitfield;
84201514:	3f 08       	r5 = SE8 r5;
    if ((splitter->inactive_streams & streams) != streams)
84201516:	b2 b2       	r0 = MBU[r4 + 26];
84201518:	53 50       	r1 = r0 LSHIFT -2;
8420151a:	9c c0       	r2 = r1 AND 0x3;
8420151c:	39 11       	rMAC = r5 AND r2;
8420151e:	c8 05       	Null = rMAC - r5;
84201520:	0c 60       	if EQ jump (m) Lc_splitter_activate_streams_5;

84201522 <Lc_splitter_activate_streams_3>:
    {
        SPLITTER_ERRORMSG3("splitter_activate_streams: Only inactive streams can be activated."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
84201522:	d3 50       	r1 = r0 LSHIFT -4;
84201524:	9d c0       	r3 = r1 AND 0x3;
84201526:	93 c0       	r1 = r0 AND 0x3;
84201528:	55 f1 02 f0 	r0 = Null + 357567163;
8420152c:	bb 52 
8420152e:	ef fd fa ff 	call (m) 0x9de;
84201532:	31 e5 

84201534 <Lc_splitter_activate_streams_4>:
    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams",base_op_get_ext_op_id(op_data));
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS, STREAMS);

    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
84201534:	02 00       	r0 = Null + Null;
84201536:	20 6e       	jump (m) Lc_splitter_activate_streams_8;

84201538 <Lc_splitter_activate_streams_5>:
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
        return FALSE;
    }

    /* Check if all output terminals are connected. */
    if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
84201538:	42 08       	r0 = r6 + Null;
8420153a:	06 f0 3d e1 	call (m) $_opmgr_op_is_running;
8420153e:	10 04       	Null = r0 - Null;
84201540:	07 60       	if EQ jump (m) Lc_splitter_activate_streams_7;

84201542 <Lc_splitter_activate_streams_6>:
84201542:	3b 00       	r1 = r5 + Null;
84201544:	32 00       	r0 = r4 + Null;
84201546:	01 f0 39 e8 	call (m) Lc_splitter_output_stream_connected_1;
8420154a:	10 04       	Null = r0 - Null;
8420154c:	f4 61       	if EQ jump (m) Lc_splitter_activate_streams_4;

8420154e <Lc_splitter_activate_streams_7>:
    {
        return FALSE;
    }
    /* Activate streams. */
    splitter->active_streams = splitter->active_streams | streams;
8420154e:	b1 b2       	rMAC = MBU[r4 + 26];
84201550:	8a c0       	r0 = rMAC AND 0x3;
84201552:	d2 13       	r0 = r0 OR r5;
84201554:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
84201558:	92 c0       	r0 = r0 AND 0x3;
8420155a:	52 12       	r0 = r0 OR rMAC;
    /* Update the inactive output streams to reflect the changes. */
    splitter->inactive_streams = splitter->inactive_streams & ~streams;
8420155c:	21 ff f3 1f 	rMAC = r0 AND 0xfffffff3;
84201560:	ff f7 53 d6 	r1 = -1 - r5;
84201564:	52 50       	r0 = r0 LSHIFT -2;
84201566:	d2 10       	r0 = r0 AND r1;
84201568:	92 c0       	r0 = r0 AND 0x3;
8420156a:	52 54       	r0 = r0 LSHIFT 2;
8420156c:	89 12       	rMAC = rMAC OR r0;
8420156e:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    return validate_new_splitter_state(op_data);
84201570:	42 08       	r0 = r6 + Null;
84201572:	01 f0 3d e4 	call (m) Lc_validate_new_splitter_state_1;

84201576 <Lc_splitter_activate_streams_8>:
}
84201576:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201578:	d8 4c       	rts;

8420157a <$_splitter_activate_streams_after_timestamp>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_activate_streams_after_timestamp(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420157a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420157c:	10 09       	r6 = r0 + Null;
8420157e:	1f 00       	r5 = r1 + Null;
84201580:	06 f0 27 e3 	call (m) $_base_op_get_instance_data;
84201584:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, STREAMS);
84201586:	f9 88       	rMAC = M[r5 + 12];
84201588:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;
    splitter->transition_point = (TIME_INTERVAL)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_LS) +
                                 ((TIME_INTERVAL)OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_ACTIVATE_STREAMS_AFTER_TIMESTAMP, TIMESTAMP_MS) << 16);
8420158c:	39 89       	rMAC = M[r5 + 16];
8420158e:	8a c6       	r0 = rMAC AND 0xffff;
84201590:	92 56       	r0 = r0 LSHIFT 16;
84201592:	79 89       	rMAC = M[r5 + 20];
84201594:	89 c6       	rMAC = rMAC AND 0xffff;
84201596:	51 00       	rMAC = r0 + rMAC;
84201598:	b1 9e       	M[r4 + 40] = rMAC;


    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams_after_timestamp",base_op_get_ext_op_id(op_data));
    if (!validate_input_and_splitter_state(splitter, bitfield))
8420159a:	4b 08       	r1 = r7 + Null;
8420159c:	32 00       	r0 = r4 + Null;
8420159e:	01 f0 25 e1 	call (m) Lc_validate_input_and_splitter_state_1;
842015a2:	10 04       	Null = r0 - Null;
842015a4:	12 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_4;

842015a6 <Lc_splitter_activate_streams_after_timestamp_2>:
    {
        return FALSE;
    }

    streams = (SPLITTER_STREAMS)bitfield;
842015a6:	ef f9 47 ce 	r5 = SE8 r7;
    if ((splitter->hold_streams & streams) != streams)
842015aa:	b2 b2       	r0 = MBU[r4 + 26];
842015ac:	d3 50       	r1 = r0 LSHIFT -4;
842015ae:	9d c0       	r3 = r1 AND 0x3;
842015b0:	79 11       	rMAC = r5 AND r3;
842015b2:	c8 05       	Null = rMAC - r5;
842015b4:	0c 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_5;

842015b6 <Lc_splitter_activate_streams_after_timestamp_3>:
    {
        SPLITTER_ERRORMSG3("splitter_activate_streams_after_timestamp: Only streams on hold (streams buffered) can be activated."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
842015b6:	53 50       	r1 = r0 LSHIFT -2;
842015b8:	9c c0       	r2 = r1 AND 0x3;
842015ba:	93 c0       	r1 = r0 AND 0x3;
842015bc:	55 f1 02 f0 	r0 = Null + 357567263;
842015c0:	1f 53 
842015c2:	ef fd fa ff 	call (m) 0x9de;
842015c6:	3d e0 

842015c8 <Lc_splitter_activate_streams_after_timestamp_4>:


    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_activate_streams_after_timestamp",base_op_get_ext_op_id(op_data));
    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
842015c8:	02 00       	r0 = Null + Null;
842015ca:	20 6e       	jump (m) Lc_splitter_activate_streams_after_timestamp_8;

842015cc <Lc_splitter_activate_streams_after_timestamp_5>:
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
        return FALSE;
    }

    /* Check if all output terminals are connected. */
    if (opmgr_op_is_running(op_data) && !splitter_output_stream_connected(splitter, streams))
842015cc:	42 08       	r0 = r6 + Null;
842015ce:	05 f0 29 ed 	call (m) $_opmgr_op_is_running;
842015d2:	10 04       	Null = r0 - Null;
842015d4:	07 60       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_7;

842015d6 <Lc_splitter_activate_streams_after_timestamp_6>:
842015d6:	3b 00       	r1 = r5 + Null;
842015d8:	32 00       	r0 = r4 + Null;
842015da:	01 f0 25 e4 	call (m) Lc_splitter_output_stream_connected_1;
842015de:	10 04       	Null = r0 - Null;
842015e0:	f4 61       	if EQ jump (m) Lc_splitter_activate_streams_after_timestamp_4;

842015e2 <Lc_splitter_activate_streams_after_timestamp_7>:
    {
        return FALSE;
    }
    /* Activate streams after timestamp. */
    splitter->active_streams = splitter->active_streams | streams;
842015e2:	b1 b2       	rMAC = MBU[r4 + 26];
842015e4:	8a c0       	r0 = rMAC AND 0x3;
842015e6:	d2 13       	r0 = r0 OR r5;
842015e8:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
842015ec:	92 c0       	r0 = r0 AND 0x3;
842015ee:	52 12       	r0 = r0 OR rMAC;
    /* Update the hold output streams to reflect the changes. */
    splitter->hold_streams = splitter->hold_streams & ~streams;
842015f0:	21 ff cf 1f 	rMAC = r0 AND 0xffffffcf;
842015f4:	ff f7 53 d6 	r1 = -1 - r5;
842015f8:	d2 50       	r0 = r0 LSHIFT -4;
842015fa:	d2 10       	r0 = r0 AND r1;
842015fc:	92 c0       	r0 = r0 AND 0x3;
842015fe:	d2 54       	r0 = r0 LSHIFT 4;
84201600:	89 12       	rMAC = rMAC OR r0;
84201602:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    return validate_new_splitter_state(op_data);
84201604:	42 08       	r0 = r6 + Null;
84201606:	01 f0 29 e0 	call (m) Lc_validate_new_splitter_state_1;

8420160a <Lc_splitter_activate_streams_after_timestamp_8>:
}
8420160a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420160c:	d8 4c       	rts;

8420160e <$_splitter_deactivate_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_deactivate_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420160e:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201610:	10 09       	r6 = r0 + Null;
84201612:	1f 00       	r5 = r1 + Null;
84201614:	05 f0 33 ee 	call (m) $_base_op_get_instance_data;
84201618:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_DEACTIVATE_STREAMS, STREAMS);
8420161a:	f9 88       	rMAC = M[r5 + 12];
8420161c:	8b c6       	r1 = rMAC AND 0xffff;


    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_deactivate_streams",base_op_get_ext_op_id(op_data));
    streams = (SPLITTER_STREAMS)bitfield;
8420161e:	1f 08       	r5 = SE8 r1;
    if (splitter->inactive_streams == streams)
84201620:	b2 b2       	r0 = MBU[r4 + 26];
84201622:	54 50       	r2 = r0 LSHIFT -2;
84201624:	a1 c0       	rMAC = r2 AND 0x3;
84201626:	c8 05       	Null = rMAC - r5;
84201628:	30 60       	if EQ jump (m) Lc_splitter_deactivate_streams_9;

8420162a <Lc_splitter_deactivate_streams_2>:
    {
        /* No need to do anything. */
        return TRUE;
    }
    /* Exit from transition if switching to active did not finish. */
    if (splitter->in_transition)
8420162a:	f0 89       	Null = M[r4 + 28];
8420162c:	06 60       	if EQ jump (m) Lc_splitter_deactivate_streams_5;

8420162e <Lc_splitter_deactivate_streams_3>:
    {
        if ((splitter->active_streams & streams) == streams)
8420162e:	d1 11       	rMAC = r0 AND r5;
84201630:	89 c0       	rMAC = rMAC AND 0x3;
84201632:	c8 05       	Null = rMAC - r5;
84201634:	2c 62       	if NE jump (m) Lc_splitter_deactivate_streams_10;

84201636 <Lc_splitter_deactivate_streams_4>:
        {
            splitter->in_transition = FALSE;
84201636:	f0 8f       	M[r4 + 28] = Null;

84201638 <Lc_splitter_deactivate_streams_5>:
        {
            /* Other transitions should be instant. */
            return FALSE;
        }
    }
    if (!validate_input_and_splitter_state(splitter, bitfield))
84201638:	32 00       	r0 = r4 + Null;
8420163a:	c4 4e       	call (m) Lc_validate_input_and_splitter_state_1;
8420163c:	10 04       	Null = r0 - Null;
8420163e:	27 60       	if EQ jump (m) Lc_splitter_deactivate_streams_10;

84201640 <Lc_splitter_deactivate_streams_6>:
    {
        return FALSE;
    }
    /* Deactivate streams. */
    splitter->inactive_streams = splitter->inactive_streams | streams;
84201640:	b2 b2       	r0 = MBU[r4 + 26];
84201642:	21 ff f3 1f 	rMAC = r0 AND 0xfffffff3;
84201646:	52 50       	r0 = r0 LSHIFT -2;
84201648:	92 c0       	r0 = r0 AND 0x3;
8420164a:	d2 13       	r0 = r0 OR r5;
8420164c:	92 c0       	r0 = r0 AND 0x3;
8420164e:	52 54       	r0 = r0 LSHIFT 2;
84201650:	89 12       	rMAC = rMAC OR r0;
    /* Update the active and hold output streams to reflect the changes. */
    splitter->active_streams = splitter->active_streams & ~streams;
84201652:	ff f7 52 d6 	r0 = -1 - r5;
84201656:	52 10       	r0 = r0 AND rMAC;
84201658:	92 c0       	r0 = r0 AND 0x3;
8420165a:	11 ff fc 1f 	rMAC = rMAC AND 0xfffffffc;
8420165e:	52 12       	r0 = r0 OR rMAC;
    splitter->hold_streams = splitter->hold_streams & ~streams;
84201660:	21 ff cf 1f 	rMAC = r0 AND 0xffffffcf;
84201664:	ff f7 53 d6 	r1 = -1 - r5;
84201668:	d2 50       	r0 = r0 LSHIFT -4;
8420166a:	d2 10       	r0 = r0 AND r1;
8420166c:	92 c0       	r0 = r0 AND 0x3;
8420166e:	d2 54       	r0 = r0 LSHIFT 4;
84201670:	89 12       	rMAC = rMAC OR r0;
84201672:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    if (validate_new_splitter_state(op_data))
84201674:	42 08       	r0 = r6 + Null;
84201676:	cc 4e       	call (m) Lc_validate_new_splitter_state_1;
84201678:	10 04       	Null = r0 - Null;
8420167a:	09 60       	if EQ jump (m) Lc_splitter_deactivate_streams_10;

8420167c <Lc_splitter_deactivate_streams_7>:
    {
#ifdef INSTALL_METADATA
        /* Switching to inactive is instant */
        if (splitter_transition(splitter))
8420167c:	32 00       	r0 = r4 + Null;
8420167e:	f6 ff 21 e0 	call (m) $_splitter_transition;
84201682:	10 04       	Null = r0 - Null;
84201684:	04 60       	if EQ jump (m) Lc_splitter_deactivate_streams_10;

84201686 <Lc_splitter_deactivate_streams_8>:
        {
            /* successful transition */
            splitter->in_transition = FALSE;
84201686:	f0 8f       	M[r4 + 28] = Null;

84201688 <Lc_splitter_deactivate_streams_9>:
    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_deactivate_streams",base_op_get_ext_op_id(op_data));
    streams = (SPLITTER_STREAMS)bitfield;
    if (splitter->inactive_streams == streams)
    {
        /* No need to do anything. */
        return TRUE;
84201688:	42 20       	r0 = Null + 1;
8420168a:	02 6e       	jump (m) Lc_splitter_deactivate_streams_11;

8420168c <Lc_splitter_deactivate_streams_10>:
            splitter->in_transition = FALSE;
        }
        else
        {
            /* Other transitions should be instant. */
            return FALSE;
8420168c:	02 00       	r0 = Null + Null;

8420168e <Lc_splitter_deactivate_streams_11>:
    }
    else
    {
        return FALSE;
    }
}
8420168e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201690:	d8 4c       	rts;

84201692 <$_splitter_buffer_streams>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_buffer_streams(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201692:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201694:	10 09       	r6 = r0 + Null;
84201696:	1f 00       	r5 = r1 + Null;
84201698:	05 f0 2f ea 	call (m) $_base_op_get_instance_data;
8420169c:	16 00       	r4 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned bitfield;
    SPLITTER_STREAMS streams;
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_BUFFER_STREAMS, STREAMS);
8420169e:	f9 88       	rMAC = M[r5 + 12];
842016a0:	8f c6       	r5 = rMAC AND 0xffff;

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_buffer_streams",base_op_get_ext_op_id(op_data));
    if (!validate_input_and_splitter_state(splitter, bitfield))
842016a2:	3b 00       	r1 = r5 + Null;
842016a4:	8f 4e       	call (m) Lc_validate_input_and_splitter_state_1;
842016a6:	10 04       	Null = r0 - Null;
842016a8:	13 60       	if EQ jump (m) Lc_splitter_buffer_streams_5;

842016aa <Lc_splitter_buffer_streams_2>:
    {
        return FALSE;
    }

    streams = (SPLITTER_STREAMS)bitfield;
842016aa:	39 08       	rMAC = SE8 r5;
    if (splitter->hold_streams == streams)
842016ac:	b2 b2       	r0 = MBU[r4 + 26];
842016ae:	d3 50       	r1 = r0 LSHIFT -4;
842016b0:	9d c0       	r3 = r1 AND 0x3;
842016b2:	68 04       	Null = r3 - rMAC;
842016b4:	29 60       	if EQ jump (m) Lc_splitter_buffer_streams_9;

842016b6 <Lc_splitter_buffer_streams_3>:
    {
        /* No need to do anything. */
        return TRUE;
    }
    if ((splitter->inactive_streams & streams) != streams)
842016b6:	53 50       	r1 = r0 LSHIFT -2;
842016b8:	9c c0       	r2 = r1 AND 0x3;
842016ba:	0b 11       	r1 = rMAC AND r2;
842016bc:	58 04       	Null = r1 - rMAC;
842016be:	0a 60       	if EQ jump (m) Lc_splitter_buffer_streams_6;

842016c0 <Lc_splitter_buffer_streams_4>:
    {
        SPLITTER_ERRORMSG3("splitter_buffer_streams: Only inactive streams can be put on hold (buffered)."
                "\n Active %d\n Inactive %d\n Hold %d",
                splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);
842016c0:	93 c0       	r1 = r0 AND 0x3;
842016c2:	55 f1 02 f0 	r0 = Null + 357567397;
842016c6:	a5 53 
842016c8:	ef fd f9 ff 	call (m) 0x9de;
842016cc:	37 e8 

842016ce <Lc_splitter_buffer_streams_5>:
    bitfield = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_BUFFER_STREAMS, STREAMS);

    SPLITTER_MSG1("#### SPLITTER 0x%08x #### splitter_buffer_streams",base_op_get_ext_op_id(op_data));
    if (!validate_input_and_splitter_state(splitter, bitfield))
    {
        return FALSE;
842016ce:	02 00       	r0 = Null + Null;
842016d0:	1c 6e       	jump (m) Lc_splitter_buffer_streams_10;

842016d2 <Lc_splitter_buffer_streams_6>:
        return FALSE;
    }

    /* Terminals on hold can stay unconnected. */
    /* Hold streams. */
    splitter->hold_streams = splitter->hold_streams | streams;
842016d2:	22 ff cf 1f 	r0 = r0 AND 0xffffffcf;
842016d6:	4b 13       	r1 = rMAC OR r3;
842016d8:	9b c0       	r1 = r1 AND 0x3;
842016da:	db 54       	r1 = r1 LSHIFT 4;
842016dc:	d2 12       	r0 = r0 OR r1;
    /* Update the inactive output streams to reflect the changes. */
    splitter->inactive_streams = splitter->inactive_streams & ~streams;
842016de:	23 ff f3 1f 	r1 = r0 AND 0xfffffff3;
842016e2:	ff f1 51 d6 	rMAC = -1 - rMAC;
842016e6:	52 50       	r0 = r0 LSHIFT -2;
842016e8:	89 10       	rMAC = rMAC AND r0;
842016ea:	8a c0       	r0 = rMAC AND 0x3;
842016ec:	52 54       	r0 = r0 LSHIFT 2;
842016ee:	99 12       	rMAC = r1 OR r0;
842016f0:	b1 ba       	MB[r4 + 26] = rMAC;

    /* verify the new state validity. */
    if (validate_new_splitter_state(op_data))
842016f2:	42 08       	r0 = r6 + Null;
842016f4:	8d 4e       	call (m) Lc_validate_new_splitter_state_1;
842016f6:	10 04       	Null = r0 - Null;
842016f8:	eb 61       	if EQ jump (m) Lc_splitter_buffer_streams_5;

842016fa <Lc_splitter_buffer_streams_7>:
    {
#ifdef INSTALL_METADATA
        /* Switching to hold is instant */
        if (splitter_transition(splitter))
842016fa:	32 00       	r0 = r4 + Null;
842016fc:	f5 ff 23 ec 	call (m) $_splitter_transition;
84201700:	10 04       	Null = r0 - Null;
84201702:	e6 61       	if EQ jump (m) Lc_splitter_buffer_streams_5;

84201704 <Lc_splitter_buffer_streams_8>:
        {
            /* successful transition */
            splitter->in_transition = FALSE;
84201704:	f0 8f       	M[r4 + 28] = Null;

84201706 <Lc_splitter_buffer_streams_9>:

    streams = (SPLITTER_STREAMS)bitfield;
    if (splitter->hold_streams == streams)
    {
        /* No need to do anything. */
        return TRUE;
84201706:	42 20       	r0 = Null + 1;

84201708 <Lc_splitter_buffer_streams_10>:
    }
    else
    {
        return FALSE;
    }
}
84201708:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420170a:	d8 4c       	rts;

8420170c <$_splitter_set_reframing>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_reframing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420170c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420170e:	1e 00       	r4 = r1 + Null;
84201710:	05 f0 37 e6 	call (m) $_base_op_get_instance_data;
84201714:	17 00       	r5 = r0 + Null;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    bool enabled;
    unsigned size;

    enabled = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_REFRAMING, MODE) == OPMSG_SPLITTER_REFRAMING_ENABLED;
84201716:	f1 88       	rMAC = M[r4 + 12];
84201718:	00 09       	r6 = Null + Null;
8420171a:	89 c6       	rMAC = rMAC AND 0xffff;
8420171c:	48 24       	Null = rMAC - 1;
8420171e:	20 f0 48 ce 	if EQ r6 = Null + 1;
    size = OPMSG_FIELD_GET(message_data, OPMSG_SPLITTER_SET_REFRAMING, SIZE);
84201722:	31 89       	rMAC = M[r4 + 16];
84201724:	8e c6       	r4 = rMAC AND 0xffff;

    if (enabled)
84201726:	0f f8 00 c2 	Null = r6 - Null;
8420172a:	23 60       	if EQ jump (m) Lc_splitter_set_reframing_9;

8420172c <Lc_splitter_set_reframing_2>:
    {
        if (splitter->reframe_data.sample_rate == 0)
8420172c:	b8 99       	Null = M[r5 + 56];
8420172e:	08 62       	if NE jump (m) Lc_splitter_set_reframing_4;

84201730 <Lc_splitter_set_reframing_3>:
        {
            SPLITTER_ERRORMSG("splitter_set_reframing: Sampling rate not set! "
                    "Please set the sampling rate first.");
84201730:	55 f1 02 f0 	r0 = Null + 357567508;
84201734:	14 58 
84201736:	ef fd f9 ff 	call (m) 0x9a2;
8420173a:	2d e3 
8420173c:	0c 6e       	jump (m) Lc_splitter_set_reframing_6;

8420173e <Lc_splitter_set_reframing_4>:
            return FALSE;
        }
        if (size < SPLITTER_MIN_FRAME_SIZE)
8420173e:	60 f0 80 24 	Null = r4 - 128;
84201742:	02 f0 97 e0 	if C jump (m) Lc_splitter_set_reframing_7;

84201746 <Lc_splitter_set_reframing_5>:
        {
            SPLITTER_ERRORMSG1("splitter_set_reframing: "
                    "Frame %d size too small!",size);
84201746:	55 f1 02 f0 	r0 = Null + 357567591;
8420174a:	67 58 
8420174c:	33 00       	r1 = r4 + Null;
8420174e:	ef fd f9 ff 	call (m) 0x9b4;
84201752:	27 e3 

84201754 <Lc_splitter_set_reframing_6>:
    {
        if (splitter->reframe_data.sample_rate == 0)
        {
            SPLITTER_ERRORMSG("splitter_set_reframing: Sampling rate not set! "
                    "Please set the sampling rate first.");
            return FALSE;
84201754:	02 00       	r0 = Null + Null;
84201756:	19 6e       	jump (m) Lc_splitter_set_reframing_10;

84201758 <Lc_splitter_set_reframing_7>:
            SPLITTER_ERRORMSG1("splitter_set_reframing: "
                    "Frame %d size too small!",size);
            return FALSE;
        }
        /* Make sure at least eight frames can be saved at the internal buffer. */
        if (size > splitter->buffer_size / SPLITTER_MIN_TAGS)
84201758:	ba 88       	r0 = M[r5 + 8];
8420175a:	92 50       	r0 = r0 LSHIFT -3;
8420175c:	b0 04       	Null = r4 - r0;
8420175e:	09 f0 93 e0 	if LS jump (m) Lc_splitter_set_reframing_9;

84201762 <Lc_splitter_set_reframing_8>:
        {
            SPLITTER_ERRORMSG1("splitter_set_reframing: "
                    "Frame %d size too big! Consider using a smaller reframe size.",size);
84201762:	55 f1 02 f0 	r0 = Null + 357567640;
84201766:	98 58 
84201768:	33 00       	r1 = r4 + Null;
8420176a:	ef fd f9 ff 	call (m) 0x9b4;
8420176e:	2b e2 

84201770 <Lc_splitter_set_reframing_9>:
        }
    }

    splitter->reframe_enabled = enabled;
84201770:	71 f0 68 82 	rMAC = MBU[r5 + 104];
84201774:	82 f0 01 00 	r0 = r6 AND 0x1;
84201778:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
8420177c:	12 54       	r0 = r0 LSHIFT 1;
8420177e:	89 12       	rMAC = rMAC OR r0;
84201780:	71 f0 68 8a 	MB[r5 + 104] = rMAC;
    splitter->frame_size = size;
84201784:	fe 9e       	M[r5 + 44] = r4;
    return TRUE;
84201786:	42 20       	r0 = Null + 1;

84201788 <Lc_splitter_set_reframing_10>:
}
84201788:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420178a:	d8 4c       	rts;

8420178c <$_splitter_set_sample_rate>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool splitter_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420178c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420178e:	1e 00       	r4 = r1 + Null;
84201790:	05 f0 37 e2 	call (m) $_base_op_get_instance_data;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);
    unsigned sample_rate = 25 * (OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE));
84201794:	f1 88       	rMAC = M[r4 + 12];
84201796:	89 c6       	rMAC = rMAC AND 0xffff;
84201798:	4b 46       	r1 = rMAC * 25 (int);

    if ((sample_rate < 8000) || (sample_rate > 192000))
8420179a:	30 f1 40 3f 	Null = r1 - 8000;
8420179e:	06 64       	if NC jump (m) Lc_splitter_set_sample_rate_3;

842017a0 <Lc_splitter_set_sample_rate_2>:
842017a0:	0b f0 30 f2 	Null = r1 - 192000;
842017a4:	00 3e 
842017a6:	09 f0 95 e0 	if LS jump (m) Lc_splitter_set_sample_rate_4;

842017aa <Lc_splitter_set_sample_rate_3>:
    {
        SPLITTER_ERRORMSG1("splitter_set_reframing: Invalid sampling rate %d!", sample_rate);
842017aa:	55 f1 02 f0 	r0 = Null + 357567726;
842017ae:	ee 58 
842017b0:	ef fd f9 ff 	call (m) 0x9b4;
842017b4:	25 e0 
        return FALSE;
842017b6:	02 00       	r0 = Null + Null;
842017b8:	03 6e       	jump (m) Lc_splitter_set_sample_rate_5;

842017ba <Lc_splitter_set_sample_rate_4>:
    }
    splitter->reframe_data.sample_rate = sample_rate;
842017ba:	93 9f       	M[r0 + 56] = r1;
    return TRUE;
842017bc:	42 20       	r0 = Null + 1;

842017be <Lc_splitter_set_sample_rate_5>:
}
842017be:	f1 48       	popm <FP, r4, rLink>;
842017c0:	d8 4c       	rts;

842017c2 <Lc_validate_input_and_splitter_state_1>:
/****************************************************************************
Private Function Declaration
*/
/* Checks if the operator state is valid together with the bitfiled. */
static bool validate_input_and_splitter_state(SPLITTER_OP_DATA *splitter, unsigned bitfield)
{
842017c2:	c8 1c       	pushm <FP(=SP), rLink>;
    if(splitter->working_mode != BUFFER_DATA)
842017c4:	11 81       	rMAC = MBS[r0 + 4];
842017c6:	48 24       	Null = rMAC - 1;
842017c8:	09 60       	if EQ jump (m) Lc_validate_input_and_splitter_state_3;

842017ca <Lc_validate_input_and_splitter_state_2>:
    {
        SPLITTER_ERRORMSG1("Splitter: Wrong working mode %d (0 Clone, 1 Buffer Data).",
                splitter->working_mode);
842017ca:	55 f1 02 f0 	r0 = Null + 357565524;
842017ce:	54 48 
842017d0:	0b 00       	r1 = rMAC + Null;
842017d2:	ef fd f8 ff 	call (m) 0x9b4;
842017d6:	23 ef 
842017d8:	16 6e       	jump (m) Lc_validate_input_and_splitter_state_7;

842017da <Lc_validate_input_and_splitter_state_3>:
/**
 * Checks if the bitfield received is within range.
 */
static inline bool invalid_stream_setting(unsigned stream_bitfield)
{
    return (stream_bitfield > (OPMSG_SPLITTER_STREAM_0 | OPMSG_SPLITTER_STREAM_1));
842017da:	01 00       	rMAC = Null + Null;
842017dc:	d8 24       	Null = r1 - 3;
842017de:	28 f0 41 ce 	if HI rMAC = Null + 1;
        return FALSE;
    }

    if (invalid_stream_setting(bitfield))
842017e2:	08 04       	Null = rMAC - Null;
842017e4:	08 60       	if EQ jump (m) Lc_validate_input_and_splitter_state_5;

842017e6 <Lc_validate_input_and_splitter_state_4>:
    {
        SPLITTER_ERRORMSG("Splitter: Invalid bitfield.");
842017e6:	55 f1 02 f0 	r0 = Null + 357565582;
842017ea:	8e 48 
842017ec:	ef fd f8 ff 	call (m) 0x9a2;
842017f0:	37 ed 
842017f2:	09 6e       	jump (m) Lc_validate_input_and_splitter_state_7;

842017f4 <Lc_validate_input_and_splitter_state_5>:
        return FALSE;
    }

    if (splitter->in_transition)
842017f4:	d0 89       	Null = M[r0 + 28];
842017f6:	09 60       	if EQ jump (m) Lc_validate_input_and_splitter_state_8;

842017f8 <Lc_validate_input_and_splitter_state_6>:
    {
        SPLITTER_ERRORMSG("Splitter: Still in transition cannot change state.");
842017f8:	55 f1 02 f0 	r0 = Null + 357565610;
842017fc:	aa 48 
842017fe:	ef fd f8 ff 	call (m) 0x9a2;
84201802:	25 ed 

84201804 <Lc_validate_input_and_splitter_state_7>:
{
    if(splitter->working_mode != BUFFER_DATA)
    {
        SPLITTER_ERRORMSG1("Splitter: Wrong working mode %d (0 Clone, 1 Buffer Data).",
                splitter->working_mode);
        return FALSE;
84201804:	02 00       	r0 = Null + Null;
84201806:	02 6e       	jump (m) Lc_validate_input_and_splitter_state_9;

84201808 <Lc_validate_input_and_splitter_state_8>:
            return FALSE;
        }
        SPLITTER_MSG("Splitter: Waiting finished.");
    }
#endif
    return TRUE;
84201808:	42 20       	r0 = Null + 1;

8420180a <Lc_validate_input_and_splitter_state_9>:
}
8420180a:	c8 48       	popm <FP, rLink>;
8420180c:	d8 4c       	rts;

8420180e <Lc_validate_new_splitter_state_1>:

/* Checks if the operator state is valid. Self kicks the operator where needed.*/
static bool validate_new_splitter_state(OPERATOR_DATA *op_data)
{
8420180e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201810:	16 00       	r4 = r0 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201812:	04 f0 35 ee 	call (m) $_base_op_get_instance_data;
    /* Check if flags for the output stream indexes are only set for state only. */
    return (
            splitter->active_streams ^ splitter->inactive_streams ^ splitter->hold_streams
           ) == (
            (1<<SPLITTER_MAX_OUTPUTS_PER_CHANNEL) - 1
           );
84201816:	93 b2       	r1 = MBU[r0 + 26];
84201818:	5c 50       	r2 = r1 LSHIFT -2;
8420181a:	dd 50       	r3 = r1 LSHIFT -4;
8420181c:	e9 14       	rMAC = r3 XOR r1;
8420181e:	09 15       	rMAC = rMAC XOR r2;
84201820:	8b c0       	r1 = rMAC AND 0x3;
84201822:	01 00       	rMAC = Null + Null;
84201824:	d8 24       	Null = r1 - 3;
84201826:	20 f0 41 ce 	if EQ rMAC = Null + 1;
            "\n   Inactive streams %d"
            "\n   Hold  streams %d!",
            splitter->output_state[0],splitter->output_state[1],
            splitter->active_streams, splitter->inactive_streams, splitter->hold_streams);

    if(!check_next_output_state_validity(splitter))
8420182a:	08 04       	Null = rMAC - Null;
8420182c:	09 62       	if NE jump (m) Lc_validate_new_splitter_state_3;

8420182e <Lc_validate_new_splitter_state_2>:
    {
        SPLITTER_ERRORMSG("Splitter: Wrong splitter state!");
8420182e:	55 f1 02 f0 	r0 = Null + 357565661;
84201832:	dd 48 
84201834:	ef fd f8 ff 	call (m) 0x9a2;
84201838:	2f eb 
        return FALSE;
8420183a:	02 00       	r0 = Null + Null;
8420183c:	0f 6e       	jump (m) Lc_validate_new_splitter_state_8;

8420183e <Lc_validate_new_splitter_state_3>:
    }

    /* No need to transition if the splitter is not connected yet. */
    if (splitter->channel_list != NULL)
8420183e:	11 e8       	rMAC = M[r0 + Null];
84201840:	03 60       	if EQ jump (m) Lc_validate_new_splitter_state_5;

84201842 <Lc_validate_new_splitter_state_4>:
    {
        splitter->in_transition = TRUE;
84201842:	41 20       	rMAC = Null + 1;
84201844:	d1 8f       	M[r0 + 28] = rMAC;

84201846 <Lc_validate_new_splitter_state_5>:
    }

    if (opmgr_op_is_running(op_data))
84201846:	32 00       	r0 = r4 + Null;
84201848:	04 f0 2f e9 	call (m) $_opmgr_op_is_running;
8420184c:	10 04       	Null = r0 - Null;
8420184e:	05 60       	if EQ jump (m) Lc_validate_new_splitter_state_7;

84201850 <Lc_validate_new_splitter_state_6>:
 * 
 * \param op_data The data structure of the operator to kick
 */
static inline void opmgr_kick_operator(OPERATOR_DATA *op_data)
{
    raise_bg_int(op_data->task_id);
84201850:	b2 88       	r0 = M[r4 + 8];
84201852:	ff fd 97 f0 	call (m) 0x14766;
84201856:	35 e8 

84201858 <Lc_validate_new_splitter_state_7>:
    {
        /* A switch is needed. Try to kick the operator to perform the switch. */
        opmgr_kick_operator(op_data);
    }
    return TRUE;
84201858:	42 20       	r0 = Null + 1;

8420185a <Lc_validate_new_splitter_state_8>:
}
8420185a:	f1 48       	popm <FP, r4, rLink>;
8420185c:	d8 4c       	rts;

8420185e <Lc_splitter_output_stream_connected_1>:

/* Check if the outputs are connected for the given bitfield. */
static bool splitter_output_stream_connected(SPLITTER_OP_DATA *splitter, SPLITTER_STREAMS streams)
{
8420185e:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned channel_mask, i;
    SPLITTER_CHANNEL_STRUC *channel;

    channel = splitter->channel_list;
84201860:	11 e8       	rMAC = M[r0 + Null];
84201862:	06 6e       	jump (m) Lc_splitter_output_stream_connected_4;

84201864 <Lc_splitter_output_stream_connected_2>:
    while (channel != NULL)
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201864:	64 20       	r2 = r2 + 1;
84201866:	2d 21       	r3 = r3 + 4;
84201868:	a0 24       	Null = r2 - 2;
8420186a:	06 64       	if NC jump (m) Lc_splitter_output_stream_connected_6;

8420186c <Lc_splitter_output_stream_connected_3>:
                SPLITTER_ERRORMSG2("Splitter: Channel %d output %d not connected", channel->id ,i);
                return FALSE;
            }
        }

        channel = channel->next;
8420186c:	09 e8       	rMAC = M[rMAC + Null];

8420186e <Lc_splitter_output_stream_connected_4>:
{
    unsigned channel_mask, i;
    SPLITTER_CHANNEL_STRUC *channel;

    channel = splitter->channel_list;
    while (channel != NULL)
8420186e:	08 04       	Null = rMAC - Null;
84201870:	13 60       	if EQ jump (m) Lc_splitter_output_stream_connected_9;

84201872 <Lc_splitter_output_stream_connected_5>:
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201872:	04 00       	r2 = Null + Null;
84201874:	0d 23       	r3 = rMAC + 12;

84201876 <Lc_splitter_output_stream_connected_6>:
        {
            channel_mask = 1<<i;
84201876:	22 00       	r0 = r2 + Null;
84201878:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
            if ((streams & channel_mask) && (channel->output_buffer[i] == NULL))
8420187c:	d2 10       	r0 = r0 AND r1;
8420187e:	f3 61       	if EQ jump (m) Lc_splitter_output_stream_connected_2;

84201880 <Lc_splitter_output_stream_connected_7>:
84201880:	2a e8       	r0 = M[r3 + Null];
84201882:	f1 63       	if NE jump (m) Lc_splitter_output_stream_connected_2;

84201884 <Lc_splitter_output_stream_connected_8>:
            {
                SPLITTER_ERRORMSG2("Splitter: Channel %d output %d not connected", channel->id ,i);
84201884:	4b 88       	r1 = M[rMAC + 4];
84201886:	55 f1 02 f0 	r0 = Null + 357565693;
8420188a:	fd 48 
8420188c:	ef fd f8 ff 	call (m) 0x9c8;
84201890:	3d e9 
                return FALSE;
84201892:	02 00       	r0 = Null + Null;
84201894:	02 6e       	jump (m) Lc_splitter_output_stream_connected_10;

84201896 <Lc_splitter_output_stream_connected_9>:

        channel = channel->next;
    }

    /* All output channels are connected. */
    return TRUE;
84201896:	42 20       	r0 = Null + 1;

84201898 <Lc_splitter_output_stream_connected_10>:
}
84201898:	c8 48       	popm <FP, rLink>;
8420189a:	d8 4c       	rts;

8420189c <$_create_internal_metadata>:
8420189c:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;

/**
 * Helper function which creates the metadata buffer.
 */
bool create_internal_metadata(SPLITTER_OP_DATA *splitter, data_buffer_t* internal_buff, unsigned buffer_size)
{
8420189e:	17 00       	r5 = r0 + Null;
842018a0:	23 00       	r1 = r2 + Null;
    tCbuffer *metadata_buffer;

    if (splitter->working_mode == CLONE_BUFFER)
842018a2:	39 81       	rMAC = MBS[r5 + 4];
842018a4:	3a 60       	if EQ jump (m) Lc_create_internal_metadata_11;

842018a6 <Lc_create_internal_metadata_2>:

    /* Make sure that metadata is only created once. */
    SPLITTER_DEBUG_INSTR(PL_ASSERT(splitter->internal_metadata.buffer == NULL));

    /* Reduce the buffer size to samples.*/
    if (splitter->tag_size_to_samples)
842018a6:	72 f0 68 82 	r0 = MBU[r5 + 104];
842018aa:	52 50       	r0 = r0 LSHIFT -2;
842018ac:	11 c0       	rMAC = r0 AND 0x1;
842018ae:	02 60       	if EQ jump (m) Lc_create_internal_metadata_4;

842018b0 <Lc_create_internal_metadata_3>:
    {
        buffer_size = buffer_size>>2;
842018b0:	5b 50       	r1 = r1 LSHIFT -2;

842018b2 <Lc_create_internal_metadata_4>:
    }

    /* This buffer is only used for metadata.*/
    metadata_buffer = cbuffer_create(NULL, buffer_size, BUF_DESC_SW_BUFFER);
842018b2:	04 00       	r2 = Null + Null;
842018b4:	02 00       	r0 = Null + Null;
842018b6:	ff fd 87 f0 	call (m) 0x12762;
842018ba:	2d e5 
842018bc:	16 00       	r4 = r0 + Null;

    if (metadata_buffer == NULL)
842018be:	2f 62       	if NE jump (m) Lc_create_internal_metadata_12;

842018c0 <Lc_create_internal_metadata_5>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata buffer for internal data!" );
842018c0:	55 f1 02 f0 	r0 = Null + 357567776;
842018c4:	20 59 
842018c6:	ef fd f8 ff 	call (m) 0x9a2;
842018ca:	3d e6 
842018cc:	39 6e       	jump (m) Lc_create_internal_metadata_14;

842018ce <Lc_create_internal_metadata_6>:
        cbuffer_destroy_struct(metadata_buffer);
        return FALSE;
    }

    /* Only one metadata for the internal buffers. */
    metadata_buffer->metadata->next = metadata_buffer->metadata;
842018ce:	12 8f       	M[r0 + 16] = r0;
    metadata_buffer->metadata->ref_cnt = 1;
842018d0:	b1 89       	rMAC = M[r4 + 24];
842018d2:	09 29       	rMAC = rMAC + 20;
842018d4:	0a e8       	r0 = M[rMAC + Null];
842018d6:	22 ff c0 1f 	r0 = r0 AND 0xffffffc0;
842018da:	12 c8       	r0 = r0 OR 0x1;
842018dc:	0a ee       	M[rMAC + Null] = r0;

    /* Set the metadata flag!*/
    metadata_buffer->descriptor |= BUF_DESC_METADATA_MASK;
842018de:	71 89       	rMAC = M[r4 + 20];
842018e0:	49 ce       	rMAC = rMAC OR 0x8000;
842018e2:	71 8f       	M[r4 + 20] = rMAC;

    /* Set the usable octets based on the packing.
     * cbuffer_set_usable_octets will also sets the metadata buffer size
     * based on the cbuffer buffer size! */
    cbuffer_set_usable_octets(metadata_buffer,
            OCTETS_PER_SAMPLE);
842018e4:	03 21       	r1 = Null + 4;
842018e6:	32 00       	r0 = r4 + Null;
842018e8:	04 f0 31 e9 	call (m) $_cbuffer_set_usable_octets;

    if (splitter->packing == PACKED&&
        ((splitter->data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA) ||
         (splitter->data_format == AUDIO_DATA_FORMAT_FIXP)))
842018ec:	b9 81       	rMAC = MBS[r5 + 6];
842018ee:	48 24       	Null = rMAC - 1;
842018f0:	13 62       	if NE jump (m) Lc_create_internal_metadata_10;

842018f2 <Lc_create_internal_metadata_7>:
842018f2:	f9 88       	rMAC = M[r5 + 12];
842018f4:	c8 24       	Null = rMAC - 3;
842018f6:	03 60       	if EQ jump (m) Lc_create_internal_metadata_9;

842018f8 <Lc_create_internal_metadata_8>:
842018f8:	48 24       	Null = rMAC - 1;
842018fa:	0e 62       	if NE jump (m) Lc_create_internal_metadata_10;

842018fc <Lc_create_internal_metadata_9>:
         * just double the metadata buffer size.
         * internal_metadata_buff->metadata->buffer_size is change by
         * cbuffer_set_usable_octets as all internal buffer has
         * the same metadata*/
        metadata_buffer->metadata->buffer_size =
                metadata_buffer->metadata->buffer_size * 2;
842018fc:	b1 89       	rMAC = M[r4 + 24];
842018fe:	09 29       	rMAC = rMAC + 20;
84201900:	0a e8       	r0 = M[rMAC + Null];
84201902:	80 ff 23 f0 	r1 = r0 AND 0xff0000ff;
84201906:	ff 00 
84201908:	d2 51       	r0 = r0 LSHIFT -8;
8420190a:	92 c6       	r0 = r0 AND 0xffff;
8420190c:	12 54       	r0 = r0 LSHIFT 1;
8420190e:	92 c6       	r0 = r0 AND 0xffff;
84201910:	d2 55       	r0 = r0 LSHIFT 8;
84201912:	d2 12       	r0 = r0 OR r1;
84201914:	0a ee       	M[rMAC + Null] = r0;

84201916 <Lc_create_internal_metadata_10>:
    }

    /* Save the created metadata buffer*/
    splitter->internal_metadata.buffer = metadata_buffer;
84201916:	7e af       	M[r5 + 84] = r4;

84201918 <Lc_create_internal_metadata_11>:
    tCbuffer *metadata_buffer;

    if (splitter->working_mode == CLONE_BUFFER)
    {
        SPLITTER_MSG("Splitter: No need to create internal metadata when cloning!");
        return TRUE;
84201918:	42 20       	r0 = Null + 1;
8420191a:	13 6e       	jump (m) Lc_create_internal_metadata_15;

8420191c <Lc_create_internal_metadata_12>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata buffer for internal data!" );
        return FALSE;
    }

    metadata_buffer->metadata = xzpnew(metadata_list);
8420191c:	c3 20       	r1 = Null + 3;
8420191e:	02 2a       	r0 = Null + 24;
84201920:	ff fd 1b f0 	call (m) 0x4f2a;
84201924:	2b e0 
    if (metadata_buffer->metadata == NULL)
84201926:	b2 8f       	M[r4 + 24] = r0;
84201928:	d3 63       	if NE jump (m) Lc_create_internal_metadata_6;

8420192a <Lc_create_internal_metadata_13>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata for internal buffer.!" );
8420192a:	55 f1 02 f0 	r0 = Null + 357567840;
8420192e:	60 59 
84201930:	ef fd f8 ff 	call (m) 0x9a2;
84201934:	33 e3 
        cbuffer_destroy_struct(metadata_buffer);
84201936:	32 00       	r0 = r4 + Null;
84201938:	ff fd 87 f0 	call (m) 0x12834;
8420193c:	3d e7 

8420193e <Lc_create_internal_metadata_14>:
    metadata_buffer = cbuffer_create(NULL, buffer_size, BUF_DESC_SW_BUFFER);

    if (metadata_buffer == NULL)
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate metadata buffer for internal data!" );
        return FALSE;
8420193e:	02 00       	r0 = Null + Null;

84201940 <Lc_create_internal_metadata_15>:
    }

    /* Save the created metadata buffer*/
    splitter->internal_metadata.buffer = metadata_buffer;
    return TRUE;
}
84201940:	f2 48       	popm <FP, r4, r5, rLink>;
84201942:	d8 4c       	rts;

84201944 <$_delete_internal_metadata>:

/**
 * Helper function which deleted the metadata buffer.
 */
void delete_internal_metadata(SPLITTER_OP_DATA *splitter)
{
84201944:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201946:	16 00       	r4 = r0 + Null;
    if (splitter->working_mode == CLONE_BUFFER)
84201948:	31 81       	rMAC = MBS[r4 + 4];
8420194a:	07 60       	if EQ jump (m) Lc_delete_internal_metadata_4;

8420194c <Lc_delete_internal_metadata_2>:
    {
        SPLITTER_MSG("Splitter: No internal metadata when cloning!");
        return;
    }
    if (splitter->internal_metadata.buffer == NULL)
8420194c:	72 a9       	r0 = M[r4 + 84];
8420194e:	05 60       	if EQ jump (m) Lc_delete_internal_metadata_4;

84201950 <Lc_delete_internal_metadata_3>:
        SPLITTER_MSG("Splitter: No internal metadata!");
        return;
    }

    SPLITTER_MSG1("Deleting internal metadata buffer 0x%08x", splitter->internal_metadata.buffer);
    cbuffer_destroy_struct(splitter->internal_metadata.buffer);
84201950:	ff fd 87 f0 	call (m) 0x12834;
84201954:	25 e7 
    
    splitter->internal_metadata.buffer = NULL;
84201956:	70 af       	M[r4 + 84] = Null;

84201958 <Lc_delete_internal_metadata_4>:
}
84201958:	f1 48       	popm <FP, r4, rLink>;
8420195a:	d8 4c       	rts;

8420195c <$_get_metadata_buffer>:
 */
tCbuffer* get_metadata_buffer(SPLITTER_OP_DATA *splitter, bool is_input, unsigned index)
{
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;

    if (channel != NULL)
8420195c:	11 e8       	rMAC = M[r0 + Null];
8420195e:	17 60       	if EQ jump (m) Lc_get_metadata_buffer_10;

84201960 <Lc_get_metadata_buffer_2>:
    {
        if (is_input)
84201960:	18 04       	Null = r1 - Null;
84201962:	03 60       	if EQ jump (m) Lc_get_metadata_buffer_4;

84201964 <Lc_get_metadata_buffer_3>:
        {
            /* Return the medata input buffer. */
            return channel->input_buffer;
84201964:	8a 88       	r0 = M[rMAC + 8];
84201966:	14 6e       	jump (m) Lc_get_metadata_buffer_11;

84201968 <Lc_get_metadata_buffer_4>:
        }
        else
        {
            if (splitter->working_mode != CLONE_BUFFER)
84201968:	12 81       	r0 = MBS[r0 + 4];
8420196a:	05 60       	if EQ jump (m) Lc_get_metadata_buffer_6;

8420196c <Lc_get_metadata_buffer_5>:
            {
                return channel->output_buffer[index];
8420196c:	62 54       	r0 = r2 LSHIFT 2;
8420196e:	51 00       	rMAC = r0 + rMAC;
84201970:	ca 88       	r0 = M[rMAC + 12];
84201972:	0e 6e       	jump (m) Lc_get_metadata_buffer_11;

84201974 <Lc_get_metadata_buffer_6>:
            else
            {
                unsigned i;
                /* When splitter is in cloning mode each output has the same
                 * metadata so use the one which is connected. */
                for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201974:	02 00       	r0 = Null + Null;
84201976:	0b 23       	r1 = rMAC + 12;

84201978 <Lc_get_metadata_buffer_7>:
                {
                    if (channel->output_buffer[i] != NULL)
84201978:	1c e8       	r2 = M[r1 + Null];
8420197a:	05 60       	if EQ jump (m) Lc_get_metadata_buffer_9;

8420197c <Lc_get_metadata_buffer_8>:
                    {
                        return channel->output_buffer[i];
8420197c:	52 54       	r0 = r0 LSHIFT 2;
8420197e:	51 00       	rMAC = r0 + rMAC;
84201980:	ca 88       	r0 = M[rMAC + 12];
84201982:	06 6e       	jump (m) Lc_get_metadata_buffer_11;

84201984 <Lc_get_metadata_buffer_9>:
            else
            {
                unsigned i;
                /* When splitter is in cloning mode each output has the same
                 * metadata so use the one which is connected. */
                for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201984:	52 20       	r0 = r0 + 1;
84201986:	1b 21       	r1 = r1 + 4;
84201988:	90 24       	Null = r0 - 2;
8420198a:	f7 65       	if NC jump (m) Lc_get_metadata_buffer_7;

8420198c <Lc_get_metadata_buffer_10>:
            }
        }
    }

    /* Couldn't find anything. */
    return NULL;
8420198c:	02 00       	r0 = Null + Null;

8420198e <Lc_get_metadata_buffer_11>:
8420198e:	d8 4c       	rts;

84201990 <$_splitter_metadata_transport_to_internal>:
 * Transports the metadata form the input to the internal buffer.
 * Very similar to metadata_strict_transport, with the exception that this function sets
 * the new metadata tag head for the channel for tracking reasons.
 */
void splitter_metadata_transport_to_internal(SPLITTER_OP_DATA *splitter,  unsigned trans_octets)
{
84201990:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84201992:	4c 4c       	SP = SP + 48;
84201994:	16 00       	r4 = r0 + Null;
84201996:	19 09       	r7 = r1 + Null;
    tCbuffer *dst;
    metadata_tag *ret_mtag;
    unsigned b4idx, afteridx;
    unsigned i;

    src = get_metadata_buffer(splitter, TRUE, 0);
84201998:	43 20       	r1 = Null + 1;
8420199a:	04 00       	r2 = Null + Null;
8420199c:	e0 4f       	call (m) $_get_metadata_buffer;
    dst = splitter->internal_metadata.buffer;
8420199e:	71 a9       	rMAC = M[r4 + 84];
842019a0:	41 de       	M[FP + 32] = rMAC;

    if (trans_octets == 0)
842019a2:	0f f9 00 c2 	Null = r7 - Null;
842019a6:	d2 60       	if EQ jump (m) Lc__loop0;

842019a8 <Lc_splitter_metadata_transport_to_internal_2>:
        SPLITTER_MSG("splitter_metadata_transport_to_internal: ignoring zero transfer");
        return;
    }

    /* convert the consumed octets.*/
    if (splitter->cbuffer.data_size == 4)
842019a8:	61 f0 25 88 	rMAC = M[r4 + 148];
842019ac:	08 25       	Null = rMAC - 4;
842019ae:	03 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_4;

842019b0 <Lc_splitter_metadata_transport_to_internal_3>:

/** Converts samples to octets */
static inline unsigned samples_to_octets(unsigned val)
{
    /* KCC is smart so it will shift.*/
    return val * OCTETS_PER_SAMPLE;
842019b0:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;

842019b4 <Lc_splitter_metadata_transport_to_internal_4>:
    {
        trans_octets = samples_to_octets(trans_octets);
    }

    if (src != NULL)
842019b4:	10 04       	Null = r0 - Null;
842019b6:	09 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_6;

842019b8 <Lc_splitter_metadata_transport_to_internal_5>:
        /* transport metadata, first (attempt to) consume tag associated with src */
#ifdef METADATA_DEBUG_TRANSPORT
        ret_mtag = buff_metadata_remove_dbg(src, trans_octets, &b4idx,
                                            &afteridx, return_addr);
#else /* METADATA_DEBUG_TRANSPORT */
        ret_mtag = buff_metadata_remove(src, trans_octets, &b4idx, &afteridx);
842019b8:	85 12       	r3 = FP + 40;
842019ba:	44 12       	r2 = FP + 36;
842019bc:	4b 08       	r1 = r7 + Null;
842019be:	ff fd 81 f0 	call (m) 0x11d7a;
842019c2:	3d ed 
842019c4:	17 00       	r5 = r0 + Null;
842019c6:	05 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_7;

842019c8 <Lc_splitter_metadata_transport_to_internal_6>:
#endif /* METADATA_DEBUG_TRANSPORT */
    }
    else
    {
        b4idx = 0;
842019c8:	48 de       	M[FP + 36] = Null;
        afteridx = trans_octets;
842019ca:	e9 f0 0a 8e 	M[FP + 40] = r7;
        ret_mtag = NULL;
842019ce:	07 00       	r5 = Null + Null;

842019d0 <Lc_splitter_metadata_transport_to_internal_7>:
                    splitter->frame_size);
        }
    }
#endif

    if (splitter->reframe_enabled)
842019d0:	62 f0 68 82 	r0 = MBU[r4 + 104];
842019d4:	13 50       	r1 = r0 LSHIFT -1;
842019d6:	19 c0       	rMAC = r1 AND 0x1;
842019d8:	8e 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_31;

842019da <Lc_splitter_metadata_transport_to_internal_8>:
    {
        metadata_tag *mtag_ip, *mtag;
        unsigned new_ttp, base_ttp = 0, sample_offset = 0;
842019da:	03 09       	r9 = Null + Null;
842019dc:	02 09       	r8 = Null + Null;
        ttp_status status;

        /* Find the first timestamped tag */
        mtag_ip = ret_mtag;
842019de:	38 09       	r6 = r5 + Null;

842019e0 <Lc_splitter_metadata_transport_to_internal_9>:
        while (mtag_ip != NULL)
842019e0:	0f f8 00 c2 	Null = r6 - Null;
842019e4:	33 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_17;

842019e6 <Lc_splitter_metadata_transport_to_internal_10>:
        {
            if (IS_TIMESTAMPED_TAG(mtag_ip))
842019e6:	81 f0 01 88 	rMAC = M[r6 + 4];
842019ea:	12 f0 30 00 	r0 = rMAC AND 0x30;
842019ee:	03 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_12;

842019f0 <Lc_splitter_metadata_transport_to_internal_11>:
842019f0:	c9 c2       	rMAC = rMAC AND 0x40;
842019f2:	0f 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_13;

842019f4 <Lc_splitter_metadata_transport_to_internal_12>:
            }
            else
            {
                SPLITTER_ERRORMSG(
                    "splitter_metadata_transport_to_internal: Tag not timestamped!"
                        "\n Splitter cannot reframe timestamped tags.");
842019f4:	55 f1 02 f0 	r0 = Null + 357567900;
842019f8:	9c 59 
842019fa:	ef fd f7 ff 	call (m) 0x9a2;
842019fe:	29 ed 
                b4idx += mtag_ip->length;
84201a00:	81 f0 03 88 	rMAC = M[r6 + 12];
84201a04:	4a d8       	r0 = M[FP + 36];
84201a06:	51 00       	rMAC = r0 + rMAC;
84201a08:	49 de       	M[FP + 36] = rMAC;
                mtag_ip = mtag_ip->next;
84201a0a:	88 f0 00 e8 	r6 = M[r6 + Null];
84201a0e:	e9 6f       	jump (m) Lc_splitter_metadata_transport_to_internal_9;

84201a10 <Lc_splitter_metadata_transport_to_internal_13>:
            }
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84201a10:	48 d8       	Null = M[FP + 36];
84201a12:	1c 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_17;

84201a14 <Lc_splitter_metadata_transport_to_internal_14>:
        {
            /* If the old tag is already at the start of the encoded frame,
             * Just use its timestamp directly
             */
            base_ttp = mtag_ip->timestamp;
84201a14:	8b f0 04 88 	r9 = M[r6 + 16];
            sample_offset = 0;
84201a18:	02 09       	r8 = Null + Null;

84201a1a <Lc_splitter_metadata_transport_to_internal_15>:
        if (mtag_ip != NULL)
        {
            unsigned *err_offset_id;
            unsigned length;
            /* Save the timestamp info from the incoming metadata */
            splitter->reframe_data.last_tag_timestamp = mtag_ip->timestamp;
84201a1a:	81 f0 04 88 	rMAC = M[r6 + 16];
84201a1e:	f1 9f       	M[r4 + 60] = rMAC;
            splitter->reframe_data.last_tag_spa = mtag_ip->sp_adjust;
84201a20:	81 f0 05 88 	rMAC = M[r6 + 20];
84201a24:	31 ae       	M[r4 + 64] = rMAC;
            splitter->reframe_data.last_tag_samples = (trans_octets - b4idx) / OCTETS_PER_SAMPLE;
84201a26:	49 d8       	rMAC = M[FP + 36];
84201a28:	1f f9 02 c2 	r0 = r7 - rMAC;
84201a2c:	52 50       	r0 = r0 LSHIFT -2;
84201a2e:	72 ae       	M[r4 + 68] = r0;
            if (buff_metadata_find_private_data(mtag_ip, META_PRIV_KEY_TTP_OFFSET, &length, (void **)&err_offset_id))
84201a30:	c5 12       	r3 = FP + 44;
84201a32:	04 13       	r2 = FP + 48;
84201a34:	43 20       	r1 = Null + 1;
84201a36:	42 08       	r0 = r6 + Null;
84201a38:	ff fd 80 f0 	call (m) 0x11a84;
84201a3c:	2d e2 
84201a3e:	10 04       	Null = r0 - Null;
84201a40:	35 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_25;

84201a42 <Lc_splitter_metadata_transport_to_internal_16>:
            {
                splitter->reframe_data.last_tag_err_offset_id = (*err_offset_id);
84201a42:	59 d8       	rMAC = M[FP + 44];
84201a44:	09 e8       	rMAC = M[rMAC + Null];
84201a46:	b1 ae       	M[r4 + 72] = rMAC;
84201a48:	10 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_22;

84201a4a <Lc_splitter_metadata_transport_to_internal_17>:
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp.
             * There had better be one ! */
            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201a4a:	71 a8       	rMAC = M[r4 + 68];
84201a4c:	48 20       	Null = rMAC + 1;
84201a4e:	04 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_19;

84201a50 <Lc_splitter_metadata_transport_to_internal_18>:
            {
                base_ttp = splitter->reframe_data.last_tag_timestamp;
84201a50:	6b f0 0f 88 	r9 = M[r4 + 60];
                sample_offset = splitter->reframe_data.last_tag_samples;
84201a54:	0a 09       	r8 = rMAC + Null;

84201a56 <Lc_splitter_metadata_transport_to_internal_19>:
            }
        }

        /* Save the tag for future reference when not tag was found. */
        if (mtag_ip != NULL)
84201a56:	0f f8 00 c2 	Null = r6 - Null;
84201a5a:	e0 63       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_15;

84201a5c <Lc_splitter_metadata_transport_to_internal_20>:
                splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
            }
        }
        else
        {
            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201a5c:	48 20       	Null = rMAC + 1;
84201a5e:	05 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_22;

84201a60 <Lc_splitter_metadata_transport_to_internal_21>:
            {
                splitter->reframe_data.last_tag_samples += trans_octets / OCTETS_PER_SAMPLE;
84201a60:	7f f9 d2 c8 	r0 = r7 LSHIFT -2;
84201a64:	51 00       	rMAC = r0 + rMAC;
84201a66:	71 ae       	M[r4 + 68] = rMAC;

84201a68 <Lc_splitter_metadata_transport_to_internal_22>:
            }
        }

        status.sp_adjustment = splitter->reframe_data.last_tag_spa;
84201a68:	31 a8       	rMAC = M[r4 + 64];
84201a6a:	71 de       	M[FP + 56] = rMAC;
        status.err_offset_id = splitter->reframe_data.last_tag_err_offset_id;
84201a6c:	b1 a8       	rMAC = M[r4 + 72];
84201a6e:	79 de       	M[FP + 60] = rMAC;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);
84201a70:	81 f0 01 88 	rMAC = M[r6 + 4];
84201a74:	09 c0       	rMAC = rMAC AND 0x1;
84201a76:	81 de       	M[FP + 64] = rMAC;

        /* Create a new tag for the output */
        mtag = buff_metadata_new_tag();
84201a78:	ff fd 7e f0 	call (m) 0x11862;
84201a7c:	2b ef 
84201a7e:	10 09       	r6 = r0 + Null;

        if (mtag != NULL)
84201a80:	1e 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_27;

84201a82 <Lc_splitter_metadata_transport_to_internal_23>:
        {
            /* create a tag which covers the newly generated output. */
            mtag->length = trans_octets;
84201a82:	89 f0 03 8e 	M[r6 + 12] = r7;

            if (splitter->reframe_data.last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84201a86:	71 a8       	rMAC = M[r4 + 68];
84201a88:	48 20       	Null = rMAC + 1;
84201a8a:	12 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_26;

84201a8c <Lc_splitter_metadata_transport_to_internal_24>:
            {
                /* Calculate new TTP from incoming data and sample offset */
                new_ttp = ttp_get_next_timestamp(base_ttp, sample_offset,
                        splitter->reframe_data.sample_rate, splitter->reframe_data.last_tag_spa);
84201a8c:	35 a8       	r3 = M[r4 + 64];
84201a8e:	b4 99       	r2 = M[r4 + 56];
84201a90:	53 08       	r1 = r8 + Null;
84201a92:	5a 08       	r0 = r9 + Null;
84201a94:	ff fd a8 f0 	call (m) 0x16aa2;
84201a98:	2f e0 
                status.ttp = new_ttp;
84201a9a:	6a de       	M[FP + 52] = r0;
                ttp_utils_populate_tag(mtag, &status);
84201a9c:	43 13       	r1 = FP + 52;
84201a9e:	42 08       	r0 = r6 + Null;
84201aa0:	ef fd f7 ff 	call (m) 0x8d0;
84201aa4:	31 e1 
                status.stream_restart = FALSE;
84201aa6:	80 de       	M[FP + 64] = Null;
84201aa8:	10 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_28;

84201aaa <Lc_splitter_metadata_transport_to_internal_25>:
            {
                splitter->reframe_data.last_tag_err_offset_id = (*err_offset_id);
            }
            else
            {
                splitter->reframe_data.last_tag_err_offset_id = INFO_ID_INVALID;
84201aaa:	b0 ae       	M[r4 + 72] = Null;
84201aac:	de 6f       	jump (m) Lc_splitter_metadata_transport_to_internal_22;

84201aae <Lc_splitter_metadata_transport_to_internal_26>:
                status.stream_restart = FALSE;
            }
            else
            {
                SPLITTER_ERRORMSG(
                    "splitter_metadata_transport_to_internal: Last tag samples invalid");
84201aae:	55 f1 02 f0 	r0 = Null + 357568005;
84201ab2:	05 5a 
84201ab4:	ef fd f7 ff 	call (m) 0x9a2;
84201ab8:	2f e7 
84201aba:	07 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_28;

84201abc <Lc_splitter_metadata_transport_to_internal_27>:
            }
        }
        else
        {
            SPLITTER_ERRORMSG(
                "splitter_metadata_transport_to_internal: Failed to allocate tag");
84201abc:	55 f1 02 f0 	r0 = Null + 357568071;
84201ac0:	47 5a 
84201ac2:	ef fd f7 ff 	call (m) 0x9a2;
84201ac6:	21 e7 

84201ac8 <Lc_splitter_metadata_transport_to_internal_28>:
        }

        if (splitter->tag_size_to_samples)
84201ac8:	62 f0 68 82 	r0 = MBU[r4 + 104];
84201acc:	52 50       	r0 = r0 LSHIFT -2;
84201ace:	11 c0       	rMAC = r0 AND 0x1;
84201ad0:	05 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_30;

84201ad2 <Lc_splitter_metadata_transport_to_internal_29>:
        {
            /* convert the the sizes to samples. */
            convert_tags_length_to_samples(mtag);
84201ad2:	42 08       	r0 = r6 + Null;
84201ad4:	bb 4e       	call (m) Lc_convert_tags_length_to_samples_1;
            trans_octets = trans_octets>>2;
84201ad6:	7f f9 d9 c8 	r7 = r7 LSHIFT -2;

84201ada <Lc_splitter_metadata_transport_to_internal_30>:
        }

        buff_metadata_append(dst, mtag, 0, trans_octets);
84201ada:	04 00       	r2 = Null + Null;
84201adc:	4d 08       	r3 = r7 + Null;
84201ade:	43 08       	r1 = r6 + Null;
84201ae0:	42 d8       	r0 = M[FP + 32];
84201ae2:	ff fd 7f f0 	call (m) 0x11adc;
84201ae6:	3b ef 

        /* Free all the incoming tags */
        buff_metadata_tag_list_delete(ret_mtag);
84201ae8:	3a 00       	r0 = r5 + Null;
84201aea:	ff fd 7f f0 	call (m) 0x11906;
84201aee:	3d e0 

        /* Set the created tag as potential new head. */
        ret_mtag = mtag;
84201af0:	47 08       	r5 = r6 + Null;
84201af2:	1a 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_36;

84201af4 <Lc_splitter_metadata_transport_to_internal_31>:
    }
    else
    {
        if (dst != NULL)
84201af4:	41 d8       	rMAC = M[FP + 32];
84201af6:	14 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_35;

84201af8 <Lc_splitter_metadata_transport_to_internal_32>:
        {
            if (splitter->tag_size_to_samples)
84201af8:	52 50       	r0 = r0 LSHIFT -2;
84201afa:	11 c0       	rMAC = r0 AND 0x1;
84201afc:	09 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_34;

84201afe <Lc_splitter_metadata_transport_to_internal_33>:
            {
                /* convert the the sizes to samples. */
                convert_tags_length_to_samples(ret_mtag);
84201afe:	3a 00       	r0 = r5 + Null;
84201b00:	a5 4e       	call (m) Lc_convert_tags_length_to_samples_1;
                b4idx = b4idx>>2;
84201b02:	4a d8       	r0 = M[FP + 36];
84201b04:	52 50       	r0 = r0 LSHIFT -2;
84201b06:	4a de       	M[FP + 36] = r0;
                afteridx = afteridx>>2;
84201b08:	52 d8       	r0 = M[FP + 40];
84201b0a:	52 50       	r0 = r0 LSHIFT -2;
84201b0c:	52 de       	M[FP + 40] = r0;

84201b0e <Lc_splitter_metadata_transport_to_internal_34>:
             * later to the src which does support metadata the dst metadata write
             * pointer needs to be at the right offset. */
#ifdef METADATA_DEBUG_TRANSPORT
            buff_metadata_append_dbg(dst, ret_mtag, b4idx, afteridx, return_addr);
#else /* METADATA_DEBUG_TRANSPORT */
            buff_metadata_append(dst, ret_mtag, b4idx, afteridx);
84201b0e:	55 d8       	r3 = M[FP + 40];
84201b10:	4c d8       	r2 = M[FP + 36];
84201b12:	3b 00       	r1 = r5 + Null;
84201b14:	42 d8       	r0 = M[FP + 32];
84201b16:	ff fd 7f f0 	call (m) 0x11adc;
84201b1a:	27 ee 
84201b1c:	05 6e       	jump (m) Lc_splitter_metadata_transport_to_internal_36;

84201b1e <Lc_splitter_metadata_transport_to_internal_35>:
#endif /* METADATA_DEBUG_TRANSPORT */
        }
        else
        {
            buff_metadata_tag_list_delete(ret_mtag);
84201b1e:	3a 00       	r0 = r5 + Null;
84201b20:	ff fd 7e f0 	call (m) 0x11906;
84201b24:	27 ef 

84201b26 <Lc_splitter_metadata_transport_to_internal_36>:
        }
    }

    /* Check if ret_mtag is a new head for any of the output streams. */
    if (ret_mtag != NULL)
84201b26:	38 04       	Null = r5 - Null;
84201b28:	11 60       	if EQ jump (m) Lc__loop0;

84201b2a <Lc_splitter_metadata_transport_to_internal_37>:
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201b2a:	01 00       	rMAC = Null + Null;
84201b2c:	62 f0 60 20 	r0 = r4 + 96;
84201b30:	14 71       	r10 = Null + 2;
84201b32:	0c 4c       	do (m) Lc__loop0;

84201b34 <Lc_splitter_metadata_transport_to_internal_38>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84201b34:	33 2a       	r1 = r4 + 24;
84201b36:	5b e0       	r1 = MBS[r1 + rMAC];
        {
            SPLITTER_OUTPUT_STATE output_state;
            output_state = get_current_output_state(splitter, i);
            if ((output_state == ACTIVE) || (output_state == HOLD))
84201b38:	58 24       	Null = r1 - 1;
84201b3a:	03 60       	if EQ jump (m) Lc_splitter_metadata_transport_to_internal_40;

84201b3c <Lc_splitter_metadata_transport_to_internal_39>:
84201b3c:	98 24       	Null = r1 - 2;
84201b3e:	04 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_42;

84201b40 <Lc_splitter_metadata_transport_to_internal_40>:
            {
                if (splitter->internal_metadata.head_tag[i] == NULL)
84201b40:	13 e8       	r1 = M[r0 + Null];
84201b42:	02 62       	if NE jump (m) Lc_splitter_metadata_transport_to_internal_42;

84201b44 <Lc_splitter_metadata_transport_to_internal_41>:
                {

                    SPLITTER_MSG2("Splitter: Setting head for out %d head 0x%08x",
                            i, ret_mtag);
                    splitter->internal_metadata.head_tag[i] = ret_mtag;
84201b44:	17 ee       	M[r0 + Null] = r5;

84201b46 <Lc_splitter_metadata_transport_to_internal_42>:
    }

    /* Check if ret_mtag is a new head for any of the output streams. */
    if (ret_mtag != NULL)
    {
        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201b46:	49 20       	rMAC = rMAC + 1;
84201b48:	12 21       	r0 = r0 + 4;

84201b4a <Lc__loop0>:
84201b4a:	74 4c       	SP = SP + -48;
84201b4c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201b4e:	d8 4c       	rts;

84201b50 <$_splitter_metadata_copy>:

/**
 * Copies metadata from the internal buffer to the output buffer.
 */
void splitter_metadata_copy(SPLITTER_OP_DATA *splitter, unsigned* data_to_copy, unsigned data_to_remove)
{
84201b50:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201b52:	13 09       	r9 = r0 + Null;
84201b54:	44 de       	M[FP + 32] = r2;
    tCbuffer *internal;


    /* the internal buffer is the metadata source. */
    internal = get_internal_metadata_buffer(splitter);
    PL_ASSERT(internal != NULL);
84201b56:	b9 f0 15 88 	r7 = M[r9 + 84];
84201b5a:	09 62       	if NE jump (m) Lc_splitter_metadata_copy_3;

84201b5c <Lc_splitter_metadata_copy_2>:
84201b5c:	03 f0 0b 42 	r1 = Null + 523;
84201b60:	02 f0 13 60 	r0 = Null + 4115;
84201b64:	ff fd 91 f0 	call (m) 0x13f12;
84201b68:	2f ed 
84201b6a:	4b 6e       	jump (m) Lc_splitter_metadata_copy_12;

84201b6c <Lc_splitter_metadata_copy_3>:


    /* Save the index value. */
    before_prev_rd_indexes = internal->metadata->prev_rd_index;
84201b6c:	91 f0 06 88 	rMAC = M[r7 + 24];
84201b70:	ca 88       	r0 = M[rMAC + 12];
84201b72:	4a de       	M[FP + 36] = r0;
    before_head_tag = internal->metadata->tags.head;
84201b74:	09 e8       	rMAC = M[rMAC + Null];
84201b76:	51 de       	M[FP + 40] = rMAC;

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201b78:	00 09       	r6 = Null + Null;
84201b7a:	1a 09       	r8 = r1 + Null;
84201b7c:	b7 f0 58 20 	r5 = r9 + 88;

84201b80 <Lc_splitter_metadata_copy_4>:
84201b80:	b1 f0 18 20 	rMAC = r9 + 24;
84201b84:	11 f0 08 e0 	rMAC = MBS[rMAC + r6];
    {
        SPLITTER_OUTPUT_STATE output_state;
        output_state = get_current_output_state(splitter, i);
        if ((data_to_copy[i] != 0) && (output_state == ACTIVE))
84201b88:	a0 f0 00 e8 	Null = M[r8 + Null];
84201b8c:	27 60       	if EQ jump (m) Lc_splitter_metadata_copy_9;

84201b8e <Lc_splitter_metadata_copy_5>:
84201b8e:	48 24       	Null = rMAC - 1;
84201b90:	25 62       	if NE jump (m) Lc_splitter_metadata_copy_9;

84201b92 <Lc_splitter_metadata_copy_6>:
        {
            unsigned dst_data;
            /* Set up the internal buffer read pointers!*/
            output_prev_rd_indexes = splitter->internal_metadata.prev_rd_indexes[i];
84201b92:	3e e8       	r4 = M[r5 + Null];
            internal->metadata->prev_rd_index = output_prev_rd_indexes;
84201b94:	91 f0 06 88 	rMAC = M[r7 + 24];
84201b98:	ce 8e       	M[rMAC + 12] = r4;

            out_head_tag = splitter->internal_metadata.head_tag[i];
84201b9a:	b9 88       	rMAC = M[r5 + 8];
            internal->metadata->tags.head = out_head_tag;
84201b9c:	92 f0 06 88 	r0 = M[r7 + 24];
84201ba0:	11 ee       	M[r0 + Null] = rMAC;

            SPLITTER_MSG4("Splitter: output index %d"
                            "\n read_index before 0x%08x\n head tag 0x%08x\n head index 0x%08x",
                            i, output_prev_rd_indexes, out_head_tag, out_head_tag->index);

            dst_data = data_to_copy[i];
84201ba2:	a1 f0 00 e8 	rMAC = M[r8 + Null];
84201ba6:	59 de       	M[FP + 44] = rMAC;

            out_head_tag = metadata_copy_without_changing_src(
                    internal, get_metadata_buffer(splitter, FALSE, i), dst_data, splitter->tag_size_to_samples);
84201ba8:	03 00       	r1 = Null + Null;
84201baa:	44 08       	r2 = r6 + Null;
84201bac:	5a 08       	r0 = r9 + Null;
84201bae:	fe ff 2f ed 	call (m) $_get_metadata_buffer;
84201bb2:	b3 f0 68 82 	r1 = MBU[r9 + 104];
84201bb6:	5b 50       	r1 = r1 LSHIFT -2;
84201bb8:	1d c0       	r3 = r1 AND 0x1;
84201bba:	13 00       	r1 = r0 + Null;
84201bbc:	4a 08       	r0 = r7 + Null;
84201bbe:	5c d8       	r2 = M[FP + 44];
84201bc0:	55 4e       	call (m) Lc_metadata_copy_without_changing_src_1;

            SPLITTER_MSG1("Splitter will continue from tag 0x%08x",
                    out_head_tag);
            splitter->internal_metadata.head_tag[i] = out_head_tag;
84201bc2:	ba 8e       	M[r5 + 8] = r0;

            /* Calculate the read index of the output metadata. */
            output_prev_rd_indexes += dst_data;
84201bc4:	59 d8       	rMAC = M[FP + 44];
84201bc6:	8e 01       	r4 = rMAC + r4;
            if (output_prev_rd_indexes >= internal->metadata->buffer_size)
84201bc8:	91 f0 06 88 	rMAC = M[r7 + 24];
84201bcc:	4a 89       	r0 = M[rMAC + 20];
84201bce:	d2 51       	r0 = r0 LSHIFT -8;
84201bd0:	91 c6       	rMAC = r0 AND 0xffff;
84201bd2:	70 04       	Null = r4 - rMAC;
84201bd4:	02 64       	if NC jump (m) Lc_splitter_metadata_copy_8;

84201bd6 <Lc_splitter_metadata_copy_7>:
            {
                output_prev_rd_indexes -= internal->metadata->buffer_size;
84201bd6:	76 04       	r4 = r4 - rMAC;

84201bd8 <Lc_splitter_metadata_copy_8>:
            }
            /* Update the read index for the output.*/
            splitter->internal_metadata.prev_rd_indexes[i] = output_prev_rd_indexes;
84201bd8:	3e ee       	M[r5 + Null] = r4;

84201bda <Lc_splitter_metadata_copy_9>:

    /* Save the index value. */
    before_prev_rd_indexes = internal->metadata->prev_rd_index;
    before_head_tag = internal->metadata->tags.head;

    for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201bda:	08 75       	r6 = r6 + 1;
84201bdc:	22 75       	r8 = r8 + 4;
84201bde:	3f 21       	r5 = r5 + 4;
84201be0:	80 f0 02 24 	Null = r6 - 2;
84201be4:	ce 65       	if NC jump (m) Lc_splitter_metadata_copy_4;

84201be6 <Lc_splitter_metadata_copy_10>:
            splitter->internal_metadata.prev_rd_indexes[i] = output_prev_rd_indexes;
        }
    }

    /* restore the index value. */
    internal->metadata->prev_rd_index = before_prev_rd_indexes;
84201be6:	91 f0 06 88 	rMAC = M[r7 + 24];
84201bea:	4a d8       	r0 = M[FP + 36];
84201bec:	ca 8e       	M[rMAC + 12] = r0;
    internal->metadata->tags.head = before_head_tag;
84201bee:	91 f0 06 88 	rMAC = M[r7 + 24];
84201bf2:	52 d8       	r0 = M[FP + 40];
84201bf4:	0a ee       	M[rMAC + Null] = r0;

    if (data_to_remove !=0)
84201bf6:	41 d8       	rMAC = M[FP + 32];
84201bf8:	04 60       	if EQ jump (m) Lc_splitter_metadata_copy_12;

84201bfa <Lc_splitter_metadata_copy_11>:
    {
        remove_metadata_from_internal(splitter, data_to_remove);
84201bfa:	5a 08       	r0 = r9 + Null;
84201bfc:	43 d8       	r1 = M[FP + 32];
84201bfe:	03 4e       	call (m) $_remove_metadata_from_internal;

84201c00 <Lc_splitter_metadata_copy_12>:
    }

}
84201c00:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201c02:	d8 4c       	rts;

84201c04 <$_remove_metadata_from_internal>:

/**
 * Helper function to remove unnecessary data from the internal buffer.
 */
void remove_metadata_from_internal(SPLITTER_OP_DATA *splitter, unsigned data_to_remove)
{
84201c04:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84201c06:	17 00       	r5 = r0 + Null;
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84201c08:	7e a9       	r4 = M[r5 + 84];
    tCbuffer* internal_metadata_buffer = get_internal_metadata_buffer(splitter);

    /* remove the associated metadata too. */
    ret_mtag = buff_metadata_remove(
            internal_metadata_buffer,
            data_to_remove, &b4idx, &afteridx);
84201c0a:	45 11       	r3 = FP + 20;
84201c0c:	04 11       	r2 = FP + 16;
84201c0e:	32 00       	r0 = r4 + Null;
84201c10:	ff fd 80 f0 	call (m) 0x11d7a;
84201c14:	2b eb 
    buff_metadata_tag_list_delete(ret_mtag);
84201c16:	ff fd 7e f0 	call (m) 0x11906;
84201c1a:	31 e7 

    /* Update channels on hold */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
84201c1c:	ba b2       	r0 = MBU[r5 + 26];
84201c1e:	d2 50       	r0 = r0 LSHIFT -4;
84201c20:	91 c0       	rMAC = r0 AND 0x3;
84201c22:	12 60       	if EQ jump (m) Lc__loop1;

84201c24 <Lc_remove_metadata_from_internal_2>:
    {
        unsigned i;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201c24:	01 00       	rMAC = Null + Null;
84201c26:	72 f0 58 20 	r0 = r5 + 88;
84201c2a:	14 71       	r10 = Null + 2;
84201c2c:	0d 4c       	do (m) Lc__loop1;

84201c2e <Lc_remove_metadata_from_internal_3>:
 */
static inline SPLITTER_OUTPUT_STATE get_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    return splitter->output_state[index];
84201c2e:	3b 2a       	r1 = r5 + 24;
84201c30:	5b e0       	r1 = MBS[r1 + rMAC];
        {
            SPLITTER_OUTPUT_STATE output_state;
            output_state = get_current_output_state(splitter, i);
            if (output_state == HOLD)
84201c32:	98 24       	Null = r1 - 2;
84201c34:	07 62       	if NE jump (m) Lc_remove_metadata_from_internal_5;

84201c36 <Lc_remove_metadata_from_internal_4>:
            {
                /* Set up the internal buffer metadata read indexes!*/
                splitter->internal_metadata.prev_rd_indexes[i] = internal_metadata_buffer->metadata->prev_rd_index;
84201c36:	b3 89       	r1 = M[r4 + 24];
84201c38:	db 88       	r1 = M[r1 + 12];
84201c3a:	13 ee       	M[r0 + Null] = r1;
                splitter->internal_metadata.head_tag[i] = internal_metadata_buffer->metadata->tags.head;
84201c3c:	b3 89       	r1 = M[r4 + 24];
84201c3e:	1b e8       	r1 = M[r1 + Null];
84201c40:	93 8e       	M[r0 + 8] = r1;

84201c42 <Lc_remove_metadata_from_internal_5>:
    /* Update channels on hold */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
    {
        unsigned i;

        for (i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201c42:	49 20       	rMAC = rMAC + 1;
84201c44:	12 21       	r0 = r0 + 4;

84201c46 <Lc__loop1>:
84201c46:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84201c48:	d8 4c       	rts;

84201c4a <Lc_convert_tags_length_to_samples_1>:
 * As the name suggests this function converts the tag sizes
 * to samples.
 */
static void convert_tags_length_to_samples(metadata_tag *mtag)
{
    while (mtag != NULL)
84201c4a:	10 04       	Null = r0 - Null;
84201c4c:	06 60       	if EQ jump (m) Lc_convert_tags_length_to_samples_4;

84201c4e <Lc_convert_tags_length_to_samples_3>:
    {
        SPLITTER_DEBUG_INSTR(PL_ASSERT((mtag->length&(OCTETS_PER_SAMPLE-1)) == 0));
        mtag->length = mtag->length/OCTETS_PER_SAMPLE;
84201c4e:	d3 88       	r1 = M[r0 + 12];
84201c50:	5b 50       	r1 = r1 LSHIFT -2;
84201c52:	d3 8e       	M[r0 + 12] = r1;
        mtag = mtag->next;
84201c54:	12 e8       	r0 = M[r0 + Null];
 * As the name suggests this function converts the tag sizes
 * to samples.
 */
static void convert_tags_length_to_samples(metadata_tag *mtag)
{
    while (mtag != NULL)
84201c56:	fa 6f       	jump (m) Lc_convert_tags_length_to_samples_1;

84201c58 <Lc_convert_tags_length_to_samples_4>:
84201c58:	d8 4c       	rts;

84201c5a <Lc_convert_tags_length_to_octets_1>:
 * Just like convert_tags_length_to_samples, but this function transforms
 * the tag sizes to octets.
 */
static void convert_tags_length_to_octets(metadata_tag *mtag)
{
    while (mtag != NULL)
84201c5a:	10 04       	Null = r0 - Null;
84201c5c:	06 60       	if EQ jump (m) Lc_convert_tags_length_to_octets_4;

84201c5e <Lc_convert_tags_length_to_octets_3>:
    {
        mtag->length = mtag->length*OCTETS_PER_SAMPLE;
84201c5e:	d3 88       	r1 = M[r0 + 12];
84201c60:	5b 54       	r1 = r1 LSHIFT 2;
84201c62:	d3 8e       	M[r0 + 12] = r1;
        mtag = mtag->next;
84201c64:	12 e8       	r0 = M[r0 + Null];
 * Just like convert_tags_length_to_samples, but this function transforms
 * the tag sizes to octets.
 */
static void convert_tags_length_to_octets(metadata_tag *mtag)
{
    while (mtag != NULL)
84201c66:	fa 6f       	jump (m) Lc_convert_tags_length_to_octets_1;

84201c68 <Lc_convert_tags_length_to_octets_4>:
84201c68:	d8 4c       	rts;

84201c6a <Lc_metadata_copy_without_changing_src_1>:

/**
 * Copies metadata to the destination without removing it from the source.
 */
static metadata_tag *metadata_copy_without_changing_src(tCbuffer *src, tCbuffer *dest, unsigned data_copied_octets, bool sample_to_octets)
{
84201c6a:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201c6c:	11 09       	r7 = r0 + Null;
84201c6e:	43 de       	M[FP + 32] = r1;
84201c70:	20 09       	r6 = r2 + Null;
84201c72:	46 08       	r4 = r6 + Null;
84201c74:	2b 09       	r9 = r3 + Null;
    metadata_tag *new_tag;
    metadata_tag *tail_tag;
    metadata_tag *head_tag;
    unsigned src_data = data_copied_octets;

    if (sample_to_octets)
84201c76:	03 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_3;

84201c78 <Lc_metadata_copy_without_changing_src_2>:
    {
        /* convert the the sizes to octets. */
        data_copied_octets = data_copied_octets << 2;
84201c78:	01 f8 d8 c8 	r6 = r6 LSHIFT 2;

84201c7c <Lc_metadata_copy_without_changing_src_3>:
    }

    /* Check if we have enough data/space. */
    PL_ASSERT(buff_metadata_available_octets(src) >= src_data);
84201c7c:	ff fd 80 f0 	call (m) 0x11d04;
84201c80:	29 e4 
84201c82:	90 05       	Null = r0 - r4;
84201c84:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_5;

84201c88 <Lc_metadata_copy_without_changing_src_4>:
84201c88:	03 f0 b0 41 	r1 = Null + 432;
84201c8c:	02 f0 13 60 	r0 = Null + 4115;
84201c90:	ff fd 91 f0 	call (m) 0x13f12;
84201c94:	23 e4 
84201c96:	64 6e       	jump (m) Lc_metadata_copy_without_changing_src_26;

84201c98 <Lc_metadata_copy_without_changing_src_5>:
    PL_ASSERT(buff_metadata_available_space(dest) >= data_copied_octets);
84201c98:	42 d8       	r0 = M[FP + 32];
84201c9a:	ff fd 80 f0 	call (m) 0x11d42;
84201c9e:	29 e5 
84201ca0:	8f f2 00 c2 	Null = r0 - r6;
84201ca4:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_7;

84201ca8 <Lc_metadata_copy_without_changing_src_6>:
84201ca8:	03 f0 b1 41 	r1 = Null + 433;
84201cac:	02 f0 13 60 	r0 = Null + 4115;
84201cb0:	ff fd 91 f0 	call (m) 0x13f12;
84201cb4:	23 e3 
84201cb6:	54 6e       	jump (m) Lc_metadata_copy_without_changing_src_26;

84201cb8 <Lc_metadata_copy_without_changing_src_7>:

    /* Transport the metadata to the output buffer. */
    tag_list = buff_metadata_peek_ex(src, &b4idx);
84201cb8:	43 12       	r1 = FP + 36;
84201cba:	4a 08       	r0 = r7 + Null;
84201cbc:	ff fd 80 f0 	call (m) 0x11cd8;
84201cc0:	3d e0 
84201cc2:	17 00       	r5 = r0 + Null;
    SPLITTER_MSG5("Splitter: buff_metadata_available_space(out) %d data_copied %d octets"
            "\n tag_list 0x%08x  tag_list->next 0x%08x b4idx %d octets " ,
            buff_metadata_available_space(dest), data_copied_octets, tag_list, tag_list->next, b4idx);

    /* Check the before index validity */
    if (tag_list != NULL)
84201cc4:	14 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_11;

84201cc6 <Lc_metadata_copy_without_changing_src_8>:
    {
        PL_ASSERT(b4idx < src->metadata->buffer_size);
84201cc6:	49 d8       	rMAC = M[FP + 36];
84201cc8:	92 f0 06 88 	r0 = M[r7 + 24];
84201ccc:	52 89       	r0 = M[r0 + 20];
84201cce:	d2 51       	r0 = r0 LSHIFT -8;
84201cd0:	92 c6       	r0 = r0 AND 0xffff;
84201cd2:	88 04       	Null = rMAC - r0;
84201cd4:	09 64       	if NC jump (m) Lc_metadata_copy_without_changing_src_10;

84201cd6 <Lc_metadata_copy_without_changing_src_9>:
84201cd6:	03 f0 bd 41 	r1 = Null + 445;
84201cda:	02 f0 13 60 	r0 = Null + 4115;
84201cde:	ff fd 91 f0 	call (m) 0x13f12;
84201ce2:	35 e1 
84201ce4:	3d 6e       	jump (m) Lc_metadata_copy_without_changing_src_26;

84201ce6 <Lc_metadata_copy_without_changing_src_10>:
    }

    /* check if we will consume one tag at all?
     * Note: When tag_list is NULL b4idx is not set by buff_metadata_peek_ex */
    if ((tag_list == NULL) || (src_data < b4idx))
84201ce6:	70 04       	Null = r4 - rMAC;
84201ce8:	02 f0 95 e0 	if C jump (m) Lc_metadata_copy_without_changing_src_12;

84201cec <Lc_metadata_copy_without_changing_src_11>:
    {
        /* continuing to consume the previous tag. */
        buff_metadata_append(dest, NULL, 0, data_copied_octets);
84201cec:	04 00       	r2 = Null + Null;
84201cee:	03 00       	r1 = Null + Null;
84201cf0:	45 08       	r3 = r6 + Null;
84201cf2:	42 d8       	r0 = M[FP + 32];
84201cf4:	ff fd 7e f0 	call (m) 0x11adc;
84201cf8:	29 ef 
84201cfa:	31 6e       	jump (m) Lc_metadata_copy_without_changing_src_25;

84201cfc <Lc_metadata_copy_without_changing_src_12>:
        return tag_list;
    }

    /* Decrement the data before the first tag. */
    src_data -= b4idx;
84201cfc:	76 04       	r4 = r4 - rMAC;

    tail_tag = NULL;
84201cfe:	01 09       	r7 = Null + Null;
    head_tag = NULL;
84201d00:	00 09       	r6 = Null + Null;
    afteridx = 0;
84201d02:	02 09       	r8 = Null + Null;

84201d04 <Lc_metadata_copy_without_changing_src_13>:

    while((tag_list != NULL) && (src_data != 0))
84201d04:	30 04       	Null = r4 - Null;
84201d06:	1a 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_22;

84201d08 <Lc_metadata_copy_without_changing_src_14>:
    {

        SPLITTER_MSG2("Splitter tag copy \n tag_list->index 0x%08x \n tag_list->length 0x%08x " ,
                tag_list->index, tag_list->length );

        tag_length = tag_list->length;
84201d08:	f9 88       	rMAC = M[r5 + 12];
        if (src_data <= tag_length)
84201d0a:	70 04       	Null = r4 - rMAC;
84201d0c:	08 f0 8b e0 	if HI jump (m) Lc_metadata_copy_without_changing_src_16;

84201d10 <Lc_metadata_copy_without_changing_src_15>:
        {
            afteridx = src_data;
84201d10:	32 09       	r8 = r4 + Null;
            src_data = 0;
84201d12:	06 00       	r4 = Null + Null;
84201d14:	02 6e       	jump (m) Lc_metadata_copy_without_changing_src_17;

84201d16 <Lc_metadata_copy_without_changing_src_16>:
        }
        else
        {
            src_data -= tag_length;
84201d16:	76 04       	r4 = r4 - rMAC;

84201d18 <Lc_metadata_copy_without_changing_src_17>:
        }
        /* Create a new tag. */
        new_tag = buff_metadata_copy_tag(tag_list);
84201d18:	3a 00       	r0 = r5 + Null;
84201d1a:	ff fd 7e f0 	call (m) 0x1191c;
84201d1e:	23 e0 
        /* Make sure the next pointer is NULL. */
        new_tag->next = NULL;
84201d20:	10 ee       	M[r0 + Null] = Null;
        /* The new tag will be the head if the list is not created yet */
        if (head_tag == NULL)
84201d22:	0f f8 00 c2 	Null = r6 - Null;
84201d26:	02 62       	if NE jump (m) Lc_metadata_copy_without_changing_src_19;

84201d28 <Lc_metadata_copy_without_changing_src_18>:
        {
            head_tag = new_tag;
84201d28:	10 09       	r6 = r0 + Null;

84201d2a <Lc_metadata_copy_without_changing_src_19>:
        }
        /* Add the tag to the end of the tag list. */
        if (tail_tag != NULL)
84201d2a:	0f f9 00 c2 	Null = r7 - Null;
84201d2e:	03 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_21;

84201d30 <Lc_metadata_copy_without_changing_src_20>:
        {
            tail_tag->next = new_tag;
84201d30:	92 f0 00 ee 	M[r7 + Null] = r0;

84201d34 <Lc_metadata_copy_without_changing_src_21>:
        }
        tail_tag = new_tag;
84201d34:	11 09       	r7 = r0 + Null;

    tail_tag = NULL;
    head_tag = NULL;
    afteridx = 0;

    while((tag_list != NULL) && (src_data != 0))
84201d36:	3f e8       	r5 = M[r5 + Null];
84201d38:	e6 63       	if NE jump (m) Lc_metadata_copy_without_changing_src_13;

84201d3a <Lc_metadata_copy_without_changing_src_22>:
        tail_tag = new_tag;

        tag_list = tag_list->next;
    }

    if (sample_to_octets)
84201d3a:	0f fb 00 c2 	Null = r9 - Null;
84201d3e:	08 60       	if EQ jump (m) Lc_metadata_copy_without_changing_src_24;

84201d40 <Lc_metadata_copy_without_changing_src_23>:
    {
        /* convert the the sizes to octets. */
        convert_tags_length_to_octets(head_tag);
84201d40:	42 08       	r0 = r6 + Null;
84201d42:	8c 4f       	call (m) Lc_convert_tags_length_to_octets_1;
        b4idx = b4idx<<2;
84201d44:	4a d8       	r0 = M[FP + 36];
84201d46:	52 54       	r0 = r0 LSHIFT 2;
84201d48:	4a de       	M[FP + 36] = r0;
        afteridx = afteridx<<2;
84201d4a:	01 fa da c8 	r8 = r8 LSHIFT 2;

84201d4e <Lc_metadata_copy_without_changing_src_24>:
    }

    buff_metadata_append(dest, head_tag, b4idx, afteridx);
84201d4e:	4c d8       	r2 = M[FP + 36];
84201d50:	55 08       	r3 = r8 + Null;
84201d52:	43 08       	r1 = r6 + Null;
84201d54:	42 d8       	r0 = M[FP + 32];
84201d56:	ff fd 7e f0 	call (m) 0x11adc;
84201d5a:	27 ec 

84201d5c <Lc_metadata_copy_without_changing_src_25>:
     * Note: When tag_list is NULL b4idx is not set by buff_metadata_peek_ex */
    if ((tag_list == NULL) || (src_data < b4idx))
    {
        /* continuing to consume the previous tag. */
        buff_metadata_append(dest, NULL, 0, data_copied_octets);
        return tag_list;
84201d5c:	3a 00       	r0 = r5 + Null;

84201d5e <Lc_metadata_copy_without_changing_src_26>:
        afteridx = afteridx<<2;
    }

    buff_metadata_append(dest, head_tag, b4idx, afteridx);
    return tag_list;
}
84201d5e:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201d60:	d8 4c       	rts;

84201d62 <$_splitter_timer_task>:
84201d62:	f1 1c       	pushm <FP(=SP), r4, rLink>;
 * This prevents a stall when buffers fill up
 *
 * \param timer_data Pointer to the operator instance data.
 */
void splitter_timer_task(void *timer_data)
{
84201d64:	16 00       	r4 = r0 + Null;
/**
 * Returns the splitter instance from an operator data.
 */
static inline SPLITTER_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (SPLITTER_OP_DATA *) base_op_get_instance_data(op_data);
84201d66:	02 f0 21 e4 	call (m) $_base_op_get_instance_data;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) timer_data;
    SPLITTER_OP_DATA *splitter = get_instance_data(op_data);

    splitter->self_kick_timer = TIMER_ID_INVALID;
84201d6a:	50 9e       	M[r0 + 36] = Null;
84201d6c:	b2 88       	r0 = M[r4 + 8];
84201d6e:	ff fd 94 f0 	call (m) 0x14766;
84201d72:	39 ef 

84201d74 <Lc_splitter_timer_task_2>:
    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
}
84201d74:	f1 48       	popm <FP, r4, rLink>;
84201d76:	d8 4c       	rts;

84201d78 <$_get_terminal_info>:
 * \param save_buffer If true, the input buffer will be saved into the terminal info.
 *
 * \return TRUE if the call is correct, FALSE otherwise.
 */
bool get_terminal_info(unsigned terminal_id, tCbuffer *buffer, terminal_info_t *terminal_info, bool save_buffer)
{
84201d78:	c8 1c       	pushm <FP(=SP), rLink>;
84201d7a:	19 00       	rMAC = r1 + Null;
    terminal_info->terminal_num = terminal_id & TERMINAL_NUM_MASK;
84201d7c:	93 c2       	r1 = r0 AND 0x3f;
84201d7e:	a3 8e       	M[r2 + 8] = r1;
    terminal_info->is_input = terminal_id & TERMINAL_SINK_MASK;
84201d80:	40 f0 22 f0 	r0 = r0 AND 0x800000;
84201d84:	00 00 
84201d86:	62 8e       	M[r2 + 4] = r0;

    if(save_buffer)
84201d88:	28 04       	Null = r3 - Null;
84201d8a:	02 60       	if EQ jump (m) Lc_get_terminal_info_3;

84201d8c <Lc_get_terminal_info_2>:
    {
        terminal_info->buffer = buffer;
84201d8c:	21 8f       	M[r2 + 16] = rMAC;

84201d8e <Lc_get_terminal_info_3>:
    }

    if (terminal_info->is_input)
84201d8e:	10 04       	Null = r0 - Null;
84201d90:	0e 60       	if EQ jump (m) Lc_get_terminal_info_7;

84201d92 <Lc_get_terminal_info_4>:
    {
        if (terminal_info->terminal_num >= SPLITTER_MAX_INPUTS)
84201d92:	18 25       	Null = r1 - 4;
84201d94:	09 64       	if NC jump (m) Lc_get_terminal_info_6;

84201d96 <Lc_get_terminal_info_5>:
        {
            SPLITTER_ERRORMSG1("Splitter: Incorrect terminal number %4d!", terminal_info->terminal_num);
84201d96:	55 f1 02 f0 	r0 = Null + 357568135;
84201d9a:	87 5a 
84201d9c:	ef fd f6 ff 	call (m) 0x9b4;
84201da0:	39 e0 
            return FALSE;
84201da2:	02 00       	r0 = Null + Null;
84201da4:	0c 6e       	jump (m) Lc_get_terminal_info_10;

84201da6 <Lc_get_terminal_info_6>:
        }
        /* For input terminals the channel id is equal to the terminal ID. */
        terminal_info->channel_id = terminal_info->terminal_num;
84201da6:	23 ee       	M[r2 + Null] = r1;
        /* Input index is always 0 . */
        terminal_info->index = 0;
84201da8:	e0 8e       	M[r2 + 12] = Null;
84201daa:	08 6e       	jump (m) Lc_get_terminal_info_9;

84201dac <Lc_get_terminal_info_7>:
    }
    else
    {
        if (terminal_info->terminal_num >= SPLITTER_MAX_OUTPUTS)
84201dac:	18 26       	Null = r1 - 8;
84201dae:	f2 ff e9 ef 	if C jump (m) Lc_get_terminal_info_5;

84201db2 <Lc_get_terminal_info_8>:
            SPLITTER_ERRORMSG1("Splitter: Incorrect terminal number %4d!", terminal_info->terminal_num);
            return FALSE;
        }
        /* For outp terminals the channel id is the terminal ID shifted
         * with the number of outputs. */
        terminal_info->channel_id = terminal_info->terminal_num >> 1;
84201db2:	1a 50       	r0 = r1 LSHIFT -1;
84201db4:	22 ee       	M[r2 + Null] = r0;

        terminal_info->index = terminal_info->terminal_num & 1;
84201db6:	19 c0       	rMAC = r1 AND 0x1;
84201db8:	e1 8e       	M[r2 + 12] = rMAC;

84201dba <Lc_get_terminal_info_9>:
    }

    return TRUE;
84201dba:	42 20       	r0 = Null + 1;

84201dbc <Lc_get_terminal_info_10>:
}
84201dbc:	c8 48       	popm <FP, rLink>;
84201dbe:	d8 4c       	rts;

84201dc0 <$_set_cbuffer_functions>:
 */
void set_cbuffer_functions(SPLITTER_OP_DATA *splitter)
{
#ifdef INSTALL_CBUFFER_EX

    if ((splitter->data_format == AUDIO_DATA_FORMAT_FIXP) || (splitter->data_format == AUDIO_DATA_FORMAT_FIXP_WITH_METADATA))
84201dc0:	d1 88       	rMAC = M[r0 + 12];
84201dc2:	48 24       	Null = rMAC - 1;
84201dc4:	03 60       	if EQ jump (m) Lc_set_cbuffer_functions_3;

84201dc6 <Lc_set_cbuffer_functions_2>:
84201dc6:	c8 24       	Null = rMAC - 3;
84201dc8:	56 62       	if NE jump (m) Lc_set_cbuffer_functions_7;

84201dca <Lc_set_cbuffer_functions_3>:
    {

        if (splitter->packing == UNPACKED)
84201dca:	91 81       	rMAC = MBS[r0 + 6];
84201dcc:	25 62       	if NE jump (m) Lc_set_cbuffer_functions_5;

84201dce <Lc_set_cbuffer_functions_4>:
        {
            /* Just copy the audio*/
            splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_in_words;
84201dce:	61 f1 b7 41 	rMAC = Null + 180663;
84201dd2:	d1 be       	M[r0 + 108] = rMAC;
            splitter->cbuffer.data = cbuffer_calc_amount_data_in_words;
84201dd4:	63 f1 09 42 	r1 = Null + 180745;
84201dd8:	13 bf       	M[r0 + 112] = r1;

            splitter->cbuffer.packed_space = cbuffer_calc_amount_space_in_words;
84201dda:	51 bf       	M[r0 + 116] = rMAC;
            splitter->cbuffer.pack = cbuffer_copy;
84201ddc:	61 f1 cf 48 	rMAC = Null + 181455;
84201de0:	91 bf       	M[r0 + 120] = rMAC;
            splitter->cbuffer.unpack = cbuffer_copy;
84201de2:	d1 bf       	M[r0 + 124] = rMAC;
            splitter->cbuffer.discard = cbuffer_advance_read_ptr;
84201de4:	61 f1 17 42 	rMAC = Null + 180759;
84201de8:	21 f0 20 8e 	M[r0 + 128] = rMAC;
#ifdef SPLITTER_EXT_BUFFER
            splitter->cbuffer.sram_packed_space = audio_ext_buffer_amount_space;
84201dec:	42 f0 11 f0 	rMAC = Null + 69214549;
84201df0:	55 41 
84201df2:	21 f0 21 8e 	M[r0 + 132] = rMAC;
            splitter->cbuffer.sram_pack = audio_ext_buffer_circ_write;
84201df6:	42 f0 11 f0 	rMAC = Null + 69214571;
84201dfa:	6b 41 
84201dfc:	21 f0 22 8e 	M[r0 + 136] = rMAC;
            splitter->cbuffer.sram_unpack = audio_ext_buffer_circ_read;
84201e00:	42 f0 11 f0 	rMAC = Null + 69214559;
84201e04:	5f 41 
84201e06:	21 f0 23 8e 	M[r0 + 140] = rMAC;
            splitter->cbuffer.sram_discard = audio_ext_buffer_discard_data;
84201e0a:	42 f0 11 f0 	rMAC = Null + 69214529;
84201e0e:	41 41 
84201e10:	21 f0 24 8e 	M[r0 + 144] = rMAC;
84201e14:	2c 6e       	jump (m) Lc_set_cbuffer_functions_6;

84201e16 <Lc_set_cbuffer_functions_5>:
            return;
        }
        else
        {
            /* Pack the audio. */
            splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_in_words;
84201e16:	61 f1 b7 41 	rMAC = Null + 180663;
84201e1a:	d1 be       	M[r0 + 108] = rMAC;
            splitter->cbuffer.data = cbuffer_calc_amount_data_in_words;
84201e1c:	61 f1 09 42 	rMAC = Null + 180745;
84201e20:	11 bf       	M[r0 + 112] = rMAC;

            splitter->cbuffer.packed_space = packed_space;
84201e22:	42 f0 11 f0 	rMAC = Null + 69214509;
84201e26:	2d 41 
84201e28:	51 bf       	M[r0 + 116] = rMAC;
            splitter->cbuffer.pack = pack_audio; /* cbuffer_copy_ex will pack the data when needed because it know about the usable octets.*/
84201e2a:	42 f0 11 f0 	rMAC = Null + 69214447;
84201e2e:	ef 40 
84201e30:	91 bf       	M[r0 + 120] = rMAC;
            splitter->cbuffer.unpack = un_pack_audio; /* same applies for unpacking. */
84201e32:	42 f0 11 f0 	rMAC = Null + 69214373;
84201e36:	a5 40 
84201e38:	d1 bf       	M[r0 + 124] = rMAC;
            splitter->cbuffer.discard = advance_packed;
84201e3a:	42 f0 11 f0 	rMAC = Null + 69214499;
84201e3e:	23 41 
84201e40:	21 f0 20 8e 	M[r0 + 128] = rMAC;
#ifdef SPLITTER_EXT_BUFFER
            splitter->cbuffer.sram_packed_space = pack_ext_buffer_amount_space;
84201e44:	42 f0 11 f0 	rMAC = Null + 69214539;
84201e48:	4b 41 
84201e4a:	21 f0 21 8e 	M[r0 + 132] = rMAC;
            splitter->cbuffer.sram_pack = ext_buffer_pack;
84201e4e:	42 f0 11 f0 	rMAC = Null + 69215033;
84201e52:	39 43 
84201e54:	21 f0 22 8e 	M[r0 + 136] = rMAC;
            splitter->cbuffer.sram_unpack = ext_buffer_unpack;
84201e58:	42 f0 11 f0 	rMAC = Null + 69215051;
84201e5c:	4b 43 
84201e5e:	21 f0 23 8e 	M[r0 + 140] = rMAC;
            splitter->cbuffer.sram_discard = pack_ext_buffer_discard_data;
84201e62:	42 f0 11 f0 	rMAC = Null + 69214519;
84201e66:	37 41 
84201e68:	21 f0 24 8e 	M[r0 + 144] = rMAC;

84201e6c <Lc_set_cbuffer_functions_6>:
            splitter->cbuffer.sram_packed_space = audio_ext_buffer_amount_space;
            splitter->cbuffer.sram_pack = audio_ext_buffer_circ_write;
            splitter->cbuffer.sram_unpack = audio_ext_buffer_circ_read;
            splitter->cbuffer.sram_discard = audio_ext_buffer_discard_data;
#endif
            splitter->cbuffer.data_size = 4;
84201e6c:	01 21       	rMAC = Null + 4;
84201e6e:	21 f0 25 8e 	M[r0 + 148] = rMAC;
84201e72:	2b 6e       	jump (m) Lc_set_cbuffer_functions_8;

84201e74 <Lc_set_cbuffer_functions_7>:
            return;
        }
    }
    /* Data will be packed and unpacked if the
     * usable octets are different. */
    splitter->cbuffer.unpacked_space = cbuffer_calc_amount_space_ex;
84201e74:	42 f0 11 f0 	rMAC = Null + 69214799;
84201e78:	4f 42 
84201e7a:	d1 be       	M[r0 + 108] = rMAC;
    splitter->cbuffer.data = cbuffer_calc_amount_data_ex;
84201e7c:	42 f0 13 f0 	r1 = Null + 69214781;
84201e80:	3d 42 
84201e82:	13 bf       	M[r0 + 112] = r1;

    splitter->cbuffer.packed_space = cbuffer_calc_amount_space_ex;
84201e84:	51 bf       	M[r0 + 116] = rMAC;
    splitter->cbuffer.pack = cbuffer_copy_ex; /* cbuffer_copy_ex will pack the data when needed because it know about the usable octets.*/
84201e86:	42 f0 11 f0 	rMAC = Null + 69214709;
84201e8a:	f5 41 
84201e8c:	91 bf       	M[r0 + 120] = rMAC;
    splitter->cbuffer.unpack = cbuffer_copy_ex; /* same applies for unpacking. */
84201e8e:	d1 bf       	M[r0 + 124] = rMAC;
    splitter->cbuffer.discard = cbuffer_advance_read_ptr_ex;
84201e90:	42 f0 11 f0 	rMAC = Null + 69214835;
84201e94:	73 42 
84201e96:	21 f0 20 8e 	M[r0 + 128] = rMAC;
#ifdef SPLITTER_EXT_BUFFER
    splitter->cbuffer.sram_packed_space = ext_buffer_amount_space;
84201e9a:	42 f0 11 f0 	rMAC = Null + 69214925;
84201e9e:	cd 42 
84201ea0:	21 f0 21 8e 	M[r0 + 132] = rMAC;
    splitter->cbuffer.sram_pack = ext_buffer_circ_write;
84201ea4:	42 f0 11 f0 	rMAC = Null + 69214961;
84201ea8:	f1 42 
84201eaa:	21 f0 22 8e 	M[r0 + 136] = rMAC;
    splitter->cbuffer.sram_unpack = ext_buffer_circ_read;
84201eae:	42 f0 11 f0 	rMAC = Null + 69214943;
84201eb2:	df 42 
84201eb4:	21 f0 23 8e 	M[r0 + 140] = rMAC;
    splitter->cbuffer.sram_discard = ext_buffer_discard_data;
84201eb8:	42 f0 11 f0 	rMAC = Null + 69215015;
84201ebc:	27 43 
84201ebe:	21 f0 24 8e 	M[r0 + 144] = rMAC;
#endif
    splitter->cbuffer.data_size = 1;
84201ec2:	41 20       	rMAC = Null + 1;
84201ec4:	21 f0 25 8e 	M[r0 + 148] = rMAC;

84201ec8 <Lc_set_cbuffer_functions_8>:
84201ec8:	d8 4c       	rts;

84201eca <$_get_channel_struct>:

/**
 * Returns the channel with the given ID. If the channel is not present it will create it.
 */
SPLITTER_CHANNEL_STRUC *get_channel_struct(SPLITTER_OP_DATA *splitter, unsigned channel_id)
{
84201eca:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201ecc:	16 00       	r4 = r0 + Null;
84201ece:	1f 00       	r5 = r1 + Null;
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
84201ed0:	32 e8       	r0 = M[r4 + Null];
84201ed2:	02 6e       	jump (m) Lc_get_channel_struct_3;

84201ed4 <Lc_get_channel_struct_2>:
    {
        if (channel->id == channel_id)
        {
            return channel;
        }
        channel = channel->next;
84201ed4:	12 e8       	r0 = M[r0 + Null];

84201ed6 <Lc_get_channel_struct_3>:
 * Returns the channel with the given ID. If the channel is not present it will create it.
 */
SPLITTER_CHANNEL_STRUC *get_channel_struct(SPLITTER_OP_DATA *splitter, unsigned channel_id)
{
    SPLITTER_CHANNEL_STRUC *channel = splitter->channel_list;
    while (channel != NULL)
84201ed6:	10 04       	Null = r0 - Null;
84201ed8:	05 60       	if EQ jump (m) Lc_get_channel_struct_6;

84201eda <Lc_get_channel_struct_4>:
    {
        if (channel->id == channel_id)
84201eda:	51 88       	rMAC = M[r0 + 4];
84201edc:	c8 05       	Null = rMAC - r5;
84201ede:	fb 63       	if NE jump (m) Lc_get_channel_struct_2;

84201ee0 <Lc_get_channel_struct_5>:
        {
            return channel;
84201ee0:	1b 6e       	jump (m) Lc_get_channel_struct_15;

84201ee2 <Lc_get_channel_struct_6>:
        }
        channel = channel->next;
    }

    if(splitter->buffer_size == 0)
84201ee2:	b0 88       	Null = M[r4 + 8];
84201ee4:	09 62       	if NE jump (m) Lc_get_channel_struct_8;

84201ee6 <Lc_get_channel_struct_7>:
    {
        SPLITTER_ERRORMSG("Splitter: Internal buffer size not set cannot connect!" );
84201ee6:	55 f1 02 f0 	r0 = Null + 357568478;
84201eea:	de 5b 
84201eec:	ef fd f5 ff 	call (m) 0x9a2;
84201ef0:	37 e5 
        return NULL;
84201ef2:	02 00       	r0 = Null + Null;
84201ef4:	11 6e       	jump (m) Lc_get_channel_struct_15;

84201ef6 <Lc_get_channel_struct_8>:
 * Helper function to get the metadata buffer for the internal buffer.
 */
static inline tCbuffer* get_internal_metadata_buffer(SPLITTER_OP_DATA *splitter)
{
    /* Couldn't find anything. */
    return splitter->internal_metadata.buffer;
84201ef6:	73 a9       	r1 = M[r4 + 84];
    }

    /* Create a new channel with the id. */
#ifdef INSTALL_METADATA
    channel = create_channel(splitter, get_internal_metadata_buffer(splitter));
84201ef8:	32 00       	r0 = r4 + Null;
84201efa:	64 4e       	call (m) Lc_create_channel_1;
#else
    channel = create_channel(splitter, NULL);
#endif

    if (channel != NULL)
84201efc:	10 04       	Null = r0 - Null;
84201efe:	f1 61       	if EQ jump (m) Lc_get_channel_struct_5;

84201f00 <Lc_get_channel_struct_9>:
    {
        /* Set the channel ID*/
        channel->id = channel_id;
84201f00:	57 8e       	M[r0 + 4] = r5;
        /* Add the channel to the channel list. */
        if (splitter->channel_list == NULL)
84201f02:	31 e8       	rMAC = M[r4 + Null];
84201f04:	03 62       	if NE jump (m) Lc_get_channel_struct_11;

84201f06 <Lc_get_channel_struct_10>:
        {
            /* First Channel. */
            splitter->channel_list = channel;
84201f06:	32 ee       	M[r4 + Null] = r0;
84201f08:	ec 6f       	jump (m) Lc_get_channel_struct_5;

84201f0a <Lc_get_channel_struct_11>:
        }
        else
        {
            /* Add the channel to the end of the list. */
            SPLITTER_CHANNEL_STRUC *temp_channel = splitter->channel_list;
            while (temp_channel->next != NULL)
84201f0a:	0b e8       	r1 = M[rMAC + Null];
84201f0c:	03 60       	if EQ jump (m) Lc_get_channel_struct_14;

84201f0e <Lc_get_channel_struct_13>:
            {
                temp_channel = temp_channel->next;
84201f0e:	19 00       	rMAC = r1 + Null;
84201f10:	fd 6f       	jump (m) Lc_get_channel_struct_11;

84201f12 <Lc_get_channel_struct_14>:
            }
            temp_channel->next = channel;
84201f12:	0a ee       	M[rMAC + Null] = r0;
84201f14:	e6 6f       	jump (m) Lc_get_channel_struct_5;

84201f16 <Lc_get_channel_struct_15>:
        }
    }
    return channel;
}
84201f16:	f2 48       	popm <FP, r4, r5, rLink>;
84201f18:	d8 4c       	rts;

84201f1a <$_delete_disconnected_channel>:

/**
 * Removes and deletes the disconnected channels.
 */
void delete_disconnected_channel(SPLITTER_OP_DATA *splitter)
{
84201f1a:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201f1c:	16 00       	r4 = r0 + Null;
    SPLITTER_CHANNEL_STRUC **channel_ptr = &splitter->channel_list;
84201f1e:	30 09       	r6 = r4 + Null;

84201f20 <Lc_delete_disconnected_channel_2>:
    while (*channel_ptr != NULL)
84201f20:	87 f0 00 e8 	r5 = M[r6 + Null];
84201f24:	19 60       	if EQ jump (m) Lc_delete_disconnected_channel_11;

84201f26 <Lc_delete_disconnected_channel_3>:
84201f26:	b9 88       	rMAC = M[r5 + 8];
84201f28:	14 62       	if NE jump (m) Lc_delete_disconnected_channel_10;

84201f2a <Lc_delete_disconnected_channel_4>:
84201f2a:	3a 23       	r0 = r5 + 12;
        {
            channel_disconnected = FALSE;
        }
        else
        {
            for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201f2c:	01 00       	rMAC = Null + Null;

84201f2e <Lc_delete_disconnected_channel_5>:
            {
                if ((*channel_ptr)->output_buffer[i] != NULL)
84201f2e:	13 e8       	r1 = M[r0 + Null];
84201f30:	10 62       	if NE jump (m) Lc_delete_disconnected_channel_10;

84201f32 <Lc_delete_disconnected_channel_6>:
        {
            channel_disconnected = FALSE;
        }
        else
        {
            for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
84201f32:	49 20       	rMAC = rMAC + 1;
84201f34:	12 21       	r0 = r0 + 4;
84201f36:	88 24       	Null = rMAC - 2;
84201f38:	fb 69       	if LT jump (m) Lc_delete_disconnected_channel_5;

84201f3a <Lc_delete_disconnected_channel_7>:
        if (channel_disconnected)
        {
            SPLITTER_CHANNEL_STRUC *temp = *channel_ptr;

            /* Remove it from the list, */
            *channel_ptr = temp->next;
84201f3a:	39 e8       	rMAC = M[r5 + Null];
84201f3c:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            /* Delete the metadata if this is the last channel. */
            if (splitter->channel_list == NULL)
84201f40:	31 e8       	rMAC = M[r4 + Null];
84201f42:	04 62       	if NE jump (m) Lc_delete_disconnected_channel_9;

84201f44 <Lc_delete_disconnected_channel_8>:
            {
#ifdef INSTALL_METADATA
                delete_internal_metadata(splitter);
84201f44:	32 00       	r0 = r4 + Null;
84201f46:	fc ff 3f ef 	call (m) $_delete_internal_metadata;

84201f4a <Lc_delete_disconnected_channel_9>:
#endif
            }
            /* Delete the channel. */
            delete_channel(splitter, temp);
84201f4a:	3b 00       	r1 = r5 + Null;
84201f4c:	32 00       	r0 = r4 + Null;
84201f4e:	97 4e       	call (m) Lc_delete_channel_1;

84201f50 <Lc_delete_disconnected_channel_10>:
        }

        channel_ptr = &((*channel_ptr)->next);
84201f50:	88 f0 00 e8 	r6 = M[r6 + Null];
 * Removes and deletes the disconnected channels.
 */
void delete_disconnected_channel(SPLITTER_OP_DATA *splitter)
{
    SPLITTER_CHANNEL_STRUC **channel_ptr = &splitter->channel_list;
    while (*channel_ptr != NULL)
84201f54:	e6 6f       	jump (m) Lc_delete_disconnected_channel_2;

84201f56 <Lc_delete_disconnected_channel_11>:
            delete_channel(splitter, temp);
        }

        channel_ptr = &((*channel_ptr)->next);
    }
}
84201f56:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201f58:	d8 4c       	rts;

84201f5a <Lc_create_internal_data_buffer_1>:

/**
 * Allocates the buffering buffer. The buffer can be internal or external (SRAM).
 */
static bool create_internal_data_buffer(SPLITTER_OP_DATA *splitter, unsigned buffer_size, data_buffer_t* internal_buff)
{
84201f5a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201f5c:	1d 00       	r3 = r1 + Null;
84201f5e:	26 00       	r4 = r2 + Null;
    if ((buffer_size>>14) != 0)
84201f60:	6b 52       	r1 = r3 LSHIFT -14;
84201f62:	09 60       	if EQ jump (m) Lc_create_internal_data_buffer_3;

84201f64 <Lc_create_internal_data_buffer_2>:
    {
        SPLITTER_ERRORMSG1("splitter: Cannot create a buffer bigger than 16383 words or 65535 octets."
                "\n  Current buffer size is %d. Note when packing the buffer size is halved!", buffer_size);
84201f64:	55 f1 02 f0 	r0 = Null + 357568176;
84201f68:	b0 5a 
84201f6a:	2b 00       	r1 = r3 + Null;
84201f6c:	ef fd f5 ff 	call (m) 0x9b4;
84201f70:	29 e2 
84201f72:	18 6e       	jump (m) Lc_create_internal_data_buffer_8;

84201f74 <Lc_create_internal_data_buffer_3>:
        return FALSE;
    }
    if (splitter->location == INTERNAL)
84201f74:	51 81       	rMAC = MBS[r0 + 5];
84201f76:	0a 62       	if NE jump (m) Lc_create_internal_data_buffer_6;

84201f78 <Lc_create_internal_data_buffer_4>:
    {
        tCbuffer *buffer;
        buffer = cbuffer_create_with_malloc(buffer_size, BUF_DESC_SW_BUFFER);
84201f78:	03 00       	r1 = Null + Null;
84201f7a:	2a 00       	r0 = r3 + Null;
84201f7c:	ff fd 84 f0 	call (m) 0x12790;
84201f80:	35 e0 
        SPLITTER_MSG1("splitter: Internal cbuffer 0x%08x", buffer);
        internal_buff->dsp = buffer;
        if (buffer != NULL)
84201f82:	32 ee       	M[r4 + Null] = r0;
84201f84:	09 60       	if EQ jump (m) Lc_create_internal_data_buffer_7;

84201f86 <Lc_create_internal_data_buffer_5>:
        {
            return TRUE;
84201f86:	42 20       	r0 = Null + 1;
84201f88:	0e 6e       	jump (m) Lc_create_internal_data_buffer_9;

84201f8a <Lc_create_internal_data_buffer_6>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        EXT_BUFFER *buffer;
        buffer = ext_buffer_create(buffer_size, 0);
84201f8a:	03 00       	r1 = Null + Null;
84201f8c:	2a 00       	r0 = r3 + Null;
84201f8e:	01 f0 3b e8 	call (m) $_ext_buffer_create;
        /* Allocate the memory on the external SRAM */
        SPLITTER_MSG1("splitter: Internal SRAM buffer 0x%08x", internal_buff);
        internal_buff->sram = buffer;
        if (buffer != NULL)
84201f92:	32 ee       	M[r4 + Null] = r0;
84201f94:	f9 63       	if NE jump (m) Lc_create_internal_data_buffer_5;

84201f96 <Lc_create_internal_data_buffer_7>:
        {
            return TRUE;
        }
#endif
    }
    SPLITTER_ERRORMSG("splitter: Could not create the internal buffer.");
84201f96:	55 f1 02 f0 	r0 = Null + 357568324;
84201f9a:	44 5b 
84201f9c:	ef fd f5 ff 	call (m) 0x9a2;
84201fa0:	27 e0 

84201fa2 <Lc_create_internal_data_buffer_8>:
{
    if ((buffer_size>>14) != 0)
    {
        SPLITTER_ERRORMSG1("splitter: Cannot create a buffer bigger than 16383 words or 65535 octets."
                "\n  Current buffer size is %d. Note when packing the buffer size is halved!", buffer_size);
        return FALSE;
84201fa2:	02 00       	r0 = Null + Null;

84201fa4 <Lc_create_internal_data_buffer_9>:
        }
#endif
    }
    SPLITTER_ERRORMSG("splitter: Could not create the internal buffer.");
    return FALSE;
}
84201fa4:	f1 48       	popm <FP, r4, rLink>;
84201fa6:	d8 4c       	rts;

84201fa8 <Lc_destroy_internal_data_buffer_1>:

#ifdef INSTALL_METADATA
static void destroy_internal_data_buffer(SPLITTER_OP_DATA *splitter, data_buffer_t* internal_buff)
{
84201fa8:	c8 1c       	pushm <FP(=SP), rLink>;
    /* delete the internal metadata buffer allocated for the channel. */
    if (splitter->location == INTERNAL)
84201faa:	51 81       	rMAC = MBS[r0 + 5];
84201fac:	06 62       	if NE jump (m) Lc_destroy_internal_data_buffer_3;

84201fae <Lc_destroy_internal_data_buffer_2>:
    {
        /* delete the internal buffer allocated for the channel. */
        cbuffer_destroy(internal_buff->dsp);
84201fae:	1a e8       	r0 = M[r1 + Null];
84201fb0:	ff fd 84 f0 	call (m) 0x12802;
84201fb4:	33 e2 
84201fb6:	04 6e       	jump (m) Lc_destroy_internal_data_buffer_4;

84201fb8 <Lc_destroy_internal_data_buffer_3>:
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        ext_buffer_destroy(internal_buff->sram);
84201fb8:	1a e8       	r0 = M[r1 + Null];
84201fba:	01 f0 21 e8 	call (m) $_ext_buffer_destroy;

84201fbe <Lc_destroy_internal_data_buffer_4>:
#else
        PL_ASSERT(splitter->location == INTERNAL);
#endif
    }
}
84201fbe:	c8 48       	popm <FP, rLink>;
84201fc0:	d8 4c       	rts;

84201fc2 <Lc_create_channel_1>:

/**
 * Helper function which creates a channel.
 */
static SPLITTER_CHANNEL_STRUC *create_channel(SPLITTER_OP_DATA *splitter, tCbuffer* internal_metadata_buff)
{
84201fc2:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84201fc4:	16 00       	r4 = r0 + Null;
84201fc6:	19 09       	r7 = r1 + Null;


    SPLITTER_MSG("Splitter: Creating internal buffer.");

    /* Allocate the channel buffer structure. */
    channel = xzpnew(SPLITTER_CHANNEL_STRUC);
84201fc8:	c3 20       	r1 = Null + 3;
84201fca:	02 30       	r0 = Null + 32;
84201fcc:	ff fd 17 f0 	call (m) 0x4f2a;
84201fd0:	3f ea 
84201fd2:	10 09       	r6 = r0 + Null;
    if (channel == NULL)
84201fd4:	09 62       	if NE jump (m) Lc_create_channel_4;

84201fd6 <Lc_create_channel_2>:
    {
        SPLITTER_ERRORMSG("Splitter: Unable to allocate CHANNEL_STRUC!" );
84201fd6:	55 f1 02 f0 	r0 = Null + 357568372;
84201fda:	74 5b 
84201fdc:	ef fd f4 ff 	call (m) 0x9a2;
84201fe0:	27 ee 

84201fe2 <Lc_create_channel_3>:
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
            /* Free up the channel structure.*/
            pdelete(channel);
            return FALSE;
84201fe2:	02 00       	r0 = Null + Null;
84201fe4:	4a 6e       	jump (m) Lc_create_channel_22;

84201fe6 <Lc_create_channel_4>:
    {
        SPLITTER_ERRORMSG("Splitter: Unable to allocate CHANNEL_STRUC!" );
        return NULL;
    }
    /* No need to allocate internal buffer when in cloning mode. */
    if (splitter->working_mode == CLONE_BUFFER)
84201fe6:	31 81       	rMAC = MBS[r4 + 4];
84201fe8:	26 60       	if EQ jump (m) Lc__loop0;

84201fea <Lc_create_channel_5>:
    {
        return channel;
    }

    /* If the data is packed we only need half of the buffer. */
    if (splitter->packing == PACKED)
84201fea:	b1 81       	rMAC = MBS[r4 + 6];
84201fec:	48 24       	Null = rMAC - 1;
84201fee:	25 62       	if NE jump (m) Lc_create_channel_15;

84201ff0 <Lc_create_channel_6>:
    {
        buffer_size = splitter->buffer_size/2;
84201ff0:	b2 88       	r0 = M[r4 + 8];
84201ff2:	17 50       	r5 = r0 LSHIFT -1;
84201ff4:	23 6e       	jump (m) Lc_create_channel_16;

84201ff6 <Lc_create_channel_7>:
            return FALSE;
        }
    }
#endif
    /* Finally, set the channel's internal buffer. */
    channel->internal.buffer = internal_buff;
84201ff6:	81 11       	rMAC = FP + 24;
84201ff8:	82 f0 14 20 	r0 = r6 + 20;
84201ffc:	0b e8       	r1 = M[rMAC + Null];
84201ffe:	13 ee       	M[r0 + Null] = r1;

    /* Transition to hold is instant. No need to have an output buffer. */
    if (splitter->hold_streams != OUT_STREAM__0_OFF__1_OFF)
84202000:	b2 b2       	r0 = MBU[r4 + 26];
84202002:	d2 50       	r0 = r0 LSHIFT -4;
84202004:	91 c0       	rMAC = r0 AND 0x3;
84202006:	17 60       	if EQ jump (m) Lc__loop0;

84202008 <Lc_create_channel_8>:
84202008:	84 20       	r2 = Null + 2;
    {
        unsigned i;
        for(i=0; i<SPLITTER_MAX_OUTPUTS_PER_CHANNEL; i++)
8420200a:	01 00       	rMAC = Null + Null;
8420200c:	14 71       	r10 = Null + 2;
8420200e:	13 4c       	do (m) Lc__loop0;

84202010 <Lc_create_channel_9>:
{
    unsigned channel_mask;
    SPLITTER_DEBUG_INSTR(PL_ASSERT(check_next_output_state_validity(splitter)));
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    channel_mask = 1<<index;
84202010:	0a 00       	r0 = rMAC + Null;
84202012:	00 f2 92 de 	r0 = 0x1 LSHIFT r0;
    if (splitter->active_streams & channel_mask)
84202016:	b3 b2       	r1 = MBU[r4 + 26];
84202018:	9d 10       	r3 = r1 AND r0;
8420201a:	ad c0       	r3 = r3 AND 0x3;
8420201c:	0b 62       	if NE jump (m) Lc_create_channel_13;

8420201e <Lc_create_channel_10>:
    {
        return ACTIVE;
    }
    else if (splitter->inactive_streams & channel_mask)
8420201e:	5d 50       	r3 = r1 LSHIFT -2;
84202020:	ad 10       	r3 = r3 AND r0;
84202022:	ad c0       	r3 = r3 AND 0x3;
84202024:	07 62       	if NE jump (m) Lc_create_channel_13;

84202026 <Lc_create_channel_11>:
    {
        return INACTIVE;
    }
    else if (splitter->hold_streams & channel_mask)
84202026:	db 50       	r1 = r1 LSHIFT -4;
84202028:	d2 10       	r0 = r0 AND r1;
8420202a:	92 c0       	r0 = r0 AND 0x3;
8420202c:	03 60       	if EQ jump (m) Lc_create_channel_13;

8420202e <Lc_create_channel_12>:
 */
static inline void set_current_output_state(SPLITTER_OP_DATA *splitter, unsigned index, SPLITTER_OUTPUT_STATE output_state)
{
    SPLITTER_DEBUG_INSTR(PL_ASSERT(index < SPLITTER_MAX_OUTPUTS_PER_CHANNEL));

    splitter->output_state[index] = output_state;
8420202e:	32 2a       	r0 = r4 + 24;
84202030:	54 ea       	MB[r0 + rMAC] = r2;

84202032 <Lc_create_channel_13>:
84202032:	49 20       	rMAC = rMAC + 1;

84202034 <Lc__loop0>:
84202034:	42 08       	r0 = r6 + Null;
84202036:	21 6e       	jump (m) Lc_create_channel_22;

84202038 <Lc_create_channel_15>:
    {
        buffer_size = splitter->buffer_size/2;
    }
    else
    {
        buffer_size = splitter->buffer_size;
84202038:	b7 88       	r5 = M[r4 + 8];

8420203a <Lc_create_channel_16>:
    }

    /* Allocate the buffer. Metadata flag is set later. */
    if (create_internal_data_buffer(splitter, buffer_size, &internal_buff) == FALSE)
8420203a:	84 11       	r2 = FP + 24;
8420203c:	3b 00       	r1 = r5 + Null;
8420203e:	32 00       	r0 = r4 + Null;
84202040:	8d 4f       	call (m) Lc_create_internal_data_buffer_1;
84202042:	10 04       	Null = r0 - Null;
84202044:	0c 62       	if NE jump (m) Lc_create_channel_19;

84202046 <Lc_create_channel_17>:
    {
        SPLITTER_ERRORMSG("splitter: Unable to allocate internal buffer for the channel!" );
84202046:	55 f1 02 f0 	r0 = Null + 357568416;
8420204a:	a0 5b 
8420204c:	ef fd f4 ff 	call (m) 0x9a2;
84202050:	37 ea 

84202052 <Lc_create_channel_18>:
    {
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
            /* Free up the channel structure.*/
            pdelete(channel);
84202052:	42 08       	r0 = r6 + Null;
84202054:	ff fd 17 f0 	call (m) 0x4f62;
84202058:	2f e8 
8420205a:	c4 6f       	jump (m) Lc_create_channel_3;

8420205c <Lc_create_channel_19>:
        pdelete(channel);
        return NULL;
    }

#ifdef INSTALL_METADATA
    if (internal_metadata_buff == NULL)
8420205c:	0f f9 00 c2 	Null = r7 - Null;
84202060:	cb 63       	if NE jump (m) Lc_create_channel_7;

84202062 <Lc_create_channel_20>:
    {
        if (create_internal_metadata(splitter, &internal_buff, buffer_size) == FALSE)
84202062:	83 11       	r1 = FP + 24;
84202064:	3c 00       	r2 = r5 + Null;
84202066:	32 00       	r0 = r4 + Null;
84202068:	fc ff 35 e1 	call (m) $_create_internal_metadata;
8420206c:	10 04       	Null = r0 - Null;
8420206e:	c4 63       	if NE jump (m) Lc_create_channel_7;

84202070 <Lc_create_channel_21>:
        {
            destroy_internal_data_buffer(splitter, &internal_buff);
84202070:	83 11       	r1 = FP + 24;
84202072:	32 00       	r0 = r4 + Null;
84202074:	9a 4f       	call (m) Lc_destroy_internal_data_buffer_1;
84202076:	ee 6f       	jump (m) Lc_create_channel_18;

84202078 <Lc_create_channel_22>:
            }
        }
    }

    return channel;
}
84202078:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
8420207a:	d8 4c       	rts;

8420207c <Lc_delete_channel_1>:

/**
 * Deletes the channel.
 */
static void delete_channel(SPLITTER_OP_DATA *splitter, SPLITTER_CHANNEL_STRUC *channel)
{
8420207c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420207e:	1e 00       	r4 = r1 + Null;
    SPLITTER_MSG1("splitter: Deleting channel %d !", channel->id);
    /* Select the correct interface */
    if (splitter->location == INTERNAL)
84202080:	51 81       	rMAC = MBS[r0 + 5];
84202082:	07 62       	if NE jump (m) Lc_delete_channel_4;

84202084 <Lc_delete_channel_2>:
    {
        if (channel->internal.buffer.dsp != NULL)
84202084:	72 89       	r0 = M[r4 + 20];
84202086:	09 60       	if EQ jump (m) Lc_delete_channel_6;

84202088 <Lc_delete_channel_3>:
        {
            SPLITTER_MSG1("Deleting internal buffer 0x%08x",channel->internal.buffer.dsp);
            cbuffer_destroy(channel->internal.buffer.dsp);
84202088:	ff fd 83 f0 	call (m) 0x12802;
8420208c:	3b eb 
8420208e:	05 6e       	jump (m) Lc_delete_channel_6;

84202090 <Lc_delete_channel_4>:
        }
    }
    else
    {
#ifdef SPLITTER_EXT_BUFFER
        if (channel->internal.buffer.sram != NULL)
84202090:	72 89       	r0 = M[r4 + 20];
84202092:	03 60       	if EQ jump (m) Lc_delete_channel_6;

84202094 <Lc_delete_channel_5>:
        {
            SPLITTER_MSG1("Deleting internal sram buffer 0x%08x",channel->internal.buffer.sram);
            ext_buffer_destroy(channel->internal.buffer.sram);
84202094:	01 f0 27 e1 	call (m) $_ext_buffer_destroy;

84202098 <Lc_delete_channel_6>:
        PL_ASSERT(splitter->location == INTERNAL);
#endif
    }

    /* delete the channel structure */
    pdelete(channel);
84202098:	32 00       	r0 = r4 + Null;
8420209a:	ff fd 17 f0 	call (m) 0x4f62;
8420209e:	29 e6 

842020a0 <Lc_delete_channel_7>:
}
842020a0:	f1 48       	popm <FP, r4, rLink>;
842020a2:	d8 4c       	rts;

842020a4 <$_un_pack_audio>:
842020a4:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
    return num_octets>>1;
}


unsigned un_pack_audio(tCbuffer * dst, tCbuffer *src, unsigned num_samples)
{
842020a6:	10 09       	r6 = r0 + Null;
842020a8:	1f 00       	r5 = r1 + Null;
    unsigned num_octets, temp_data_space;


    num_octets = num_samples<<1;
842020aa:	26 54       	r4 = r2 LSHIFT 1;

    PL_ASSERT(cbuffer_get_usable_octets(src) == 4);
842020ac:	3a 00       	r0 = r5 + Null;
842020ae:	ac 4e       	call (m) $_cbuffer_get_usable_octets;
842020b0:	10 25       	Null = r0 - 4;
842020b2:	08 60       	if EQ jump (m) Lc_un_pack_audio_3;

842020b4 <Lc_un_pack_audio_2>:
842020b4:	c3 39       	r1 = Null + 55;
842020b6:	02 f0 13 60 	r0 = Null + 4115;
842020ba:	ff fd 8f f0 	call (m) 0x13f12;
842020be:	39 e2 
842020c0:	15 6e       	jump (m) Lc_un_pack_audio_8;

842020c2 <Lc_un_pack_audio_3>:
    temp_data_space = cbuffer_calc_amount_data_ex(src);
842020c2:	3a 00       	r0 = r5 + Null;
842020c4:	bc 4e       	call (m) $_cbuffer_calc_amount_data_ex;
    if (temp_data_space < num_octets)
842020c6:	90 05       	Null = r0 - r4;
842020c8:	02 f0 87 e0 	if C jump (m) Lc_un_pack_audio_5;

842020cc <Lc_un_pack_audio_4>:
    {
        num_octets = temp_data_space;
842020cc:	16 00       	r4 = r0 + Null;

842020ce <Lc_un_pack_audio_5>:
    }

    /* Convert from samples to octets. */
    temp_data_space = cbuffer_calc_amount_space_in_words(dst)<<1;
842020ce:	42 08       	r0 = r6 + Null;
842020d0:	ff fd 50 f1 	call (m) 0x2c1b6;
842020d4:	27 e7 
842020d6:	12 54       	r0 = r0 LSHIFT 1;
    if (temp_data_space < num_octets)
842020d8:	90 05       	Null = r0 - r4;
842020da:	02 f0 87 e0 	if C jump (m) Lc_un_pack_audio_7;

842020de <Lc_un_pack_audio_6>:
    {
        num_octets = temp_data_space;
842020de:	16 00       	r4 = r0 + Null;

842020e0 <Lc_un_pack_audio_7>:
    }

    cbuffer_copy_packed_to_audio_shift(dst, src, num_octets>>1);
842020e0:	34 50       	r2 = r4 LSHIFT -1;
842020e2:	3b 00       	r1 = r5 + Null;
842020e4:	42 08       	r0 = r6 + Null;
842020e6:	d8 4e       	call (m) $_cbuffer_copy_packed_to_audio_shift;

    /*we still need to return samples*/
    return num_octets>>1;
842020e8:	32 50       	r0 = r4 LSHIFT -1;

842020ea <Lc_un_pack_audio_8>:
}
842020ea:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842020ec:	d8 4c       	rts;

842020ee <$_pack_audio>:

/****************************************************************************
Private Function Definitions
*/
unsigned pack_audio(tCbuffer * dst, tCbuffer *src, unsigned num_samples)
{
842020ee:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842020f0:	10 09       	r6 = r0 + Null;
842020f2:	1f 00       	r5 = r1 + Null;
842020f4:	26 00       	r4 = r2 + Null;
    unsigned num_octets, temp_data_space;

    temp_data_space = cbuffer_calc_amount_data_in_words(src);
842020f6:	3a 00       	r0 = r5 + Null;
842020f8:	ff fd 50 f1 	call (m) 0x2c208;
842020fc:	31 e8 
    if (temp_data_space < num_samples)
842020fe:	90 05       	Null = r0 - r4;
84202100:	02 f0 87 e0 	if C jump (m) Lc_pack_audio_3;

84202104 <Lc_pack_audio_2>:
    {
        num_samples = temp_data_space;
84202104:	16 00       	r4 = r0 + Null;

84202106 <Lc_pack_audio_3>:
    }

    /* Because the audio is packed a sample only occupies 2 octets.*/
    num_octets = num_samples<<1;
84202106:	36 54       	r4 = r4 LSHIFT 1;

    temp_data_space = cbuffer_calc_amount_space_ex(dst);
84202108:	42 08       	r0 = r6 + Null;
8420210a:	a2 4e       	call (m) $_cbuffer_calc_amount_space_ex;
    if (temp_data_space < num_octets)
8420210c:	90 05       	Null = r0 - r4;
8420210e:	02 f0 87 e0 	if C jump (m) Lc_pack_audio_5;

84202112 <Lc_pack_audio_4>:
    {
        num_octets = temp_data_space;
84202112:	16 00       	r4 = r0 + Null;

84202114 <Lc_pack_audio_5>:
    }

    /* Call splitters packing function. */
    cbuffer_copy_audio_shift_to_packed(dst, src, num_octets>>1);
84202114:	34 50       	r2 = r4 LSHIFT -1;
84202116:	3b 00       	r1 = r5 + Null;
84202118:	42 08       	r0 = r6 + Null;
8420211a:	b5 4e       	call (m) $_cbuffer_copy_audio_shift_to_packed;

    /*we still need to return samples*/
    return num_octets>>1;
8420211c:	32 50       	r0 = r4 LSHIFT -1;

8420211e <Lc_pack_audio_6>:
}
8420211e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202120:	d8 4c       	rts;

84202122 <$_advance_packed>:
    /*we still need to return samples*/
    return num_octets>>1;
}

void advance_packed(tCbuffer *cbuffer, unsigned num_samples)
{
84202122:	c8 1c       	pushm <FP(=SP), rLink>;

    unsigned num_octets;
    num_octets = num_samples<<1;
84202124:	1b 54       	r1 = r1 LSHIFT 1;
    cbuffer_advance_read_ptr_ex(cbuffer, num_octets);
84202126:	a6 4e       	call (m) $_cbuffer_advance_read_ptr_ex;

84202128 <Lc_advance_packed_2>:
}
84202128:	c8 48       	popm <FP, rLink>;
8420212a:	d8 4c       	rts;

8420212c <$_packed_space>:

/**
 * Function returns the number of samples which can be copied to the internal buffer.
 */
unsigned packed_space(tCbuffer *cbuffer)
{
8420212c:	c8 1c       	pushm <FP(=SP), rLink>;
    return cbuffer_calc_amount_space_ex(cbuffer) >>1;
8420212e:	90 4e       	call (m) $_cbuffer_calc_amount_space_ex;
84202130:	12 50       	r0 = r0 LSHIFT -1;

84202132 <Lc_packed_space_2>:
}
84202132:	c8 48       	popm <FP, rLink>;
84202134:	d8 4c       	rts;

84202136 <$_pack_ext_buffer_discard_data>:


#ifdef SPLITTER_EXT_BUFFER
void pack_ext_buffer_discard_data(EXT_BUFFER * eb, unsigned int num_samples)
{
84202136:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<1;
84202138:	1b 54       	r1 = r1 LSHIFT 1;
    ext_buffer_discard_data(eb, num_octets);
8420213a:	f6 4e       	call (m) $_ext_buffer_discard_data;

8420213c <Lc_pack_ext_buffer_discard_data_2>:
}
8420213c:	c8 48       	popm <FP, rLink>;
8420213e:	d8 4c       	rts;

84202140 <$_audio_ext_buffer_discard_data>:


void audio_ext_buffer_discard_data(EXT_BUFFER * eb, unsigned int num_samples)
{
84202140:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
84202142:	5b 54       	r1 = r1 LSHIFT 2;
    ext_buffer_discard_data(eb, num_octets);
84202144:	f1 4e       	call (m) $_ext_buffer_discard_data;

84202146 <Lc_audio_ext_buffer_discard_data_2>:
}
84202146:	c8 48       	popm <FP, rLink>;
84202148:	d8 4c       	rts;

8420214a <$_pack_ext_buffer_amount_space>:

unsigned int pack_ext_buffer_amount_space(EXT_BUFFER * eb)
{
8420214a:	c8 1c       	pushm <FP(=SP), rLink>;
    return ext_buffer_amount_space(eb)>>1;
8420214c:	c0 4e       	call (m) $_ext_buffer_amount_space;
8420214e:	12 50       	r0 = r0 LSHIFT -1;

84202150 <Lc_pack_ext_buffer_amount_space_2>:

}
84202150:	c8 48       	popm <FP, rLink>;
84202152:	d8 4c       	rts;

84202154 <$_audio_ext_buffer_amount_space>:

unsigned int audio_ext_buffer_amount_space(EXT_BUFFER * eb)
{
84202154:	c8 1c       	pushm <FP(=SP), rLink>;
    return ext_buffer_amount_space(eb)>>2;
84202156:	bb 4e       	call (m) $_ext_buffer_amount_space;
84202158:	52 50       	r0 = r0 LSHIFT -2;

8420215a <Lc_audio_ext_buffer_amount_space_2>:

}
8420215a:	c8 48       	popm <FP, rLink>;
8420215c:	d8 4c       	rts;

8420215e <$_audio_ext_buffer_circ_read>:


unsigned int audio_ext_buffer_circ_read(tCbuffer * dest, EXT_BUFFER * ext_src, unsigned int num_samples)
{
8420215e:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
84202160:	64 54       	r2 = r2 LSHIFT 2;

    return ext_buffer_circ_read(dest, ext_src, num_octets)>>2;
84202162:	be 4e       	call (m) $_ext_buffer_circ_read;
84202164:	52 50       	r0 = r0 LSHIFT -2;

84202166 <Lc_audio_ext_buffer_circ_read_2>:
}
84202166:	c8 48       	popm <FP, rLink>;
84202168:	d8 4c       	rts;

8420216a <$_audio_ext_buffer_circ_write>:

unsigned int audio_ext_buffer_circ_write(EXT_BUFFER * ext_dest, tCbuffer * src, unsigned int num_samples)
{
8420216a:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned num_octets;
    num_octets = num_samples<<2;
8420216c:	64 54       	r2 = r2 LSHIFT 2;

    return ext_buffer_circ_write(ext_dest, src, num_octets)>>2;
8420216e:	c1 4e       	call (m) $_ext_buffer_circ_write;
84202170:	52 50       	r0 = r0 LSHIFT -2;

84202172 <Lc_audio_ext_buffer_circ_write_2>:
}
84202172:	c8 48       	popm <FP, rLink>;
84202174:	d8 4c       	rts;

84202176 <$_opmgr_op_is_running>:
84202176:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
84202178:	10 b0       	Null = MBS[r0 + 24];
8420217a:	20 f0 41 ce 	if EQ rMAC = Null + 1;
8420217e:	0a 00       	r0 = rMAC + Null;

84202180 <Lc_opmgr_op_is_running_2>:
84202180:	d8 4c       	rts;

84202182 <$_opmgr_op_suspend_processing>:
{
    op_data->cap_class_ext = class_data;
}

void opmgr_op_suspend_processing(OPERATOR_DATA *op_data)
{
84202182:	c8 1c       	pushm <FP(=SP), rLink>;
    interrupt_block();
84202184:	ff fd 55 f1 	call (m) 0x2cc9c;
84202188:	39 e8 

8420218a <Lc_opmgr_op_suspend_processing_2>:
}
8420218a:	c8 48       	popm <FP, rLink>;
8420218c:	d8 4c       	rts;

8420218e <$_opmgr_op_resume_processing>:

void opmgr_op_resume_processing(OPERATOR_DATA *op_data)
{
8420218e:	c8 1c       	pushm <FP(=SP), rLink>;
    interrupt_unblock();
84202190:	ff fd 55 f1 	call (m) 0x2ccb8;
84202194:	29 e9 

84202196 <Lc_opmgr_op_resume_processing_2>:
}
84202196:	c8 48       	popm <FP, rLink>;
84202198:	d8 4c       	rts;

8420219a <$_base_op_get_sched_info_ex>:
{
    return op_data->cap_data->id;
}

OP_SCHED_INFO_RSP* base_op_get_sched_info_ex(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id)
{
8420219a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420219c:	16 00       	r4 = r0 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = xzpnew(OP_SCHED_INFO_RSP);
8420219e:	c3 20       	r1 = Null + 3;
842021a0:	02 29       	r0 = Null + 20;
842021a2:	ff fd 16 f0 	call (m) 0x4f2a;
842021a6:	29 ec 
    if (resp == NULL)
842021a8:	10 04       	Null = r0 - Null;
842021aa:	03 62       	if NE jump (m) Lc_base_op_get_sched_info_ex_3;

842021ac <Lc_base_op_get_sched_info_ex_2>:
    {
        return NULL;
842021ac:	02 00       	r0 = Null + Null;
842021ae:	04 6e       	jump (m) Lc_base_op_get_sched_info_ex_4;

842021b0 <Lc_base_op_get_sched_info_ex_3>:
    }

    resp->op_id = op_data->id;
842021b0:	71 88       	rMAC = M[r4 + 4];
842021b2:	11 ee       	M[r0 + Null] = rMAC;
    resp->status = STATUS_OK;
842021b4:	50 8e       	M[r0 + 4] = Null;

842021b6 <Lc_base_op_get_sched_info_ex_4>:

    return resp;
842021b6:	f1 48       	popm <FP, r4, rLink>;
842021b8:	d8 4c       	rts;

842021ba <$_base_op_build_std_response_ex>:
    return op_data->state == OP_RUNNING;
}

/* will allocate and create a success message, with zeroed error_code field */
bool base_op_build_std_response_ex(OPERATOR_DATA *op_data, STATUS_KYMERA status, void **response_data)
{
842021ba:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842021bc:	16 00       	r4 = r0 + Null;
842021be:	1f 00       	r5 = r1 + Null;
842021c0:	20 09       	r6 = r2 + Null;
    OP_STD_RSP* resp = xzpnew(OP_STD_RSP);
842021c2:	c3 20       	r1 = Null + 3;
842021c4:	02 23       	r0 = Null + 12;
842021c6:	ff fd 16 f0 	call (m) 0x4f2a;
842021ca:	25 eb 

    if (resp == NULL)
842021cc:	10 04       	Null = r0 - Null;
842021ce:	03 62       	if NE jump (m) Lc_base_op_build_std_response_ex_3;

842021d0 <Lc_base_op_build_std_response_ex_2>:
    {
        return FALSE;
842021d0:	02 00       	r0 = Null + Null;
842021d2:	08 6e       	jump (m) Lc_base_op_build_std_response_ex_4;

842021d4 <Lc_base_op_build_std_response_ex_3>:
    }

    resp->op_id = op_data->id;
842021d4:	71 88       	rMAC = M[r4 + 4];
842021d6:	11 ee       	M[r0 + Null] = rMAC;
    resp->resp_data.err_code = 0;
842021d8:	90 8e       	M[r0 + 8] = Null;
    resp->status = status;
842021da:	57 8e       	M[r0 + 4] = r5;

    *response_data = resp;
842021dc:	82 f0 00 ee 	M[r6 + Null] = r0;
    return TRUE;
842021e0:	42 20       	r0 = Null + 1;

842021e2 <Lc_base_op_build_std_response_ex_4>:
}
842021e2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842021e4:	d8 4c       	rts;

842021e6 <$_base_op_get_instance_data>:

void* base_op_get_instance_data(OPERATOR_DATA *op_data)
{
    return op_data->extra_op_data;
842021e6:	12 99       	r0 = M[r0 + 48];

842021e8 <Lc_base_op_get_instance_data_2>:
842021e8:	d8 4c       	rts;

842021ea <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_splitter_cap_data;
842021ea:	07 f0 02 f0 	r0 = Null + 7340032;
842021ee:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842021f0:	20 f0 b0 41 	Null = Null + 16816;

842021f4 <$_cbuffer_copy_ex>:
.MODULE $M.download_support_lib.cbuffer_copy_ex;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_copy_ex:
    rMAC = M[$_patched_fw_version];
842021f4:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842021f8:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_COPY_EX;
842021fc:	fc ff b0 f0 	if EQ jump (m) 0x400811a;
84202200:	9f ee 

84202202 <$M.download_support_lib.cbuffer_copy_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202202:	02 00       	r0 = Null + Null;
    rts;
84202204:	d8 4c       	rts;

84202206 <$_cbuffer_get_usable_octets>:
.MODULE $M.download_support_lib.cbuffer_get_usable_octets;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_get_usable_octets:
    rMAC = M[$_patched_fw_version];
84202206:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420220a:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_GET_USABLE_OCTETS;
8420220e:	fc ff b0 f0 	if EQ jump (m) 0x40080d6;
84202212:	c9 ed 

84202214 <$M.download_support_lib.cbuffer_get_usable_octets.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202214:	02 00       	r0 = Null + Null;
    rts;
84202216:	d8 4c       	rts;

84202218 <$_cbuffer_set_usable_octets>:
.MODULE $M.download_support_lib.cbuffer_set_usable_octets;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_set_usable_octets:
    rMAC = M[$_patched_fw_version];
84202218:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420221c:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_SET_USABLE_OCTETS;
84202220:	fc ff b0 f0 	if EQ jump (m) 0x40080ea;
84202224:	cb ed 

84202226 <$M.download_support_lib.cbuffer_set_usable_octets.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202226:	02 00       	r0 = Null + Null;
    rts;
84202228:	d8 4c       	rts;

8420222a <$_cbuffer_get_read_address_ex>:
.MODULE $M.download_support_lib.cbuffer_get_read_address_ex;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_get_read_address_ex:
    rMAC = M[$_patched_fw_version];
8420222a:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420222e:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_GET_READ_ADDRESS_EX;
84202232:	fc ff e0 f0 	if EQ jump (m) 0x4009a1a;
84202236:	e9 ef 

84202238 <$M.download_support_lib.cbuffer_get_read_address_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202238:	02 00       	r0 = Null + Null;
    rts;
8420223a:	d8 4c       	rts;

8420223c <$_cbuffer_calc_amount_data_ex>:
.CODESEGMENT PM;
.MINIM;

$cbuffer.calc_amount_data_ex:
$_cbuffer_calc_amount_data_ex:
    rMAC = M[$_patched_fw_version];
8420223c:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202240:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_CALC_AMOUNT_DATA_EX;
84202244:	fc ff f0 f0 	if EQ jump (m) 0x4009a82;
84202248:	bf e0 

8420224a <$M.download_support_lib.cbuffer_calc_amount_data_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
8420224a:	02 00       	r0 = Null + Null;
    rts;
8420224c:	d8 4c       	rts;

8420224e <$_cbuffer_calc_amount_space_ex>:
.CODESEGMENT PM;
.MINIM;

$cbuffer.calc_amount_space_ex:
$_cbuffer_calc_amount_space_ex:
    rMAC = M[$_patched_fw_version];
8420224e:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202252:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_CALC_AMOUNT_SPACE_EX;
84202256:	fc ff f0 f0 	if EQ jump (m) 0x4009ad2;
8420225a:	fd e0 

8420225c <$M.download_support_lib.cbuffer_calc_amount_space_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
8420225c:	02 00       	r0 = Null + Null;
    rts;
8420225e:	d8 4c       	rts;

84202260 <$_cbuffer_set_read_address_ex>:
.CODESEGMENT PM;
.MINIM;

$cbuffer.set_read_address_ex:
$_cbuffer_set_read_address_ex:
    rMAC = M[$_patched_fw_version];
84202260:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202264:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_SET_READ_ADDRESS_EX;
84202268:	fc ff f0 f0 	if EQ jump (m) 0x4009b38;
8420226c:	d1 e1 

8420226e <$M.download_support_lib.cbuffer_set_read_address_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
8420226e:	02 00       	r0 = Null + Null;
    rts;
84202270:	d8 4c       	rts;

84202272 <$_cbuffer_advance_read_ptr_ex>:
.CODESEGMENT PM;
.MINIM;

$cbuffer.advance_read_ptr_ex:
$_cbuffer_advance_read_ptr_ex:
    rMAC = M[$_patched_fw_version];
84202272:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202276:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_ADVANCE_READ_PTR_EX;
8420227a:	fc ff f0 f0 	if EQ jump (m) 0x4009bf8;
8420227e:	ff e2 

84202280 <$M.download_support_lib.cbuffer_advance_read_ptr_ex.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202280:	02 00       	r0 = Null + Null;
    rts;
84202282:	d8 4c       	rts;

84202284 <$_cbuffer_copy_audio_shift_to_packed>:
.MODULE $M.download_support_lib.cbuffer_copy_audio_shift_to_packed;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_copy_audio_shift_to_packed:
    rMAC = M[$_patched_fw_version];
84202284:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202288:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_COPY_AUDIO_SHIFT_TO_PACKED;
8420228c:	fc ff f0 f0 	if EQ jump (m) 0x400a204;
84202290:	f9 ee 

84202292 <$M.download_support_lib.cbuffer_copy_audio_shift_to_packed.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202292:	02 00       	r0 = Null + Null;
    rts;
84202294:	d8 4c       	rts;

84202296 <$_cbuffer_copy_packed_to_audio_shift>:
.MODULE $M.download_support_lib.cbuffer_copy_packed_to_audio_shift;
.CODESEGMENT PM;
.MINIM;

$_cbuffer_copy_packed_to_audio_shift:
    rMAC = M[$_patched_fw_version];
84202296:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420229a:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_CBUFFER_COPY_PACKED_TO_AUDIO_SHIFT;
8420229e:	fc ff 00 f1 	if EQ jump (m) 0x400a2bc;
842022a2:	9f e0 

842022a4 <$M.download_support_lib.cbuffer_copy_packed_to_audio_shift.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022a4:	02 00       	r0 = Null + Null;
    rts;
842022a6:	d8 4c       	rts;

842022a8 <$_ext_buffer_create>:
.MODULE $M.download_support_lib.ext_buffer_create;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_create:
    rMAC = M[$_patched_fw_version];
842022a8:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842022ac:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_BUFFER_CREATE;
842022b0:	fc ff b0 f0 	if EQ jump (m) 0x400820c;
842022b4:	dd ee 

842022b6 <$M.download_support_lib.ext_buffer_create.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022b6:	02 00       	r0 = Null + Null;
    rts;
842022b8:	d8 4c       	rts;

842022ba <$_ext_buffer_destroy>:
.MODULE $M.download_support_lib.ext_buffer_destroy;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_destroy:
    rMAC = M[$_patched_fw_version];
842022ba:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842022be:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_BUFFER_DESTROY;
842022c2:	fc ff b0 f0 	if EQ jump (m) 0x4008266;
842022c6:	a5 ef 

842022c8 <$M.download_support_lib.ext_buffer_destroy.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022c8:	02 00       	r0 = Null + Null;
    rts;
842022ca:	d8 4c       	rts;

842022cc <$_ext_buffer_amount_space>:
.MODULE $M.download_support_lib.ext_buffer_amount_space;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_amount_space:
    rMAC = M[$_patched_fw_version];
842022cc:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842022d0:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_AMOUNT_SPACE;
842022d4:	fc ff c0 f0 	if EQ jump (m) 0x400832e;
842022d8:	db e0 

842022da <$M.download_support_lib.ext_buffer_amount_space.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022da:	02 00       	r0 = Null + Null;
    rts;
842022dc:	d8 4c       	rts;

842022de <$_ext_buffer_circ_read>:
.MODULE $M.download_support_lib.ext_buffer_circ_read;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_circ_read:
    rMAC = M[$_patched_fw_version];
842022de:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842022e2:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_CIRC_READ;
842022e6:	fc ff c0 f0 	if EQ jump (m) 0x4008410;
842022ea:	ab e2 

842022ec <$M.download_support_lib.ext_buffer_circ_read.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022ec:	02 00       	r0 = Null + Null;
    rts;
842022ee:	d8 4c       	rts;

842022f0 <$_ext_buffer_circ_write>:
.MODULE $M.download_support_lib.ext_buffer_circ_write;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_circ_write:
    rMAC = M[$_patched_fw_version];
842022f0:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
842022f4:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_CIRC_WRITE;
842022f8:	fc ff c0 f0 	if EQ jump (m) 0x40084ba;
842022fc:	c3 e3 

842022fe <$M.download_support_lib.ext_buffer_circ_write.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
842022fe:	02 00       	r0 = Null + Null;
    rts;
84202300:	d8 4c       	rts;

84202302 <$_ext_buffer_get_read_offset>:
.MODULE $M.download_support_lib.ext_buffer_get_read_offset;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_get_read_offset:
    rMAC = M[$_patched_fw_version];
84202302:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202306:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_GET_READ_OFFSET;
8420230a:	fc ff b0 f0 	if EQ jump (m) 0x4008286;
8420230e:	fd ee 

84202310 <$M.download_support_lib.ext_buffer_get_read_offset.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202310:	02 00       	r0 = Null + Null;
    rts;
84202312:	d8 4c       	rts;

84202314 <$_ext_buffer_set_read_offset>:
.MODULE $M.download_support_lib.ext_buffer_set_read_offset;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_set_read_offset:
    rMAC = M[$_patched_fw_version];
84202314:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202318:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_SET_READ_OFFSET;
8420231c:	fc ff b0 f0 	if EQ jump (m) 0x40082a8;
84202320:	8d ef 

84202322 <$M.download_support_lib.ext_buffer_set_read_offset.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202322:	02 00       	r0 = Null + Null;
    rts;
84202324:	d8 4c       	rts;

84202326 <$_ext_buffer_discard_data>:
.MODULE $M.download_support_lib.ext_buffer_discard_data;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_discard_data:
    rMAC = M[$_patched_fw_version];
84202326:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420232a:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_DISCARD_DATA;
8420232e:	fc ff c0 f0 	if EQ jump (m) 0x40084f6;
84202332:	c9 e3 

84202334 <$M.download_support_lib.ext_buffer_discard_data.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202334:	02 00       	r0 = Null + Null;
    rts;
84202336:	d8 4c       	rts;

84202338 <$_ext_buffer_pack>:
.MODULE $M.download_support_lib.ext_buffer_pack;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_pack:
    rMAC = M[$_patched_fw_version];
84202338:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420233c:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_BUFFER_PACK;
84202340:	fc ff c0 f0 	if EQ jump (m) 0x4008546;
84202344:	87 e4 

84202346 <$M.download_support_lib.ext_buffer_pack.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202346:	02 00       	r0 = Null + Null;
    rts;
84202348:	d8 4c       	rts;

8420234a <$_ext_buffer_unpack>:
.MODULE $M.download_support_lib.ext_buffer_unpack;
.CODESEGMENT PM;
.MINIM;

$_ext_buffer_unpack:
    rMAC = M[$_patched_fw_version];
8420234a:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420234e:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXT_BUFFER_UNPACK;
84202352:	fc ff c0 f0 	if EQ jump (m) 0x4008586;
84202356:	b5 e4 

84202358 <$M.download_support_lib.ext_buffer_unpack.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84202358:	02 00       	r0 = Null + Null;
    rts;
8420235a:	d8 4c       	rts;

8420235c <$_extmem_lock>:
.MODULE $M.download_support_lib.extmem_lock;
.CODESEGMENT PM;
.MINIM;

$_extmem_lock:
    rMAC = M[$_patched_fw_version];
8420235c:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202360:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXTMEM_LOCK;
84202364:	fc ff a0 f0 	if EQ jump (m) 0x4007640;
84202368:	dd e5 

8420236a <$M.download_support_lib.extmem_lock.L_pb_mismatch>:

L_pb_mismatch:
    r0 = 0;
8420236a:	02 00       	r0 = Null + Null;
    rts;
8420236c:	d8 4c       	rts;

8420236e <$_extmem_unlock>:
.MODULE $M.download_support_lib.extmem_unlock;
.CODESEGMENT PM;
.MINIM;

$_extmem_unlock:
    rMAC = M[$_patched_fw_version];
8420236e:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202372:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXTMEM_UNLOCK;
84202376:	fc ff a0 f0 	if EQ jump (m) 0x400768a;
8420237a:	95 e6 

8420237c <$M.download_support_lib.extmem_unlock.L_pb_mismatch>:

L_pb_mismatch:
    r0 = 0;
8420237c:	02 00       	r0 = Null + Null;
    rts;
8420237e:	d8 4c       	rts;

84202380 <$_extmem_enable_with_retry>:
.MODULE $M.download_support_lib.extmem_enable_with_retry;
.CODESEGMENT PM;
.MINIM;

$_extmem_enable_with_retry:
    rMAC = M[$_patched_fw_version];
84202380:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84202384:	10 f1 77 35 	Null = rMAC - 6519;
    if EQ jump PATCH_ENTRY_EXTMEM_ENABLE_WITH_RETRY;
84202388:	fc ff a0 f0 	if EQ jump (m) 0x40075ea;
8420238c:	e3 e4 

8420238e <$M.download_support_lib.extmem_enable_with_retry.L_pb_mismatch>:

L_pb_mismatch:
    r0 = 0;
8420238e:	02 00       	r0 = Null + Null;
    rts;
84202390:	d8 4c       	rts;
